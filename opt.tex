\newcommand{\rel}{{\tt rel}}


\section{Single Threaded Optimizations}

As we have seen already, our model {\em invalidates} thread inlining.  We
argue that our model is fully flexible with respect to single threaded
optimizations in two ways; firstly, by considering concrete examples of
single threaded optimizations, and secondly, by proving a full abstraction
theorem for single threads without synchronization.  

%In this section, we only consider commands $\aCmd$ that do not have any occurrence of $\PAR$. 

% \begin{definition}
% $\aCmd \unrhd \bCmd$ if $\sem{\aCmd} \supseteq \sem{\bCmd}$
% \end{definition}
% Thus, in this case $\aCmd$ can be transformed into $\bCmd$ in any program context.  

By Lemma~\ref{lem:monotone}, if $\sem{\aCmd} \supseteq \sem{\bCmd}$
then $\aCmd$ can be transformed into $\bCmd$ in any program context.

We follow the terminology and presentation of section~7.1 of
~\citet{Dolan:2018:BDR:3192366.3192421}, to maintain a clear comparison with models that enforce extra ordering.

\paragraph*{Peephole optimizations. } 
Certain transformations involving adjacent operations on the same location
are permissible. 
 
\begin{lemma}
  Suppose $\cExp=\dExp$ is a tautology.  Then the following optimizations hold.
% \begin{eqnarray*}
% \mbox{Redundant load} &&\sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} \supseteq  \sem{\aReg \GETS \aLoc \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Store forwarding} &&\sem{\aLoc \GETS \aReg \SEMI \bReg \GETS \aLoc \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \aReg \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Dead Store} && \sem{\aLoc \GETS \aReg \SEMI \aLoc \GETS \bReg \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \bReg \SEMI \aCmd}
% \end{eqnarray*}
\begin{align*}
  \tag{Redundant load}
  \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} &\supseteq
  \sem{\aReg \GETS \REF{\cExp} \SEMI \aCmd[\aReg/\bReg]} \\
  \tag{Store forwarding} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &\supseteq 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \aCmd[\aExp/\bReg]} \\
  \tag{Dead Store} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq 
  \sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}
\end{align*}
\begin{proof}
  In each case, the proof proceeds by observing that the semantics allows us
  to use an implicit action on the lefthand side.  For dead store
  elimination, note that
  $\sem{\aLoc \GETS \bReg \SEMI \aCmd} = \DW{\aLoc}{} \guard \sem{\aLoc \GETS
    \bReg \SEMI \aCmd}$.
\end{proof}
\end{lemma}
  
\paragraph*{Reorderings of independent statements}

$\aLoc$ and $\aCmd$ are independent if there are no writes to $\aLoc$ or reads from $\aLoc$ in $\aCmd$.  
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{Read-read}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &=
    \sem{\bReg \GETS \REF{\dExp} \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{Read-write}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Write-write}
    \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp} \GETS \aExp \SEMI \aCmd}
  \end{align*}
\begin{proof}
  The result follows immediately from the semantics of prefixing where the
  only enforced $\lt$ and $\gtN$ relationships come from conflict on $\aLoc$ or
  release actions in $\aCmd$.
\end{proof}
\end{lemma}

\paragraph*{Compiler optimizations.} Reordering and peephole optimizations can be combined to describe common  compiler optimizations.  We illustrate following~\citet{Dolan:2018:BDR:3192366.3192421}.

Common subexpression elimination. Consider the command 
\[ \aReg \GETS \aLoc *2  \SEMI \aCmd \SEMI \bReg \GETS \aLoc * 2 \]
where $\aCmd$ is independent of $\bReg$.  Then, reordering yields
\[\aCmd \SEMI \aReg \GETS \aLoc *2  \SEMI  \bReg \GETS \aLoc * 2 \]
followed by redundant load to yield:
\[\aCmd \SEMI \aReg \GETS \aLoc * 2 \SEMI  \bReg \GETS \aReg\]

Similarly, the treatment of loop-invariant code motion, dead-store elimination and constant propagation from~\citet{Dolan:2018:BDR:3192366.3192421} follows mutatis-mutandis, since our model is more generous about permitted reorderings.  Thus, we permit  redundant store elimination that they forbid.
Consider:
\[ \aReg \GETS \aLoc \SEMI \bLoc \GETS \cLoc  \SEMI \aLoc \GETS \aReg \]
Reordering, permitted by us, but forbidden by them, yields
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]
followed by the valid elimination of redundant load:
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]

\endinput










\subsection{Single thread full abstraction}
We first develop some infrastructure to identify the minimal elements, wrt augmentation, $\aCmd$.  
\begin{definition}
$\aPS$ is a generator of  $\sem{\aCmd}$ if for all $\bPS \in \sem{\aCmd}$ such that $\aPS$ augments $\bPS$, $\aPS = \bPS$.
\end{definition}

$\reco$ is the specialization of the $\gtN$ to a per-location basis.  
\begin{definition}
 $ \aEv' \xeco  \bEv'$ if both $\aEv'$ and $\bEv'$ touch the same location, $\bEv' \gtN \aEv'$, and at least one of them is a write.  
\end{definition}

\begin{lemma}\label{onethread}
Let $\aCmd$ be a thread.  Then, all generators $\aPS$ of  $\semClosed{\aCmd}$  are such that:
\begin{itemize}
\item  If $\aEv\lt\bEv$ and $\aEv$ is a release or a write, then $\bEv$ is a release action.
\item  If $\aEv\lt\bEv$ and $\bEv$ is an acquire or a read, then $\aEv$ is an acquire action.
%\item  If both $\aEv$ and $\bEv$ touch the same location and, 
%then $\bEv \gtN \aEv$ or $\aEv \gtN \bEv$.
 \item  $\aEv \gtN \bEv$ if and only if $ \aEv [\lt \cup (\le; \reco; 
\le)] \bEv$. 
\end{itemize}
\end{lemma}
The proof proceeds considering the minimal requirements on the order relations imposed by the semantics.  The key case is prefixing.  The only required $\lt$-edges out of writes are into release actions, and the only required $\lt$-edges into reads arise from read actions. 

Any optimisation which does not shrink the subrelations of $\rpox$ listed in lemma~\ref{onethread} is permissible.  







In particular, if there are no release or acquire actions in $\aCmd$:
\begin{itemize}
\item Writes are maximal
\item Reads are minimal
\end{itemize}
thus providing a particularly simple view of the semantics of threads without synchronization primitives.   