\section{Single Threaded Optimizations}
\label{sec:opt}

% In order to prove optimizations that introduce redundant actions, we need to
% make appeal to program order, defined in \textsection\ref{sec:sc}.
% Two events are \emph{redundant} if 
% $\labelingAct(\bEv)=\labelingAct(\aEv)$ is relaxed,
% $\labelingForm(\bEv)\land\labelingForm(\aEv)$ is satisfiable,
% $\bEv\xpox\aEv$ and 
% $\lnot(\bEv\le\aEv)$.

% Let $\fsatrep(\aPSS)$ be the subset $\fsat(\aPSS)$ that contains no pomset
% with a redundant action.

As we have seen already, our model {\em invalidates} thread inlining.  We argue that our model is fully flexible with respect to single threaded optimizations; concretely by validating several 
single threaded optimizations including reordering of independent statements; and abstractly, by proving a full abstraction
theorem for single threads without synchronization and connecting to traditional Hoare logic for sequential programs. 

%In this section, we only consider commands $\aCmd$ that do not have any occurrence of $\PAR$. 

% \begin{definition}
% $\aCmd \unrhd \bCmd$ if $\sem{\aCmd} \supseteq \sem{\bCmd}$
% \end{definition}
% Thus, in this case $\aCmd$ can be transformed into $\bCmd$ in any program context.  

Let $\fsat(\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \{\aEv \in \Event\mid \labelingForm(\aEv)\;\text{is satisfiable}\textand \labelingAct(\aEv)\;\text{is external}\}$,
${\le'} = {\le}\restrict{\Event'}$,
%${\gtN'} = {\gtN}\restrict{\Event'}$.
and
${\labeling'} = {\labeling}\restrict{\Event'}$.

By Lemma~\ref{lem:monotone}, if $\sem{\aCmd} \supseteq \sem{\bCmd}$
then $\aCmd$ can be transformed into $\bCmd$ in any program context.  Since
unsatisfiable events are ignored in our architecture model, it is
an immediate corollary that it is sufficient to show that
$\fsat\sem{\aCmd} \supseteq \fsat\sem{\bCmd}$.



\subsection{Validating single threaded optimizations}
We follow the terminology and presentation of section~7.1 of
\citet{Dolan:2018:BDR:3192366.3192421}, to maintain a clear comparison with
models that enforce extra ordering.

%\paragraph*{Peephole optimizations. } 
Certain transformations involving adjacent operations on the same location
are permissible. 
 
\begin{lemma}
  Suppose $\aExp=0$ is a tautology and $\cExp=\dExp$ is a tautology.   Then the following hold.
% \begin{eqnarray*}
% \mbox{Redundant load} &&\sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} \supseteq  \sem{\aReg \GETS \aLoc \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Store forwarding} &&\sem{\aLoc \GETS \aReg \SEMI \bReg \GETS \aLoc \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \aReg \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Dead Store} && \sem{\aLoc \GETS \aReg \SEMI \aLoc \GETS \bReg \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \bReg \SEMI \aCmd}
% \end{eqnarray*}
  \begin{align*}
  \tag{Dead Code} 
  \fsat\sem{\IF{\aExp}\THEN\aCmd\ELSE\bCmd\FI} &\supseteq 
  \fsat\sem{\bCmd} \\
  \tag{Dead Store} 
  \fsat\sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq 
  \fsat\sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}\\    
  \tag{Redundant load}
  \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} &\supseteq
  \sem{\aReg \GETS \REF{\cExp} \SEMI \aCmd[\aReg/\bReg]} \\
  \tag{Store forwarding} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &\supseteq 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \aCmd[\aExp/\bReg]}
\end{align*}
\begin{proof}
  For dead code elimination, the result is immediate from the semantics.
  
  For dead store, note that no event in $\aCmd$ can depend on the first store,
  therefore it may be taken with precondition $\FALSE$.
  
  For the others, the proof proceeds by observing that the semantics allows us
  to use an implicit action on the lefthand side to mimic the right hand side.
  For example, taking $\REF{\cExp}=\REF{\dExp}=\aLoc$, the argument for
  redundant load is as follows.
  \begin{align*}
    \sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} 
    \supseteq&  \sem{ \bReg  \GETS \aLoc \SEMI \aCmd[\aLoc/\aReg]} \\
    \supseteq&  \sem{\aCmd}[\aLoc/\aReg][\aLoc/\bReg] \cup  \textstyle\bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg][\aLoc/\bReg]\\
    =& \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg] \cup  \textstyle\bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg]\\
    =& \sem{\aReg \GETS \aLoc\SEMI \aCmd[\aReg/\bReg]}
    \tag*{\qedhere}
  \end{align*}
  % Similarly, store forwarding is proved by considering the implicit read subset of $\sem{\bReg \GETS \REF{\dExp} \SEMI \aCmd}$.
\end{proof}
\end{lemma}
  
%\paragraph*{Reorderings of independent statements}
Certain reorderings involving adjacent operations on the distinct locations
are also permissible. 

% $\aLoc$ and $\aCmd$ are independent if there are no writes to $\aLoc$ or reads from $\aLoc$ in $\aCmd$.  
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{R-R}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &=
    \sem{\bReg \GETS \REF{\dExp} \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{R-W}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{W-W}
    \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp} \GETS \aExp \SEMI \aCmd}
  \end{align*}
\begin{proof}
The proof of both of the above lemmas follows from the semantics of prefixing where the only enforced $\lt$ relationships come from conflict on $\aLoc$ or release actions in $\aCmd$.
\end{proof}
\end{lemma}

Roach-motel reorderings that increase the scope of synchronization are valid.
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{R-Acq}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}\ACQ \SEMI \aCmd} &\supseteq
    \sem{\bReg \GETS \REF{\dExp}\ACQ\SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
&&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{W-Acq} 
    \sem{\REF{\dExp} \GETS \bExp \SEMI\aReg \GETS \REF{\cExp}\ACQ \SEMI\aCmd} &\supseteq
    \sem{\aReg \GETS \REF{\cExp}\ACQ  \SEMI \REF{\dExp}\GETS \bExp \SEMI \aCmd} 
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
\tag{Rel-R} 
\sem{\REF{\dExp}\REL \GETS \bExp \SEMI\aReg \GETS \REF{\cExp} \SEMI \aCmd} &\supseteq
    \sem{ \aReg \GETS \REF{\cExp} \SEMI \REF{\dExp}\REL \GETS \bExp \SEMI \aCmd}
   &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Rel-W}
    \sem{\REF{\cExp}\REL \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp}\REL \GETS \aExp \SEMI \aCmd}
  \end{align*}
\begin{proof}
The proof follows from noticing that the pomsets in the semantics of the right hand sides are augmentations of a pomset on the left hand side.  
\end{proof}
\end{lemma}

\paragraph*{Compiler optimizations.} Reordering and peephole optimizations
can be combined to describe common compiler optimizations.  We illustrate
using common subexpression elimination,
following~\citet{Dolan:2018:BDR:3192366.3192421}:
Consider the command 
\begin{math}
  (\aReg \GETS \aLoc *2  \SEMI \aCmd \SEMI \bReg \GETS \aLoc * 2)
\end{math}
where $\aCmd$ is independent of $\aReg$.  Reordering yields
\begin{math}
  (\aCmd \SEMI \aReg \GETS \aLoc *2  \SEMI  \bReg \GETS \aLoc * 2),
\end{math}
followed by redundant load to yield
\begin{math}
  (\aCmd \SEMI \aReg \GETS \aLoc * 2 \SEMI  \bReg \GETS \aReg).
\end{math}

Similarly, the treatment of loop-invariant code motion, dead-store
elimination and constant propagation
from~\citet{Dolan:2018:BDR:3192366.3192421} follow.

Since
our model is more generous about permitted reorderings, we permit
optimizations that they forbid.  Consider:
\begin{math}
  (\aReg \GETS \aLoc \SEMI \bLoc \GETS \cLoc  \SEMI \aLoc \GETS \aReg).
\end{math}
Reordering, permitted by us, but forbidden by them, yields
\begin{math}
  (\aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc),
\end{math}
followed by the valid elimination of redundant load
\begin{math}
  (\aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc).
\end{math}

\subsection{Full abstraction for synchronization free threads}
Our semantics is complete for reasoning about full-thread optimizations of synchronization free programs.

In the rest of this section, we only consider commands $\aCmd,\bCmd$ that are
restriction-free, composition-free (ie. single threaded), and
synchronization-free (ie. no acquire, release, fence).

In order to develop the proof, we first make the semantics insensitive to
reads that are never used.  Let $\readc(\aPSS)$ be the smallest augmentation
closed set containing $\aPSS$ that also satisfies closure under the inclusion
of useless reads: if $\aPS \in \readc(\aPSS)$, then
$\aPS' \in \readc(\aPSS)$, where $\Event'= \Event\cup\{\aEv\}$,
$\aEv \not \in \Event$, ${\le'} ={\le}$,
${\labeling'} \restrict \Event = {\labeling}$, and
$\labeling'(\aEv) = \DR{\aLoc}{\aVal}$ for any $\aLoc$ and $\aVal$.

Let $\freadsat(\aPSS)= \readc(\fsat(\aPSS))$.

This closure permits us to  describe a normal form for the top-level pomsets that arise in single threaded and synchronization free code.  
\begin{definition}
$\aPS$ is in normal form if:
\begin{itemize}
% \item All preconditions on events are tautologies.
\item If $\bEv \lt \aEv$ and  $\bEv$ is a write, then $\aEv$ is a write or read on the same variable.
\item If $\bEv \lt \aEv$ and  $\aEv$ is a read, then $\bEv$ is a write on the same variable. 
    
% \item $\aEv \gtN \bEv$ only if $ \aEv\ (\lt \cup \reco)^{\star} \  \bEv$.
\item If $\aEv, \aEv'$ have the same read action label, then there exists a write $\bEv$ on the same location such that $\aEv \gtN \bEv \gtN \aEv'$.
%\item  If $\aEv, \aEv'$ have the same write action label, then 
%there exists a event $\bEv$ on the same location as $\aEv$ such 
%that  $\bEv$ has a different action label and $\aEv \gtN \bEv \gtN 
%\aEv'$.
\end{itemize}
\end{definition}
In a normal form pomset, the successors of a write event (resp. the predecessors of a read) are related in the coherence order to the event.  Any two events with the same read label are separated by a write in the $\reco$ order. 

It suffices to consider normal forms when distinguishing single threaded, synchronization free code at the top level.  The normal forms determine the full semantics by the closure properties of the semantics.

\begin{lemma}\label{unrhd}
Every top-level pomset of $\freadsat\sem{\aCmd}$ is a top-level pomset of $\freadsat\sem{\bCmd}$ if and only if 
every top-level normal form pomset of $\freadsat\sem{\aCmd}$ is a top-level normal form pomset of $\freadsat\sem{\bCmd}$.
\begin{proof}
The proof proceeds by induction on structure.  The key case is prefixing.  The only edges $\lt$-edges out of writes  and into read actions enforced by prefixing are $\reco$ edges.  Read prefixing permits the reuse of events to ensure that distinct read events not separated by $\reco$ have distinct read labels.  
\end{proof}
\end{lemma}

We develop testers for top-level pomsets in normal form.  We  follow~\citet{Plotkin:1997:TSP:266557.266600}, albeit in a concrete form appropriate to our setting.   

Let $\aPS$ be a top-level pomset in normal form with events $\aEv_1, \ldots,
\aEv_n$.  For all $i$, we assume a new location $b_i$.    Let $\freshaval$ be a fresh value that does not occur in $\aPS$.  

Let $\vec{\bEv}$ be all  the predecessors of $\aEv_i$ in $\lt$. Let $\vec{c}$ be the corresponding sub vector of $b_i$'s. 
\begin{itemize}
\item 
If $\aEv_i$ has label $\DR{\aLoc}{\aVal}$, we define a program $\testP{\aPS}{i}$ as follows:  
\[
  \testP{\aPS}{i} = (
  % \vec{\aReg} \GETS \vec{c}  \SEMI
  \IF{\vec{c}=\vec{1}} \THEN x \GETS \aVal \SEMI  \FENCE \SEMI b_i \GETS 1 \FI)
\]
\item 
If $\aEv_i$ has label $\DW{\aLoc}{\aVal}$, we define a program $\testP{\aPS}{i}$ as follows:
\[
  \testP{\aPS}{i} = (
  % \vec{\aReg} \GETS \vec{c}  \SEMI
  \IF{\vec{c}=\vec{1}} \THEN %\aReg = \aLoc \SEMI
  \IF{\aLoc = \aVal} \THEN \aLoc = \freshaval \SEMI \FENCE \SEMI b_i \GETS 1  \FI \FI)
\]
\end{itemize}
$\testP{\aPS}{i}$ is as expected, matching the reads (resp. writes) in $\aPS$ by writes (resp. reads).  The fresh value is used to flush out prior writes and reset to see fresh writes.    

\begin{definition}[Tester for $\aPS$ ]\label{testAPS} 
The tester context for $\aPS$, $\testP{\aPS}{}\hole{}$ is 
\[
b \GETS b_{1} \land  \cdots \land b_{n}
\PAR  \testP{\aPS}{1} 
\PAR   \cdots 
\PAR  \testP{\aPS}{n} 
\PAR \hole{}
\]
\end{definition}
The constraints of the normal form ensure that if the labels of any two events are the same, then one is a predecessor of the other. 

\begin{lemma}\label{tester}
$\sem{\testP{\aPS}{}\hole{\aCmd}}$  has a pomset that sets $b$ to $1$ iff $\aPS \in \freadsat\sem{\aCmd}$.
\begin{proof}
It suffices to prove that there is a pomset that sets $b$ to $1$ in
 $\freadsat\sem{b \GETS b_{1} \land  \cdots \land b_{n}
\PAR  \testP{\aPS}{1} 
\PAR   \cdots 
\PAR  \testP{\aPS}{n}} \parallel \bPS$ iff $\aPS$ is an augmentation of $\bPS$. 

We prove by induction on $\lt$ that $\testP{\aPS}{i}\hole{\aCmd}$  sets $b_i$ to $1$ iff the event $\aEv_i$ is enabled. Result follows.
\end{proof}
\end{lemma}

\begin{theorem}
  Let $\aCmd_1$ and $\aCmd_2$ be restriction-free, composition-free and
  synchronization free.  Then all top-level pomsets of
  $\freadsat\sem{\aCmd_1}$ are also pomsets of $\freadsat\sem{\aCmd_2}$ if
  and only if for all parallel contexts $\bCmd$, all top-level pomsets of
  $\freadsat\sem{\aCmd_1 \PAR \bCmd}$ are also pomsets of
  $\freadsat\sem{\aCmd_2 \PAR \bCmd}$
\begin{proof}
  The forward implication follows from the compositionality of the semantics.

  For the converse, pick a top level pomset in normal form in
  $\aPS \in \freadsat\sem{\aCmd_1} \setminus \freadsat\sem{\aCmd_2} $.  The
  required context is given by the tester context $\testP{\aPS}{}\hole{}$.
 \end{proof}
\end{theorem}

The full abstraction theorem applies only to full threads.  The reason for this limited statement is that our impoverished language does not permit  parallel composition to be used freely as the continuation in arbitrary sequential contexts.  A full abstraction theorem that applies also to commands can be achieved with these richer distinguishing contexts.  


\subsection{Relationship to Hoare logic}
In order to provide useful information about sequential commands in sequential contexts, we establish a relationship with Hoare triples for a sequential language.    

This invariant captured in the following theorem underlies the definitions in the semantics of sequential commands.
% \begin{theorem}
% Let $\aCmd$ be a command without either synchronization or parallelism.  Then:
%
% The following Hoare triple is valid:
% \begin{displaymath}
%   \hoare{\aForm\land\bLoc_1=\aVal_1\land\cdots\land\bLoc_n=\aVal_n}{\aCmd}{\aLoc=\bVal}  
% \end{displaymath}
% if and only if $\sem{\aCmd}$ contains an execution that includes
% \begin{tikzdisplay}[node distance=1em]
%   \event{r}{\smash{\vec{\bForm}}\mid\DR{\vec{\bLoc}}{\vec{\aVal}}}{}
%   \event{w1}{\vec{\cForm}\mid\DW{\aLoc}{\vec{\dVal}}}{right=4em of r}
%   \eventl{\aEv}{w2}{\aForm\mid\DW{\aLoc}{\bVal}}{below right=of r}
%   \wk{w1}{w2}
%   \po{r}{w2}
% \end{tikzdisplay}
% where $\DR{\vec{\bLoc}}{\vec{\aVal}}$ are all the events that precede $\aEv$ and
% $\DW{\aLoc}{\vec{\dVal}}$ are all the writes on $\aLoc$.
% \begin{proof}
% The proof proceeds by structural induction on the command. 
% \end{proof}
% \end{theorem}
\begin{theorem}
Let $\aCmd$ be a command without either synchronization or parallelism, such that
$\sem{\aCmd}$ contains an execution that includes
\begin{tikzdisplay}[node distance=1em]
  \event{r}{\smash{\vec{\bForm}}\mid\DR{\vec{\bLoc}}{\vec{\aVal}}}{}
  \event{w1}{\vec{\cForm}\mid\DW{\aLoc}{\vec{\dVal}}}{right=4em of r}
  \eventl{\aEv}{w2}{\aForm\mid\DW{\aLoc}{\bVal}}{below right=of r}
  \wk{w1}{w2}
  \po{r}{w2}
\end{tikzdisplay}
where $\DR{\vec{\bLoc}}{\vec{\aVal}}$ are all the events that precede $\aEv$ and
$\DW{\aLoc}{\vec{\dVal}}$ are all the writes on $\aLoc$.
Then the following Hoare triple is valid:
\begin{displaymath}
  \hoare{\aForm\land\bLoc_1=\aVal_1\land\cdots\land\bLoc_n=\aVal_n}{\aCmd}{\aLoc=\bVal}  
\end{displaymath}
\begin{proof}
The proof proceeds by structural induction on the command. 
\end{proof}
\end{theorem}


We illustrate with a few examples.
$\hoare{\TRUE}{x\GETS 1 \SEMI x \GETS 2}{x=2} $ holds.   In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{w1}{\DW{x}{1}}{}
 \event{w2}{\DW{x}{2}}{right=of w1}
\wk{w1}{w2}
\end{tikzdisplay}

$\hoare{\TRUE}{r \GETS x \SEMI \IF{r=1} \THEN y \GETS 1 \ELSE y \GETS 1 \FI}{y=1} $ holds.  
In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{w}{\DW{y}{1}}{}
 \event{r}{\DR{x}{v}}{right=of w}
\end{tikzdisplay}
In contrast, in a semantics that forbids load buffering, where the best that one can prove is
$\hoare{x=v} {r \GETS x \SEMI \IF{r=1} \THEN y \GETS 1 \ELSE y \GETS 1 \FI}{y= 1}
$.

Let $\aCmd = r \GETS x \SEMI \IF{r=1} \THEN y \GETS 1 \FI \SEMI s \GETS u \SEMI \IF{s=1} \THEN v \GETS 1 \FI$.  Then:
$ \hoare{x=1}{\aCmd}{y=1}$ and
$ \hoare{u=1}{\aCmd}{v=1}$
hold.  In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{rx}{\DR{x}{1}}{}
 \event{ru}{\DR{u}{1}}{right=of rx}
 \event{wy}{\DW{y}{1}}{below=of rx}
\event{wv}{\DW{u}{1}}{below=of ru}
 \rf{rx}{wy}
 \rf{ru}{wv}
\end{tikzdisplay}


Consider a fragment from example~\eqref{rfub}.
\begin{align*}
\bCmd:  r \GETS y \SEMI \IF{r \NOTEQ 42} \THEN a \GETS 1 \SEMI s \GETS 42 \FI \SEMI x \GETS 42
\end{align*}
Then, $\hoare{\TRUE}{\bCmd}{x=42} $ and $\hoare{y \neq 42}{\bCmd}{a= 1} $.  Thus, the traditional sequential semantics {\em does not} attribute any cause for the write of $42$ to $x$.  
In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{ry}{\DR{y}{41}}{}
 \event{wx}{\DW{x}{42}}{right=of ry}
 \event{wa}{\DW{a}{1}}{below=of rx}
 \rf{ry}{wa}
\end{tikzdisplay}


\endinput 



