\newcommand{\rel}{{\tt rel}}


\section{Single Threaded Optimizations}

As we have seen already, our model {\em invalidates} thread inlining.  We
argue that our model is fully flexible with respect to single threaded
optimizations in two ways; firstly, by considering concrete examples of
single threaded optimizations, and secondly, by proving a full abstraction
theorem for single threads without synchronization.  

%In this section, we only consider commands $\aCmd$ that do not have any occurrence of $\PAR$. 

% \begin{definition}
% $\aCmd \unrhd \bCmd$ if $\sem{\aCmd} \supseteq \sem{\bCmd}$
% \end{definition}
% Thus, in this case $\aCmd$ can be transformed into $\bCmd$ in any program context.  

By Lemma~\ref{lem:monotone}, if $\sem{\aCmd} \supseteq \sem{\bCmd}$
then $\aCmd$ can be transformed into $\bCmd$ in any program context.

We follow the terminology and presentation of section~7.1 of
~\citet{Dolan:2018:BDR:3192366.3192421}, to maintain a clear comparison with models that enforce extra ordering.

\paragraph*{Peephole optimizations. } 
Certain transformations involving adjacent operations on the same location
are permissible. 
 
\begin{lemma}
  Suppose $\cExp=\dExp$ is a tautology.  Then the following optimizations hold.
% \begin{eqnarray*}
% \mbox{Redundant load} &&\sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} \supseteq  \sem{\aReg \GETS \aLoc \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Store forwarding} &&\sem{\aLoc \GETS \aReg \SEMI \bReg \GETS \aLoc \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \aReg \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Dead Store} && \sem{\aLoc \GETS \aReg \SEMI \aLoc \GETS \bReg \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \bReg \SEMI \aCmd}
% \end{eqnarray*}
\begin{align*}
  \tag{Redundant load}
  \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} &\supseteq
  \sem{\aReg \GETS \REF{\cExp} \SEMI \aCmd[\aReg/\bReg]} \\
  \tag{Store forwarding} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &\supseteq 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \aCmd[\aExp/\bReg]} \\
  \tag{Dead Store} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq 
  \sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}
\end{align*}
\begin{proof}
  In each case, the proof proceeds by observing that the semantics allows us to use an implicit action on the lefthand side to mimic the right hand side.  

For dead store,
  $\sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd} = \REF{\dExp}=\aLoc) \guard \DW{\aLoc}{} \guard \sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}$.


For redundant load, 
\begin{eqnarray*}
&& \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} \\
&\supseteq&  \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  \sem{ \bReg  \GETS \REF{\dExp} \SEMI \aCmd[\aLoc/\aReg]} \\
&\supseteq&  \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  ( \REF{\dExp}=\aLoc \guard [ \sem{\aCmd}[\aLoc/\aReg,\aLoc/\bReg] \bigcup\  \bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg,\aLoc/\bReg]]\\
&=& \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  [ \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg] \bigcup\  \bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg]]\\
&=& \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \aReg \SEMI \aCmd} 
\end{eqnarray*}

Similarly, store forwarding is proved by considering the implicit read subset of $\sem{\bReg \GETS \REF{\dExp} \SEMI \aCmd}$.

\end{proof}
\end{lemma}
  
\paragraph*{Reorderings of independent statements}

$\aLoc$ and $\aCmd$ are independent if there are no writes to $\aLoc$ or reads from $\aLoc$ in $\aCmd$.  
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{Read-read}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &=
    \sem{\bReg \GETS \REF{\dExp} \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{Read-write}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Write-write}
    \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp} \GETS \aExp \SEMI \aCmd}
  \end{align*}

\begin{proof}
  The result follows immediately from the semantics of prefixing where the
  only enforced $\lt$ and $\gtN$ relationships come from conflict on $\aLoc$ or
  release actions in $\aCmd$.
\end{proof}
\end{lemma}

\paragraph*{Compiler optimizations.} Reordering and peephole optimizations can be combined to describe common  compiler optimizations.  We illustrate following~\citet{Dolan:2018:BDR:3192366.3192421}.

Common subexpression elimination. Consider the command 
\[ \aReg \GETS \aLoc *2  \SEMI \aCmd \SEMI \bReg \GETS \aLoc * 2 \]
where $\aCmd$ is independent of $\bReg$.  Then, reordering yields
\[\aCmd \SEMI \aReg \GETS \aLoc *2  \SEMI  \bReg \GETS \aLoc * 2 \]
followed by redundant load to yield:
\[\aCmd \SEMI \aReg \GETS \aLoc * 2 \SEMI  \bReg \GETS \aReg\]

Similarly, the treatment of loop-invariant code motion, dead-store elimination and constant propagation from~\citet{Dolan:2018:BDR:3192366.3192421} follows mutatis-mutandis, since our model is more generous about permitted reorderings.  Thus, we permit  redundant store elimination that they forbid.
Consider:
\[ \aReg \GETS \aLoc \SEMI \bLoc \GETS \cLoc  \SEMI \aLoc \GETS \aReg \]
Reordering, permitted by us, but forbidden by them, yields
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]
followed by the valid elimination of redundant load:
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]

\subsection{Full abstraction for synchronization free threads}
We provide some evidence that our semantics incorporates a complete suite of optimizations for single threaded and synchronization free programs.

\paragraph*{Generators}
We first examine the structure of the generators of single threaded and synchronization free code.  

$\TRUE\guard \sem{\aCmd}$ captures the behavior of $\aCmd$ as a top-level thread; since, it is not part of a bigger sequential composition, we can eliminate the events that are not guarded by tautologies.
\begin{lemma}
Let $\aCmd$ be $\PAR$-free.  Then, all generators $\aPS$ of $\TRUE\guard \sem{\aCmd}$ satisfy:
\begin{itemize}
\item If $\aEv$ is a write or a release, and $\aEv \lt\ \bEv$, then $\bEv$ is a release.
\item If $\bEv$ is a read or an acquire, and $\aEv \lt \bEv$, then $\aEv$ is an acquire.
\item $\aEv \gtN \bEv$ only if $ \aEv\ [\lt \cup (\le;\reco) \cup (\reco;\le)]) \  \bEv$.
\end{itemize}
\end{lemma}
The proof proceeds considering the minimal requirements on the order relations imposed by the semantics.  The key case is prefixing.  The only required $\lt$-edges out of writes are into release actions, and the only required $\lt$-edges into reads arise from read actions.  The only required $\gtN$-edges arise from conflicts on a location.

In the case where $\aCmd$ has no synchronization constructs, the structure of the generators simplifies further.
\begin{corollary}
Let $\aCmd$ be $\PAR$-free and synchronization free.  Then, all generators $\aPS$ of $\TRUE\guard \sem{\aCmd}$ satisfy:
\begin{itemize}
\item Writes are maximal and Reads are minimal in $\lt$.
\item $\aEv \gtN \bEv$ only if $ \aEv\ [\lt \cup (\le; \reco) \cup (\reco;\le)] \  \bEv$.
\end{itemize}
\end{corollary}

We define $\aPS \unrhd \bPS$ if $\bPS$ can be derived from $\aPS$ by removing writes and ``adjacent'' duplicate reads.
\begin{definition}
$\aPS \unrhd \bPS$ if 
\begin{itemize}
\item $\Event_{\bPS} \subseteq \Event_{\aPS}$ and $ \bPS$ is the restriction of $\aPS$ to $\Event_{\bPS}$.
\item if $\aEv \in \aPS \setminus \bPS$, then $\aEv$ is a write or there exists $\bEv$ in $\bPS$ with the same read label that agrees with $\aEv$ on all orders. ie.  forall $\cEv$ in $\aEv$:
$\cEv \lt \bEv \Leftrightarrow \cEv \lt \aEv,\bEv \lt \cEv \Leftrightarrow \aEv \lt \cEv, \cEv \xeco \bEv \Leftrightarrow \cEv \xeco \aEv, \bEv \xeco \cEv \Leftrightarrow \aEv \xeco \cEv$
\end{itemize}
\end{definition}
The generators of $\TRUE\guard \sem{\aCmd}$ are closed under $\unrhd$.  
\begin{lemma}\label{unrhd}
Let $\aCmd$ be $\PAR$-free and synchronization free.  Let $\aPS$ be a generator of $\sem{\aCmd}$.  Then, $\bPS$ is also a generator of $\sem{\aCmd}$, where $\aPS \unrhd \bPS$.
\end{lemma}
The proof uses the implicit actions in the semantics of write and read prefixing to remove the missing read and write actions.  

\paragraph{Testers for generators}


Let $\aPS$ be a generator of $\TRUE\guard \sem{\aCmd}$.  Let $\aEv_1, \ldots, \aEv_n$ be all the events in $\aPS$ that read or write $\aLoc$.  Let $\freshaval$ be a fresh value that does not occur in $\aPS$.  Let $\aReg_1, \ldots \aReg_n$ be distinct registers,, and $b_{\aLoc}, b_{\aPS}$ be a  set of fresh locations, not occurring in $\aPS$, one for each $\aLoc$.

\begin{definition}[Tester program]
For each $\aEv_i$, we define a command with a hole, called $\test{\aEv_i}$ as follows:
\[
\test{\aEv_i} = \left\{ 
                             \begin{array}{l}
                              \aLoc\GETS\aVal \SEMI \hole{\cdot}, \ \labeling(\aEv_i) = \DR{\aLoc}{\aVal} \\
                              \aLoc\GETS\freshaval\SEMI \aReg_i \GETS\aLoc \SEMI \IF{\aReg_i == \aVal} \THEN \hole{\cdot} \FI , \ \labeling(\aEv_i) = \DW{\aLoc}{\aVal} \\
                           \end{array}
                       \right.
\]    
The tester program for $\aPS$ for $\aLoc$, $\testP{\aPS}{\aLoc}$ is \[ \test{\aEv_1}[\test{\aEv_2}[\ldots [\test{\aEv_n}[b_{\aLoc} = \TRUE]]\ldots]] \]
The tester program for $\aPS$, $\testP{\aPS}{}$ is 
\[
\begin{array}{ll}
& b_{\aPS}\GETS b_{\aLoc} \star b_{\bLoc} \star  \ldots   \\
\PAR & \testP{\aPS}{\aLoc} \\
\PAR & \testP{\aPS}{\bLoc} \\
 \PAR  & \ldots 
\end{array}
\]
\end{definition}
 $\testP{\aPS}{\aLoc}$ is as expected, matching the reads (resp. writes) in $\aPS$ by writes (resp. reads).  The matching read for a write in $\aPS$ on $\aLoc$ has an extra write of a fresh value in order to flush prior potential writes of the same value.    

The tester program works as expected to detect $\aPS$ as a parallel context.  
The write of $1$ to the testing variable $b_{\aPS}$ is possible only by the paral
\begin{lemma}\label{testcorrect}
$\VAR\vec{\aLoc}\SEMI \VAR\vec{b} \SEMI \VAR b_{\aPS} \SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{b}\GETS\vec{0} \SEMI b_{\aPS}\GETS 0 [\sem{\testP{\aPS}{\aLoc}} \parallel \bPS]$
includes a pomset with an event writting 1 to $b_{\aPS}$ to 1 iff $\bPS$ augments a $\bPS'$ such that $\aPS \unrhd \bPS'$
\end{lemma}
As a corollary, using lemma~\ref{unrhd}, we deduce that parallel contexts suffice to distinguish  $\PAR$-free and synchronization free code.
\begin{theorem}
Let $\aCmd_1, \bCmd_2$ be $\PAR$-free and synchronization free.  Then $\TRUE\guard \sem{\aCmd_1}  \supseteq \TRUE\guard \sem{\aCmd_2}$ iff for all $\bCmd$,  $\sem{\aCmd_1\PAR \bCmd}  \supseteq \sem{\aCmd_2 \PAR \bCmd}$.
\end{theorem}
\begin{proof}
The forward implication follows from the compositionality of the semantics. For the converse, pick $\aPS \in \TRUE\guard \sem{\aCmd_1} \setminus \TRUE\guard \sem{\aCmd_2} $.  Definition~\ref{testAPS} defines a tester that works as required via lemma~\ref{testcorrect}.
\end{proof}

\endinput 



