\newcommand{\rel}{{\tt rel}}


\section{Single Threaded Optimizations}

As we have seen already, our model {\em invalidates} thread inlining.  We
argue that our model is fully flexible with respect to single threaded
optimizations in two ways; firstly, by considering concrete examples of
single threaded optimizations, and secondly, by proving a full abstraction
theorem for single threads without synchronization.  

%In this section, we only consider commands $\aCmd$ that do not have any occurrence of $\PAR$. 

% \begin{definition}
% $\aCmd \unrhd \bCmd$ if $\sem{\aCmd} \supseteq \sem{\bCmd}$
% \end{definition}
% Thus, in this case $\aCmd$ can be transformed into $\bCmd$ in any program context.  

By Lemma~\ref{lem:monotone}, if $\sem{\aCmd} \supseteq \sem{\bCmd}$
then $\aCmd$ can be transformed into $\bCmd$ in any program context.

We follow the terminology and presentation of section~7.1 of
~\citet{Dolan:2018:BDR:3192366.3192421}, to maintain a clear comparison with models that enforce extra ordering.

\paragraph*{Peephole optimizations. } 
Certain transformations involving adjacent operations on the same location
are permissible. 
 
\begin{lemma}
  Suppose $\cExp=\dExp$ is a tautology.  Then the following optimizations hold.
% \begin{eqnarray*}
% \mbox{Redundant load} &&\sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} \supseteq  \sem{\aReg \GETS \aLoc \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Store forwarding} &&\sem{\aLoc \GETS \aReg \SEMI \bReg \GETS \aLoc \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \aReg \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Dead Store} && \sem{\aLoc \GETS \aReg \SEMI \aLoc \GETS \bReg \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \bReg \SEMI \aCmd}
% \end{eqnarray*}
\begin{align*}
  \tag{Redundant load}
  \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} &\supseteq
  \sem{\aReg \GETS \REF{\cExp} \SEMI \aCmd[\aReg/\bReg]} \\
  \tag{Store forwarding} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &\supseteq 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \aCmd[\aExp/\bReg]} \\
  \tag{Dead Store} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq 
  \sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}
\end{align*}
\begin{proof}
  In each case, the proof proceeds by observing that the semantics allows us to use an implicit action on the lefthand side to mimic the right hand side.  

For dead store,
  $\sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd} = \REF{\dExp}=\aLoc) \guard \DW{\aLoc}{} \guard \sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}$.


For redundant load, 
\begin{eqnarray*}
&& \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} \\
&\supseteq&  \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  \sem{ \bReg  \GETS \REF{\dExp} \SEMI \aCmd[\aLoc/\aReg]} \\
&\supseteq&  \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  ( \REF{\dExp}=\aLoc \guard [ \sem{\aCmd}[\aLoc/\aReg,\aLoc/\bReg] \bigcup\  \bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg,\aLoc/\bReg]]\\
&=& \bigcup_\aLoc\; (\REF{\cExp}=\aLoc) \guard  [ \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg] \bigcup\  \bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg]]\\
&=& \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \aReg \SEMI \aCmd} 
\end{eqnarray*}

Similarly, store forwarding is proved by considering the implicit read subset of $\sem{\bReg \GETS \REF{\dExp} \SEMI \aCmd}$.

\end{proof}
\end{lemma}
  
\paragraph*{Reorderings of independent statements}

$\aLoc$ and $\aCmd$ are independent if there are no writes to $\aLoc$ or reads from $\aLoc$ in $\aCmd$.  
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{Read-read}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &=
    \sem{\bReg \GETS \REF{\dExp} \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{Read-write}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Write-write}
    \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp} \GETS \aExp \SEMI \aCmd}
  \end{align*}

\begin{proof}
  The result follows immediately from the semantics of prefixing where the
  only enforced $\lt$ and $\gtN$ relationships come from conflict on $\aLoc$ or
  release actions in $\aCmd$.
\end{proof}
\end{lemma}

\paragraph*{Compiler optimizations.} Reordering and peephole optimizations can be combined to describe common  compiler optimizations.  We illustrate following~\citet{Dolan:2018:BDR:3192366.3192421}.

Common subexpression elimination. Consider the command 
\[ \aReg \GETS \aLoc *2  \SEMI \aCmd \SEMI \bReg \GETS \aLoc * 2 \]
where $\aCmd$ is independent of $\bReg$.  Then, reordering yields
\[\aCmd \SEMI \aReg \GETS \aLoc *2  \SEMI  \bReg \GETS \aLoc * 2 \]
followed by redundant load to yield:
\[\aCmd \SEMI \aReg \GETS \aLoc * 2 \SEMI  \bReg \GETS \aReg\]

Similarly, the treatment of loop-invariant code motion, dead-store elimination and constant propagation from~\citet{Dolan:2018:BDR:3192366.3192421} follows mutatis-mutandis, since our model is more generous about permitted reorderings.  Thus, we permit  redundant store elimination that they forbid.
Consider:
\[ \aReg \GETS \aLoc \SEMI \bLoc \GETS \cLoc  \SEMI \aLoc \GETS \aReg \]
Reordering, permitted by us, but forbidden by them, yields
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]
followed by the valid elimination of redundant load:
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]

\endinput 



