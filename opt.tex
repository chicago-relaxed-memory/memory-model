\section{Single Threaded Optimizations}
\label{sec:opt}

As we have seen already, our model {\em invalidates} thread inlining.  We argue that our model is fully flexible with respect to single threaded optimizations; concretely by validating several 
single threaded optimizations including reordering of independent statements; and abstractly, by proving a full abstraction
theorem for single threads without synchronization and connecting to traditional Hoare logic for sequential programs. 

%In this section, we only consider commands $\aCmd$ that do not have any occurrence of $\PAR$. 

% \begin{definition}
% $\aCmd \unrhd \bCmd$ if $\sem{\aCmd} \supseteq \sem{\bCmd}$
% \end{definition}
% Thus, in this case $\aCmd$ can be transformed into $\bCmd$ in any program context.  

Let $\fsat(\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \{\aEv \in \Event\mid \labelingForm(\aEv)\;\text{is satisfiable}\}$,
${\le'} = {\le}\restrict{\Event'}$,
%${\gtN'} = {\gtN}\restrict{\Event'}$.
and
${\labeling'} = {\labeling}\restrict{\Event'}$.

By Lemma~\ref{lem:monotone}, if $\sem{\aCmd} \supseteq \sem{\bCmd}$
then $\aCmd$ can be transformed into $\bCmd$ in any program context.  Since
unsatisfiable events are ignored in our architecture model, it is
an immediate corollary that it is sufficient to show that
$\fsat\sem{\aCmd} \supseteq \fsat\sem{\bCmd}$.



\subsection{Validating single threaded optimizations}
We follow the terminology and presentation of section~7.1 of
\citet{Dolan:2018:BDR:3192366.3192421}, to maintain a clear comparison with
models that enforce extra ordering.

%\paragraph*{Peephole optimizations. } 
Certain transformations involving adjacent operations on the same location
are permissible. 
 
\begin{lemma}
  Suppose $\aExp=0$ is a tautology and $\cExp=\dExp$ is a tautology.   Then the following hold.
% \begin{eqnarray*}
% \mbox{Redundant load} &&\sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} \supseteq  \sem{\aReg \GETS \aLoc \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Store forwarding} &&\sem{\aLoc \GETS \aReg \SEMI \bReg \GETS \aLoc \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \aReg \SEMI \aCmd[\aReg/\bReg]} \\
% \mbox{Dead Store} && \sem{\aLoc \GETS \aReg \SEMI \aLoc \GETS \bReg \SEMI \aCmd} \supseteq \sem{\aLoc \GETS \bReg \SEMI \aCmd}
% \end{eqnarray*}
  \begin{align*}
  \tag{Dead Code} 
  \fsat\sem{\IF{\aExp}\THEN\aCmd\ELSE\bCmd\FI} &\supseteq 
  \fsat\sem{\bCmd} \\
  \tag{Dead Store} 
  \fsat\sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq 
  \fsat\sem{\REF{\dExp} \GETS \bExp \SEMI \aCmd}\\    
  \tag{Redundant load}
  \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}  \SEMI \aCmd} &\supseteq
  \sem{\aReg \GETS \REF{\cExp} \SEMI \aCmd[\aReg/\bReg]} \\
  \tag{Store forwarding} 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &\supseteq 
  \sem{\REF{\cExp} \GETS \aExp \SEMI \aCmd[\aExp/\bReg]}
\end{align*}
\begin{proof}
  For dead code elimination, the result is immediate from the semantics.
  
  For dead store, note that no event in $\aCmd$ can depend on the first store,
  therefore it may be taken with precondition $\FALSE$.
  
  For the others, the proof proceeds by observing that the semantics allows us
  to use an implicit action on the lefthand side to mimic the right hand side.
  For example, taking $\REF{\cExp}=\REF{\dExp}=\aLoc$, the argument for
  redundant load is as follows.
  \begin{align*}
    \sem{\aReg \GETS \aLoc \SEMI \bReg \GETS \aLoc  \SEMI \aCmd} 
    \supseteq&  \sem{ \bReg  \GETS \aLoc \SEMI \aCmd[\aLoc/\aReg]} \\
    \supseteq&  \sem{\aCmd}[\aLoc/\aReg][\aLoc/\bReg] \cup  \textstyle\bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg][\aLoc/\bReg]\\
    =& \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg] \cup  \textstyle\bigcup_\aVal\;  (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aReg/ \bReg][\aLoc/\aReg]\\
    =& \sem{\aReg \GETS \aLoc\SEMI \aCmd[\aReg/\bReg]}
    \tag*{\qedhere}
  \end{align*}
  % Similarly, store forwarding is proved by considering the implicit read subset of $\sem{\bReg \GETS \REF{\dExp} \SEMI \aCmd}$.
\end{proof}
\end{lemma}
  
%\paragraph*{Reorderings of independent statements}
Certain reorderings involving adjacent operations on the distinct locations
are also permissible. 

% $\aLoc$ and $\aCmd$ are independent if there are no writes to $\aLoc$ or reads from $\aLoc$ in $\aCmd$.  
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{Read-read}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp} \SEMI \aCmd} &=
    \sem{\bReg \GETS \REF{\dExp} \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{Read-write}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Write-write}
    \sem{\REF{\cExp} \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &=
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp} \GETS \aExp \SEMI \aCmd}
  \end{align*}
\begin{proof}
The proof of both of the above lemmas follows from the semantics of prefixing where the only enforced $\lt$ and $\gtN$ relationships come from conflict on $\aLoc$ or release actions in $\aCmd$.
\end{proof}
\end{lemma}

Roach-motel reorderings that increase the scope of synchronization are valid.
\begin{lemma}%[Reorderings]
  Suppose $\cExp\neq\dExp$ is a tautology.  Then the following reorderings hold.
  \begin{align*}
    \tag{Read-Acq}
    \sem{\aReg \GETS \REF{\cExp} \SEMI \bReg \GETS \REF{\dExp}\ACQ \SEMI \aCmd} &\supseteq
    \sem{\bReg \GETS \REF{\dExp}\ACQ\SEMI \aReg \GETS \REF{\cExp} \SEMI \aCmd}
&&\textif \aReg\notin\free(\dExp) \textand \bReg\notin\free(\cExp)
    \\
    \tag{Write-Acq} 
    \sem{\REF{\dExp} \GETS \bExp \SEMI\aReg \GETS \REF{\cExp}\ACQ \SEMI\aCmd} &\supseteq
    \sem{\aReg \GETS \REF{\cExp}\ACQ  \SEMI \REF{\dExp}\GETS \bExp \SEMI \aCmd} 
    &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
\tag{Rel-Read} 
\sem{\REF{\dExp}\REL \GETS \bExp \SEMI\aReg \GETS \REF{\cExp} \SEMI \aCmd} &\supseteq
    \sem{ \aReg \GETS \REF{\cExp} \SEMI \REF{\dExp}\REL \GETS \bExp \SEMI \aCmd}
   &&\textif \aReg\notin\free(\dExp) \cup\free(\bExp)
    \\
    \tag{Rel-Write}
    \sem{\REF{\cExp}\REL \GETS \aExp \SEMI \REF{\dExp} \GETS \bExp \SEMI \aCmd} &\supseteq
    \sem{\REF{\dExp} \GETS \bExp \SEMI \REF{\cExp}\REL \GETS \aExp \SEMI \aCmd}
  \end{align*}
\begin{proof}
The proof follows from noticing that the pomsets in the semantics of the right hand sides are augmentations of a pomset on the left hand side.  
\end{proof}
\end{lemma}

\paragraph*{Compiler optimizations.} Reordering and peephole optimizations can be combined to describe common  compiler optimizations.  We illustrate following~\citet{Dolan:2018:BDR:3192366.3192421}.

Common subexpression elimination. Consider the command 
\[ \aReg \GETS \aLoc *2  \SEMI \aCmd \SEMI \bReg \GETS \aLoc * 2 \]
where $\aCmd$ is independent of $\bReg$.  Then, reordering yields
\[\aCmd \SEMI \aReg \GETS \aLoc *2  \SEMI  \bReg \GETS \aLoc * 2 \]
followed by redundant load to yield:
\[\aCmd \SEMI \aReg \GETS \aLoc * 2 \SEMI  \bReg \GETS \aReg\]

Similarly, the treatment of loop-invariant code motion, dead-store elimination and constant propagation from~\citet{Dolan:2018:BDR:3192366.3192421} follows mutatis-mutandis, since our model is more generous about permitted reorderings.  Thus, we permit  redundant store elimination that they forbid.
Consider:
\[ \aReg \GETS \aLoc \SEMI \bLoc \GETS \cLoc  \SEMI \aLoc \GETS \aReg \]
Reordering, permitted by us, but forbidden by them, yields
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]
followed by the valid elimination of redundant load:
\[ \aReg \GETS \aLoc \SEMI \aLoc \GETS \aReg \SEMI \bLoc \GETS \cLoc  \]

\subsection{Full abstraction for synchronization free threads}
Our semantics is complete for reasoning about full-thread optimizations of synchronization free programs.

In the rest of this section, we only consider commands $\aCmd,\bCmd$ that are synchronization free (ie. no acquire, release, fence) and single threaded (ie. no parallel composition). 

In order to develop the proof, we describe a normal form for pomsets that arise in single threaded and synchronization free code.  
\begin{definition}
$\aPS$ is in normal form if:
\begin{itemize}
\item All preconditions on events are tautologies.
\item Writes are maximal and Reads are minimal in $\lt$.
\item $\aEv \gtN \bEv$ only if $ \aEv\ (\lt \cup \reco)^{\star} \  \bEv$.
\item If $\aEv, \aEv'$ have the same read action label, then $\aEv = \aEv'$
\item  If $\aEv, \aEv'$ have the same write action label, then there exists a write $\bEv$ on the same location as $\aEv$ such that $\aEv \gtN \bEv \gtN \aEv'$.
\end{itemize}
\end{definition}
It suffices to consider normal forms when distinguishing single threaded, synchronization free code at the top level. $\TRUE\guard \sem{\aCmd}$ is used to captures the behavior of $\aCmd$ as a top-level thread by restricting only to events whose preconditions are tautologies.
\begin{lemma}\label{unrhd}
Let $\aCmd,\bCmd$ be 
$\TRUE\guard \sem{\aCmd} \subseteq \TRUE\guard \sem{\bCmd} $  iff for all $\aPS$ in normal form, $\aPS in \TRUE\guard \sem{\aCmd} \Leftrightarrow\ \aPS in \TRUE\guard \sem{\bCmd}$
\begin{proof}
The normal forms determine the full semantics by the closure properties of the semantics.     The proof proceeds by induction on structure.  The key case is prefixing. 

Prefixing does not require $\lt$-edges out of writes  and into read actions.  Read prefixing permits the reuse of events to ensure that distinct read events have distinct read labels.  Similarly, write prefixing can be used to ensure that  writes that are adjacent in $\gtN$ order have distinct labels.
\end{proof}
\end{lemma}



Let $\aPS$ be a normal form of $\TRUE\guard \sem{\aCmd}$.  Let $\aEv_1, \ldots, \aEv_n$ be all the events in $\aPS$ that read or write $\aLoc$.  Let $\freshaval$ be a fresh value that does not occur in $\aPS$.  Let $\aReg_1, \ldots \aReg_n$ be distinct registers,, and $b_{\aLoc}, b_{\aPS}$ be a  set of fresh locations, not occurring in $\aPS$, one for each $\aLoc$.


We define a tester program to use as a parallel context to detect $\aPS$. 
\begin{definition}[Tester program]\label{testAPS}
For each $\aEv_i$, we define a command with a hole, called $\test{\aEv_i}$ as follows:
\[
\test{\aEv_i} = \left\{ 
                             \begin{array}{l}
                              \aLoc\GETS\aVal \SEMI \hole{\cdot}, \ \labeling(\aEv_i) = \DR{\aLoc}{\aVal} \\
                              \aLoc\GETS\freshaval\SEMI \aReg_i \GETS\aLoc \SEMI \IF{\aReg_i = \aVal} \THEN \hole{\cdot} \FI , \ \labeling(\aEv_i) = \DW{\aLoc}{\aVal} \\
                           \end{array}
                       \right.
\]    
The tester program for $\aPS$ for $\aLoc$, $\testP{\aPS}{\aLoc}$ is \[ \test{\aEv_1}[\test{\aEv_2}[\ldots [\test{\aEv_n}[b_{\aLoc} = \TRUE]]\ldots]] \]
The tester program for $\aPS$, $\testP{\aPS}{}$ is 
\[
\begin{array}{ll}
& b_{\aPS}\GETS b_{\aLoc} \star b_{\bLoc} \star  \ldots   \\
\PAR & \testP{\aPS}{\aLoc} \\
\PAR & \testP{\aPS}{\bLoc} \\
 \PAR  & \ldots 
\end{array}
\]
\end{definition}
 $\testP{\aPS}{\aLoc}$ is as expected, matching the reads (resp. writes) in $\aPS$ by writes (resp. reads).  The matching read for a write in $\aPS$ on $\aLoc$ has an extra write of a fresh value in order to flush prior potential writes of the same value.    

 

\begin{theorem}
Let $\aCmd_1, \bCmd_2$ be $\PAR$-free and synchronization free.  Then $\TRUE\guard \sem{\aCmd_1}  \supseteq \TRUE\guard \sem{\aCmd_2}$ iff for all $\bCmd$,  $\sem{\TRUE\guard(\aCmd_1\PAR \bCmd)}  \supseteq \sem{\TRUE \guard (\aCmd_2 \PAR \bCmd)}$.

\begin{proof}
The forward implication follows from the compositionality of the semantics. For the converse, pick $\aPS \in \TRUE\guard \sem{\aCmd_1} \setminus \TRUE\guard \sem{\aCmd_2} $. 

Consider the (semantic) context induced by tester program $\testP{\aPS}{}$:
\[ \sem{\VAR\vec{\aLoc}\SEMI \VAR\vec{b} \SEMI \VAR b_{\aPS} \SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\vec{b}}\GETS\vec{0} 
    \SEMI b_{\aPS}\GETS 0 \SEMI  [\sem{\testP{\aPS}{} \parallel [\TRUE \guard [\cdot]]}]}
\]
There is a pomset that writes one to the  testing variable $b_{\aPS}$ if and only if the context hole is filled with a set that contains $\aPS$.  
\end{proof}
\end{theorem}

The full abstraction theorem applies only to full threads; in particular.  The reason for this limited statement of full abstraction is that our language is impoverished, in that parallel composition cannot be used freely as the continuation in a sequential composition.  A full abstraction theorem that applies also to commands requires these richer distinguishing contexts.  


\subsection{Relationship to Hoare logic}
In order to provide useful information about sequential commands in sequential contexts, we establish a relationship with Hoare triples for a sequential language.  

\begin{theorem}
Let $\aCmd$ be a command without either synchronization or parallelism.

The following Hoare triple is valid:
\begin{displaymath}
  \hoare{\aForm\land\bLoc_1=\aVal_1\land\cdots\land\bLoc_n=\aVal_n}{\aCmd}{\aLoc=\bVal}  
\end{displaymath}
if and only if $\sem{\aCmd}$ contains an execution that includes
\begin{tikzdisplay}[node distance=1em]
  \event{r}{\smash{\vec{\bForm}}\mid\DR{\vec{\bLoc}}{\vec{\aVal}}}{}
  \event{w1}{\vec{\cForm}\mid\DW{\aLoc}{\vec{\dVal}}}{right=4em of r}
  \eventl{\aEv}{w2}{\aForm\mid\DW{\aLoc}{\bVal}}{below right=of r}
  \wk{w1}{w2}
  \po{r}{w2}
\end{tikzdisplay}
where $\DR{\vec{\bLoc}}{\vec{\aVal}}$ are all the events that precede $\aEv$ and
$\DW{\aLoc}{\vec{\dVal}}$ are all the writes on $\aLoc$.
\begin{proof}
The proof proceeds by structural induction on the command.  Indeed, this invariant underlies the definitions in the semantics.
\end{proof}
\end{theorem}

This theorem captures the independence between reads and writes in a sequential program fragment.  We illustrate with a couple of examples.

\begin{example}
Consider:
\begin{align*}
\aCmd:   x\GETS 1 \SEMI x \GETS 2
\end{align*}
Then: $\hoare{\TRUE}{\aCmd}{2=1} $.  In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{w1}{\DW{x}{1}}{}
 \event{w2}{\DW{x}{2}}{right=of w1}
\wk{w1}{w2}
\end{tikzdisplay}
\end{example}

\begin{example}
Consider:
\begin{align*}
\aCmd =  (r \GETS x \SEMI \IF{r=1} \THEN y \GETS 1 \ELSE y \GETS 1 \FI)
\end{align*}
Then: $\hoare{\TRUE}{\aCmd}{y=1} $.  In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{w}{\DW{y}{1}}{}
 \event{r}{\DR{x}{v}}{right=of w}
\end{tikzdisplay}
In particular, this Hoare triple is not captured by a semantics that forbids load buffering, where the best that one can prove is
$\hoare{x=v} {\aCmd}{y= 1} $.
\end{example}
 
\begin{example}
Consider:
\begin{align*}
\aCmd =   (r \GETS x \SEMI \IF{r=1} \THEN y \GETS 1 \FI \SEMI r \GETS u \SEMI \IF{s=1} \THEN v \GETS 1 \FI)
\end{align*}
Then: $\hoare{x=1}{\aCmd}{y=1} $ and $\hoare{u=1}{\aCmd}{v=1} $.  In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{rx}{\DR{x}{1}}{}
 \event{ru}{\DR{u}{1}}{right=of rx}
 \event{wy}{\DW{y}{1}}{below=of rx}
\event{wv}{\DW{u}{1}}{below=of ru}
 \rf{rx}{wy}
 \rf{ru}{wv}
\end{tikzdisplay}
\end{example}

\begin{example}
Consider a fragment from example~\eqref{rfub}.
\begin{align*}
\aCmd = (r \GETS y \SEMI \IF{r \NOTEQ 42} \THEN a \GETS 1 \SEMI s \GETS 42 \FI \SEMI x \GETS 42
\end{align*}
Then, $\hoare{\TRUE}{\aCmd}{x=42} $ and $\hoare{y \neq 42}{\aCmd}{a= 1} $.  Thus, the traditional sequential semantics {\em does not} attribute any cause for the write of $42$ to $x$.  
In the semantics, this is mirrored by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{ry}{\DR{y}{42}}{}
 \event{wx}{\DW{x}{42}}{right=of ry}
 \event{wa}{\DW{a}{1}}{below=of rx}
 \rf{ry}{wa}
\end{tikzdisplay}
\end{example}


\endinput 



