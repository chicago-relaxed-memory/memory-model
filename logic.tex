\section{Invariant Reasoning in Temporal Logic}
\label{sec:logic}

A significant challenge for a software memory model is to relax order enough
to allow efficient implementation without admitting anomalous
behaviors---called \emph{out of thin air} (\oota) in the literature
\cite{vacuous,DBLP:conf/esop/BattyMNPS15,BoehmOOTA}.  The most famous example is:
\begin{align}
  \label{oota1}
  (y\GETS x \PAR r\GETS y\SEMI x\GETS r)
  &&
  %\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=2em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \po{ry}{wx}
  \rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
    \end{tikzinline}}
\end{align}
Although Java does not allow \eqref{oota1},
\citet{DBLP:journals/toplas/Lochbihler13} showed that it does allow \oota\
behaviors of \eqref{lochbihler}.  In this case, the violation is a subtler
temporal property.  We develop a logic sufficient to prove that our semantics
disallows \oota\ on \eqref{lochbihler}.   The logic is not meant to be
definitive; at the end of this section, we give examples that require non-trivial extensions.

We adapt past linear temporal logic (\pLTL)
\cite{Lichtenstein:1985:GP:648065.747612} to pomsets by dropping the previous
instant operator and adopting strict versions of the temporal operators.
We ignore synchronization; the atoms of our logic are write and read events.
% \begin{displaymath}
%   \afo \QUAD::=\QUAD
%   \DR{\aLoc}{\aVal}
%   \mid
%   \DW\aLoc\aVal
%   \afo \wedge\bfo
%   \mid \lnot \afo
%   \once\afo
%   \mid \always\afo
% \end{displaymath}
%\begin{definition} %[Satisfaction]
Given a pomset $\aPS$ and event $\aEv$, define\footnote{Let $\FALSE$, $\lor$,
  $\Rightarrow$ and $\once$ as usual;
  for example,
  $\once\afo = \lnot(\always\lnot\afo)$.}:
  \begin{displaymath}
    \begin{array}{lrl}
      \aPS,\aEv &\models& \DW{\aLoc}{\aVal}, \text{ if } \labeling(\aEv) =  (\TRUE\mid \DW{\aLoc}{\aVal}) \\
      \aPS,\aEv &\models& \DR{\aLoc}{\aVal}, \text{ if } \labeling(\aEv) =  (\TRUE\mid \DR{\aLoc}{\aVal}) \\
      \aPS,\aEv &\models& \afo\land\bfo, \text{ if } \aPS,\aEv \models  \afo \text{ and } \aPS,\aEv \models  \bfo \\
      \aPS,\aEv &\models& \TRUE\\
      \aPS,\aEv &\models& \lnot\afo, \text{ if } \aPS,\aEv \not\models \afo \\
      \aPS,\aEv &\models& \once\afo,\mkern1.5mu \text{if } (\exists \bEv \lt \aEv)\;  \aPS,\bEv \models \afo \\
      \aPS,\aEv &\models& \always\afo, \text{ if } (\forall \bEv \lt \aEv)\; \aPS,\bEv \models \afo
    \end{array} 
  \end{displaymath}

  % \begin{definition}
  Let $\aPS \models \afo$ if
  $\aPS,\aEv \models\afo$, for all $\aEv \in \Event$.

  Let $\aPSS\models \afo$
  if $\aPS \models\afo$, for all $\aPS \in \aPSS$.
  
Let
  \begin{math}
    \afo, \aPSS \models \bfo  \text{ if } \{ \aPSS \mid \aPSS \models \afo \} \parallel \aPSS \models \bfo.
  \end{math}
%\end{definition}

  Let $\afo$ be \emph{prefix closed} when
  $\{ \aPSS \mid \aPSS \models \afo \}$ is.

% Thus, $\aPS\models \afo \land \always\afo$ whenever $\aPS \models
  % \afo$. This fact relies on the use of universal quantification in the definition.

% We define other connectives as standard:
% $\once\afo = \lnot(\always\lnot\afo)$,
% %$\FALSE = \lnot(\TRUE)$
% $\afo\lor\bfo = \lnot(\lnot(\afo)\land\lnot(\bfo))$, and
% $\afo\Rightarrow\bfo = \lnot(\afo) \lor\ \bfo$.
% \begin{displaymath}
% \begin{array}{lrl}
% \once\afo &=& \lnot(\always\lnot\afo) \\
% \FALSE &=& \lnot(\TRUE) \\
% \afo\lor\bfo &=& \lnot(\lnot(\afo)\land\lnot(\bfo)) \\
% \afo\Rightarrow\bfo &=& \lnot(\afo) \lor\ \bfo
% \end{array}
% \end{displaymath}
%Let $$ be defined as $$. 
%In addition, let $\FALSE$, $\lor$ and $$ be defined in the
%standard way.
% $\afo\lor\bfo$ for $\lnot(\lnot \afo \land \lnot \bfo)$,
% and $\afo \Rightarrow \bfo$ for $\lnot \afo \lor \bfo$.
The past operators do not include the current
instant, and thus they do \emph{not} satisfy the rule
\begin{math}
  \always\afo\Rightarrow\once\afo.
\end{math}
The \emph{roots}---the minimal elements of a pomset---always validate $\always\afo$ and always invalidate $\once\afo$.  
However, they do satisfy:
% \begin{align*}  
%   \frac{\aPS \models \afo \Rightarrow\once{\afo}}{\aPS \models \lnot \afo}\text{(Coinduction)}
%   &&
%   \frac{\aPS \models \always\afo \Rightarrow\afo}{\aPS \models \afo}\text{(Induction)}
% \end{align*}
% \begin{lemma}
% Given an pomset $\aPS$.  
\begin{align*}
  \tag{Induction}
  \aPS \models& (\always\afo \Rightarrow\afo) \Rightarrow\afo
  \\[-1ex]
  \tag{Coinduction}
  \aPS \models& (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
  \\[-1ex]
  \tag{Weakening}
  \aPS \models& (\afo \Rightarrow\once{\bfo}) \Rightarrow (\once\afo \Rightarrow\once{\bfo})
\end{align*}
% \end{lemma}
% \begin{proof}
% We prove that any node in a pomset satisfies these formulas.  
%The proof for both rules proceeds by induction on the length of the maximal path from a root to a node. 
%\end{proof}

% \begin{description}
% \item[Coinduction.]
%   \begin{math}
%     (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
%   \end{math}
% \item[Induction.] 
%   \begin{math}
%     (\always\afo \Rightarrow\afo) \Rightarrow\afo
%   \end{math}
% \end{description}


%We now present two proof rules for programs. 

%\paragraph*{Proof rules for programs}
We present two proof rules for programs. 

The first rule concerns
location declarations:  % Define
%The soundness proof is straightforward.
% \begin{math}
%   \closed(\aLoc) = (\DR{\aLoc}{\aVal} \Rightarrow \once \DW{\aLoc}{\aVal}).
% \end{math}
% Although this definition does not mention intervening writes, it is
% sufficient for our example.  
\begin{displaymath}
  %\tag{Closing $\aLoc$}
  \frac{
    \afo \text{ is independent of } \aLoc
    \qquad
    %\aPS \models \closed(\aLoc) \Rightarrow \afo
    \aPS \models (\DR{\aLoc}{\aVal} \Rightarrow \once \DW{\aLoc}{\aVal}) \Rightarrow \afo
  }{
    \nu \aLoc \DOT \aPS \models \afo
  }
\end{displaymath}
It is straightforward to establish that this rule is sound.
% Although it does
% not mention intervening writes, the rule is sufficient for our examples.

The second rule describes composition, in the style of~\citet{Abadi:1993:CS:151646.151649}.  To simplify the presentation, we
consider the special case with a single invariant.
% We view the
% composition result as capturing key aspects of no-ThinAirRead, as will become
% clearer in the examples below.
In order to state the theorem, we generalize the satisfaction relation to
include environment assumptions.

\begin{proposition}%[Composition]
  Let $\afo$ be prefix-closed.  Let $\aPSS_1, \aPSS_2$ be
  augmentation\hyp{}closed.%\footnote{$\aPS'$ is an augmentation of $\aPS$ if
 %   $\Event'=\Event$, $\aEv\le\bEv$ implies $\aEv\le'\bEv$, $\aEv\gtN\bEv$
 %   implies $\aEv\gtN'\bEv$, and
 %   % $\labeling'(\aEv)=\labeling(\aEv)$
 %   if $\labeling(\aEv) = (\bForm \mid \bAct)$ then
 %   $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies
 %   $\bForm$.}
  Then:
  \begin{displaymath}
    %\tag{Composition}
    \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
  \end{displaymath}
\end{proposition}
\begin{proof}[Proof sketch]
  We will show that all prefixes in the prefix closures of
  $\aPSS_1 \parallel \aPSS_2$ satisfy the required property.  Proof proceeds
  by induction on prefixes of $\aPS \in \aPSS_1 \parallel \aPSS_2$.
  %
  The case for empty prefix  follows from assumption that  $\afo$ is prefix closed.  
  %
  For the inductive case, consider %$\aPS$ in the prefix closure of $\aPSS_1 \parallel \aPSS_2$, i.e.
  $\aPS \in \aPS_1 \parallel \aPS_2$ where
  $\aPS_i \in \aPSS_i$.  Since $\aPSS_1$ and $\aPSS_2$ are augmentation
  closed, we can assume that the restriction of $\aPS$ to the events of
  $\aPS_i$ coincides with $\aPS_i$, for $i=1,2$.
  %
  Consider a prefix $\aPS'$ derived by removing a maximal element $\aEv$ from
  $\aPS$.  Suppose $\aEv$ comes from $\aPS_1$ (the other case is
  symmetric). Since $\aPS_2$ is a prefix of $\aPS'$ and $\aPS' \models \afo$
  by induction hypothesis, we deduce that $\aPS_2 \models \afo$.
  % Thus, $\aPS_2 \in \mods{(\afo)}$.
  Since $\aPS_1 \in \aPSS_1$, by assumption $\afo, \aPSS_1 \models\afo$ we
  deduce that $\aPS \models \afo$.
\end{proof}
When all variables are initially bound to $0$, we show that \eqref{oota1}
satisfies
\begin{math}
  \lnot\DW{x}{1}.
\end{math}
 We start with the invariant:
\begin{displaymath}
  [\DW{x}{1}\Rightarrow\once\DR{y}{1}]
  \land
  [\DW{y}{1}\Rightarrow\once\DR{x}{1}]
\end{displaymath}
This invariant holds for each thread; thus, it holds for the
aggregate program by composition.  Closing $y$ yields
\begin{math}
  \DR{y}{1} \Rightarrow \once\DW{y}{1}.
\end{math}
Weakening the right conjunct: % yields
\begin{math}
  \once\DW{y}{1}\Rightarrow\once\DR{x}{1}.
\end{math}
Chaining these together: %yields
\begin{math}
  \DR{y}{1} \Rightarrow \once\DR{x}{1}.
\end{math}
Weakening:  %yields
\begin{math}
  \once\DR{y}{1} \allowbreak\Rightarrow \once\DR{x}{1}. 
\end{math}
Chaining into the left conjunct:  %yields
\begin{math}
  \DW{x}{1} \Rightarrow \once\DR{x}{1}. 
\end{math}
Closing $x$, 
% \begin{math}
%   \DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
weakening, 
% \begin{math}
%   \once\DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
then chaining: %, yields
\begin{math}
  \DW{x}{1} \Rightarrow \once\DW{x}{1}. 
\end{math}
By coinduction, 
\begin{math}
  \lnot\DW{x}{1},
\end{math}
as required.

We consider a variant of
\citeauthor{DBLP:journals/toplas/Lochbihler13}'s example \eqref{lochbihler}:
% A more general principle, in the spirit of~\citet{Abadi:1993:CS:151646.151649} can be proved.  We chose the simple case of temporal invariants to illustrate the idea in a simple form.  Even this simple version has interesting consequences. 
\begin{align*}
  \label{alan}
  %   Z=1;
  % ||
  %   a=X; // 1
  %   Y=a;
  % ||
  %   b=Z; // 0
  %   if(b){
  %     X=1
  %   } else {
  %     c=Y; // 1
  %     X=c;
  %     W=c;
  %   }
  %\VAR  x\GETS0\SEMI \VAR  y\GETS0\SEMI \VAR  z\GETS0\SEMI
  z\GETS1
  \PAR
    y\GETS x
  \PAR
    \IF{z}\THEN x\GETS1 \ELSE r\GETS y \SEMI x\GETS r \SEMI a\GETS r \FI
\end{align*}
This variant retains the essential temporal aspects of \eqref{lochbihler}.
In this case, all threads satisfy the invariant ``a write to $a$ is preceded
by a read of $z$ as $1$.''

Attempting to write $1$ to $a$ results in a cycle:
\begin{tikzdisplay}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{left=2em of rx}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{rz}{\DR{z}{0}}{right=2em of wy}
  \event{ry}{\DR{y}{1}}{right=of rz}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \po{ry}{wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=10,in=170]{rz}{wa}
  \po[out=-15,in=-165]{ry}{wa}
\end{tikzdisplay}
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy0}{\DW{y}{0}}{}
%   \event{rx}{\DR{x}{1}}{right=4.5em of wy0}
%   \event{wy}{\DW{y}{1}}{right=of rx}
%   \po{rx}{wy}
%   \wk[bend left]{wy0}{wy}
%   \event{wx0}{\DW{x}{0}}{below=of wy0}
%   \event{rz}{\DR{z}{0}}{right=of wx0}
%   \event{ry}{\DR{y}{1}}{right=of rz}
%   \event{wx}{\DW{x}{1}}{right=of ry}
%   \event{ry1}{\DR{y}{1}}{right=of wx}
%   \event{wa}{\DW{a}{1}}{right=of ry1}
%   \rf{wy}{ry1}
%   \po{ry}{wx}
%   \wk[bend right]{wx0}{wx}
%   \rf{wy}{ry}
%   \rf{wx}{rx}
%   \event{wz0}{\DW{z}{0}}{below=of wx0}
%   \event{wz1}{\DW{z}{1}}{right=of wz0}
%   \rf{wz0}{rz}
%   \wk{wz0}{wz1}
%   \po{ry1}{wa}
%   \po[bend right]{rz}{wa}
% \end{tikzdisplay}

We prove the formula
\begin{math}
  \lnot\DW{a}{1},
\end{math}
starting with invariant:
% which holds for each of the three threads, and thus, by composition, for the
% aggregate program:
\begin{scope}
\small
\begin{align*}
  [\once\DW{y}{1} \Rightarrow \once\DR{x}{1}]
  \land
  [\notonce\DW{a}{1} \Rightarrow (\once\DR{y}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{y}{1}))]
\end{align*}
\end{scope}
Closing $y$ and chaining into the left conjunct:
% \begin{math}
%   \once\DR{y}{1} \Rightarrow \once\DW{y}{1}. % \Rightarrow \once\DR{x}{1}
% \end{math}
% Chaining this implication on the left:
\begin{math}
  \once\DR{y}{1} \Rightarrow \once\DR{x}{1}.
\end{math}
% We can weaken this to:
% \begin{math}
%   \once\DR{y}{1} \Rightarrow \once\DR{x}{1}. % \Rightarrow \once\DR{x}{1}
% \end{math}
Chaining into the right conjunct:
\begin{displaymath}
  \notonce\DW{a}{1} \Rightarrow (\once\DR{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{x}{1}))
\end{displaymath}
Closing $x$:
% \begin{math}
%   \once\DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
%  Weakening and chaining again:
%we can replace $\once\DR{x}{1}$ with $\once\DW{x}{1}$:
\begin{math}
  \notonce\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DW{x}{1}).
\end{math}
Applying coinduction to the right conjunct:
\begin{displaymath}
  \notonce\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\lnot \DW{x}{1}))
\end{displaymath}
Simplifying:
\begin{math}
  \notonce\DW{a}{1} \Rightarrow \FALSE,
\end{math}
as required.

Many examples are superficially similar, but can write $a$ without cycles.
In the following, $\DW{x}{1}$ is independent of $\DR{y}{1}$.
\begin{gather*}
    y\GETS x
  \PAR
    \IF{y}\THEN r\GETS y\SEMI x\GETS r\SEMI a\GETS r \ELSE x\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=2em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=-15,in=-165]{ry}{wa}
    \end{tikzinline}}
\end{gather*}



Some \oota\ examples can be proven if we extend the logic with value
quantification---we leave the details to future work.  Consider
\cite[(\textsc{rng})]{DBLP:conf/esop/SvendsenPDLV18}:
\begin{gather*}
  % \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI %\\[-.5ex]
  \begin{aligned}
    ( y\GETS x+1
    \PAR
    x\GETS y ) && \hbox{\begin{tikzinline}[node distance=1em]
        \event{rx}{\DR{x}{1}}{}
        \event{wy}{\DW{y}{2}}{right=of rx}
        \po{rx}{wy}
        \event{ry}{\DR{y}{1}}{right=3em of wy}
        \event{wx}{\DW{x}{1}}{right=of ry}
        \po{ry}{wx}
        % \rf{wy}{ry}
        \rf[out=170,in=10]{wx}{rx}
      \end{tikzinline}}
  \end{aligned}
  \\
  \hbox{$
    \begin{gathered}
      [\forall u,v.\;(\once\DW{y}{u} \land \once\DW{y}{v}) \Rightarrow ((u \EQ v) \vee (u \EQ 0) \vee (v \EQ 0))]
      \\[-.5ex]
      \land [\DW{x}{1} \Rightarrow \once\DR{y}{1}]
      \land [\DW{y}{2} \Rightarrow \once\DR{x}{1}]
      % \land [\DW{z}{2} \Rightarrow \once\DR{y}{2}]
    \end{gathered}$}
\end{gather*}
% \begin{displaymath}
%   \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI  %\\[-.5ex]
%   (
%     y\GETS x+1\SEMI z \GETS y
%   \PAR
%     x\GETS y
%     %   )
% \end{displaymath}
% \begin{scope}
%   \small
%   \begin{gather*}
%     [(\once\DW{y}{v_1} \land \once\DW{y}{v_2}) \Rightarrow ((v_1 = v_2) \vee (v_1 = 0) \vee (v_2 = 0))] \land\\[-.5ex]
%     [\once\DW{x}{1} \Rightarrow \once\DR{y}{1}] \land [\once\DW{y}{2}
%     \Rightarrow \once\DR{x}{1}] \land [\once\DW{z}{2} \Rightarrow
%     \once\DR{y}{2}]
%   \end{gather*}
% \end{scope}
The attempted execution is disallowed since there is no write to fulfill
$\DR{y}{1}$.  Closing $x$ and $y$ and using the last two conjuncts in the
invariant above:
% last conjunct, we have
% \begin{math}
%   % \once\DW{z}{2} \Rightarrow \once\DR{y}{2}
%   % \once\DW{z}{2} \Rightarrow \once\DW{y}{2}
%   \DW{y}{2} \Rightarrow \once\DR{x}{1}.
% \end{math}
% Closing $x$, we then have
\begin{math}
  % \once\DW{z}{2} \Rightarrow \once\DW{x}{1}
  \DW{y}{2} \Rightarrow \once\DW{y}{1}.
\end{math}
From the first conjunct, we then derive
\begin{math}
  \DW{y}{2} \Rightarrow \FALSE,
\end{math}
as required.

Other \oota\ examples may require that we extend the logic to deal with
intervening writes or coherence. The following outcome is allowed by the
promising semantics \cite{DBLP:conf/popl/KangHLVD17}, but not in \weakestmo{}
\cite[Fig.~3]{DBLP:journals/pacmpl/ChakrabortyV19} nor in our semantics, due
to the cycle:
\begin{gather*}
  \label{weakestmo}
  x\GETS 2\SEMI
  \IF{x\NOTEQ2}\THEN y\GETS 1 \FI
  \PAR
  x\GETS 1\SEMI
  r\GETS x\SEMI
  \IF{y}\THEN x\GETS 3 \FI
  \\\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{\DW{x}{2}}{}
  \event{rx3}{\DR{x}{3}}{right=of wx2}
  \event{wy1}{\DW{y}{1}}{right=of rx3}
  \po{rx3}{wy1}
  \event{wx1}{\DW{x}{1}}{right=2em of wy1}
  \event{rx2}{\DR{x}{2}}{right=of wx1}
  \wk{wx1}{rx2}
  \event{ry1}{\DR{y}{1}}{right=of rx2}
  \event{wx3}{\DW{x}{3}}{right=of ry1}
  \po{ry1}{wx3}
  \wk[in=165,out=15]{rx2}{wx3}
  \rf[in=-170,out=-10]{wy1}{ry1}
  \rf[in=170,out=10]{wx2}{rx2}
  \rf[out=-170,in=-10]{wx3}{rx3}
  \wk[out=-170,in=-10]{wx1}{wx2}
  \wk{wx2}{rx3}
    \end{tikzinline}}
\end{gather*}


\subsection{RFUB}
Let $\aCmd$ be the right thread in \eqref{rfub}.
\begin{align*}
  \aCmd = r\GETS y\SEMI \IF{r \NOTEQ 1} \THEN z\GETS 1\SEMI r\GETS 1\FI  \SEMI x\GETS r 
\end{align*}
Then, $\hoare{\TRUE}{\aCmd}{x=1} $ and $\hoare{y \neq 1}{\bCmd}{z=1}$.  Thus, the traditional sequential semantics {\em does not} attribute any cause for the write of $1$ to $x$, as seen by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{ry}{\DR{y}{1}}{}
 \event{wx}{\DW{x}{1}}{right=of ry}
 \event{wa}{\DW{z}{1}}{below=of rx}
 \rf{ry}{wa}
\end{tikzdisplay}
Consider the
following, where all locations are initialized to $0$.  In \textsection\ref{sec:logic} we provide machinery to prove that \oota{} is
incapable of writing $1$.  The question is whether this should be possible
for \rfub, which changes \oota{} only to include a \emph{Register assignment
  From an Unexecuted Branch} \cite{BoehmOOTA}:?  
\begin{align*}
  \label{oota}  \tag{\textsc{oota}}
  y\GETS x
  \PAR&
  r\GETS y\SEMI
  x\GETS r
  \\
  \tag{\rfub1}
  \label{rfub}
  y\GETS x
  \PAR&
  r\GETS y\SEMI
  \IF{r \NOTEQ 1} \THEN z\GETS 1\SEMI r\GETS 1\FI  \SEMI x\GETS r 
\end{align*}
%and the following \emph{Out Of Thin Air} litmus test:
The change in the second
thread from \oota{} to \rfub{} is not a valid refinement under Hoare logic:
\rfub{} validates the triple $\hoare{\TRUE}{\aCmd}{x=1}$, but \oota{} does
not.  As a result, it is expected that \rfub{} may have additional behaviors.

The program writes $1$ to $x$ in both branches of the conditional.  Further,
the writes to $z$ and $x$ in the then-branch of the conditional are
independent.  Therefore, it is sensible for a compiler to hoist the write to
$x$ out of the conditional.  In our semantics, there is no dependency from
the read of $y$ to the write to $x$
The execution in question is:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|
  (\DR{y}{1})
  \prefix
  \left(
    \begin{tikzcenter}[node distance=.5em]
      \event{b1}{r\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
    \end{tikzcenter}
    % \begin{tikzcenter}[node distance=.5em]
    %   \event{b1}{r\NOTEQ1\mid\DW{z}{1}}{}
    %   \event{b2}{r\NOTEQ1\mid\DW{x}{1}}{right=of b1}
    % \end{tikzcenter}
    % \biggm\|
    % \begin{tikzcenter}[node distance=1em]
    %   \event{c1}{r\EQ1\mid\DW{x}{1}}{}
    % \end{tikzcenter}
  \right)
\end{displaymathsmall}
With an internal read of $y$, we have:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|
    \begin{tikzcenter}[node distance=1em]
      \event{b1}{y\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
    \end{tikzcenter}
\end{displaymathsmall}
but the precondition $y\NOTEQ1$ cannot be satisfied locally.
With an external read of $(\DR{y}{1})$, we can discharge the precondition, but in this
case, the predicate becomes $1\NOTEQ 1$. 
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|  
    \begin{tikzcenter}[node distance=1em]
      \nonevent{b1}{1\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \event{b0}{\DR{y}{1}}{left=of b1}
      \po{b0}{b1}
    \end{tikzcenter}
\end{displaymathsmall}


\endinput

\paragraph{Load buffering and thin air.}
The program
\begin{math}
  %x\GETS0\SEMI y\GETS0\SEMI
  (y\GETS x \PAR \bReg\GETS y\SEMI x\GETS1)
\end{math}
has top level executions that result in the final outcome $x = y = 1$, such as:
\begin{tikzdisplay}[node distance=1em]
  % \event{wx0}{\DW{x}{0}}{}
  % \event{wy0}{\DW{y}{0}}{below=wx0}
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=3em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  %\po{rx}{wy}
\end{tikzdisplay}
In \textsection\ref{sec:logic} we provide machinery to prove that this
outcome is impossible if there is order from read to write in both
threads.  This order can be achieved by replacing the second thread
\begin{math}
  (\bReg\GETS y\SEMI x\GETS1)
\end{math}
with 
\begin{math}
  (\bReg\GETS y\ACQ\SEMI x\GETS1)
\end{math}
or
\begin{math}
  (\IF{y}\THEN x\GETS 1\FI)
\end{math}
or
\begin{math}
  (x\GETS y).
\end{math}

A more interesting example is the following variant of \eqref{types}:
\begin{displaymath}
  %\label{alan}
  % x\GETS0\SEMI
  %y\GETS0\SEMI   
  (
    y\GETS x
  \PAR
    \IF{z}\THEN x\GETS1 \ELSE x\GETS y\SEMI a\GETS y \FI
  \PAR
    z\GETS0\SEMI z\GETS1
  )
\end{displaymath}
This program is allowed to write $1$ to $a$ under many speculative
memory models
\cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17},
even though the read of $1$ from $y$ in the else branch of the second
thread arises out of thin air.   \citet{DBLP:journals/toplas/Lochbihler13}
argues that such executions compromise type safety unless object allocation
partitions memory by type.
In our model, the attempted execution is:
\begin{tikzdisplay}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{below=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=of rx}
  \event{wx}{\DW{x}{1}}{below=of ry}
  \po{ry}{wx}
  \rf{wy}{ry}
  \rf{wx}{rx}
  \event{rz}{\DR{z}{0}}{right=of ry}
  \event{wz0}{\DW{z}{0}}{right=of rz}
  \rf{wz0}{rz}
  \event{wz1}{\DW{z}{1}}{right=of wz0}
  \wk{wz0}{wz1}
  \event{ry1}{\DR{y}{1}}{below=of rz}
  \rf[bend right]{wy}{ry1}
  \event{wa}{\DW{a}{1}}{right=of ry1}
  \po{ry1}{wa}
  \po{rz}{wa}
\end{tikzdisplay}
This is forbidden by the evident cycle.


\begin{verbatim}



y=x+1; a=y || x=y
prove a!=2

Wyv_1 /\ Wyv_2 => v_1 == v_2 (and maybe v_1==0 \/ v_2==0)
Wx1 => <>-1 Ry1
Wy1 => <>-1 Rx1
\end{verbatim}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
