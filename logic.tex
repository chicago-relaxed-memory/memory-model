\section{Invariant Reasoning in Temporal Logic}
\label{sec:logic}

A significant challenge for a software memory model is to relax order enough
to allow efficient implementation without admitting anomalous
behaviors---called \emph{out of thin air} \oota\ in the literature
\cite{vacuous,DBLP:conf/esop/BattyMNPS15,BoehmOOTA}.  The most famous example is:
\begin{align}
  \label{oota1}
  (y\GETS x \PAR x\GETS y) %\SEMI x\GETS r)
  &&
  %\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=3em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \po{ry}{wx}
  \rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
    \end{tikzinline}}
\end{align}
Although Java does not allow \eqref{oota1},
\citet{DBLP:journals/toplas/Lochbihler13} showed that it does allow \oota\
behaviors of \eqref{lochbihler}.  In this case, the violation is a subtler
temporal property.  We develop a logic sufficient to prove that our semantics
disallows \oota\ on \eqref{lochbihler}.  

We adapt past linear temporal logic (\pLTL)
\cite{Lichtenstein:1985:GP:648065.747612} to pomsets by dropping the previous
instant operator and adopting strict versions of the temporal operators.
We ignore synchronization; the atoms of our logic are write and read events.
% \begin{displaymath}
%   \afo \QUAD::=\QUAD
%   \DR{\aLoc}{\aVal}
%   \mid
%   \DW\aLoc\aVal
%   \afo \wedge\bfo
%   \mid \lnot \afo
%   \once\afo
%   \mid \always\afo
% \end{displaymath}
%\begin{definition} %[Satisfaction]
Given a pomset $\aPS$ and event $\aEv$, define\footnote{Let $\FALSE$, $\lor$,
  $\Rightarrow$ and $\once$ as usual;
  for example,
  $\once\afo = \lnot(\always\lnot\afo)$.}:
  \begin{displaymath}
    \begin{array}{lrl}
      \aPS,\aEv &\models& \DW{\aLoc}{\aVal}, \text{ if } \labeling(\aEv) =  (\TRUE\mid \DW{\aLoc}{\aVal}) \\
      \aPS,\aEv &\models& \DR{\aLoc}{\aVal}, \text{ if } \labeling(\aEv) =  (\TRUE\mid \DR{\aLoc}{\aVal}) \\
      \aPS,\aEv &\models& \afo\land\bfo, \text{ if } \aPS,\aEv \models  \afo \text{ and } \aPS,\aEv \models  \bfo \\
      \aPS,\aEv &\models& \TRUE\\
      \aPS,\aEv &\models& \lnot\afo, \text{ if } \aPS,\aEv \not\models \afo \\
      %\aPS,\aEv &\models& \once\afo, \text{if } (\exists \bEv \le \aEv, \bEv\not=\aEv)  \aPS,\bEv \models \afo \\
      \aPS,\aEv &\models& \always\afo, \text{ if } (\forall \bEv \lt \aEv)\; \aPS,\bEv \models \afo
    \end{array} 
  \end{displaymath}

  % \begin{definition}
  Let $\aPS \models \afo$ if
  $\aPS,\aEv \models\afo$, for all $\aEv \in \Event$.

  Let $\aPSS\models \afo$
  if $\aPS \models\afo$, for all $\aPS \in \aPSS$.
  
Let
  \begin{math}
    \afo, \aPSS \models \bfo  \text{ if } \{ \aPSS \mid \aPSS \models \afo \} \parallel \aPSS \models \bfo.
  \end{math}
%\end{definition}

  Thus, $\aPS\models \afo \land \always\afo$ whenever $\aPS \models
  \afo$. This fact relies on the use of universal quantification in the definition.

% We define other connectives as standard:
% $\once\afo = \lnot(\always\lnot\afo)$,
% %$\FALSE = \lnot(\TRUE)$
% $\afo\lor\bfo = \lnot(\lnot(\afo)\land\lnot(\bfo))$, and
% $\afo\Rightarrow\bfo = \lnot(\afo) \lor\ \bfo$.
% \begin{displaymath}
% \begin{array}{lrl}
% \once\afo &=& \lnot(\always\lnot\afo) \\
% \FALSE &=& \lnot(\TRUE) \\
% \afo\lor\bfo &=& \lnot(\lnot(\afo)\land\lnot(\bfo)) \\
% \afo\Rightarrow\bfo &=& \lnot(\afo) \lor\ \bfo
% \end{array}
% \end{displaymath}
%Let $$ be defined as $$. 
%In addition, let $\FALSE$, $\lor$ and $$ be defined in the
%standard way.
% $\afo\lor\bfo$ for $\lnot(\lnot \afo \land \lnot \bfo)$,
% and $\afo \Rightarrow \bfo$ for $\lnot \afo \lor \bfo$.
The past operators do not include the current
instant, and thus they do \emph{not} satisfy the rule
\begin{math}
  \always\afo\Rightarrow\once\afo.
\end{math}
because the \emph{roots}---the minimal elements of a pomset---always validate $\always\afo$ and always invalidate $\once\afo$.  
However, they do satisfy:
% \begin{align*}  
%   \frac{\aPS \models \afo \Rightarrow\once{\afo}}{\aPS \models \lnot \afo}\text{(Coinduction)}
%   &&
%   \frac{\aPS \models \always\afo \Rightarrow\afo}{\aPS \models \afo}\text{(Induction)}
% \end{align*}
% \begin{lemma}
% Given an pomset $\aPS$.  
\begin{gather*}
  \tag{Coinduction}
  \aPS \models (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
  \\[-1ex]
  \tag{Induction}
  \aPS \models (\always\afo \Rightarrow\afo) \Rightarrow\afo
\end{gather*}
% \end{lemma}
% \begin{proof}
% We prove that any node in a pomset satisfies these formulas.  
The proof for both rules proceeds by induction on the length of the maximal path from a root to a node. 
%\end{proof}

% \begin{description}
% \item[Coinduction.]
%   \begin{math}
%     (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
%   \end{math}
% \item[Induction.] 
%   \begin{math}
%     (\always\afo \Rightarrow\afo) \Rightarrow\afo
%   \end{math}
% \end{description}


%We now present two proof rules for programs. 

\paragraph*{Proof rules for programs}
We present two proof rules for programs. 
 The first rule captures the semantics of
local variables.  Define
\begin{math}
  \closed(\aLoc) = (\DR{\aLoc}{\aVal} \Rightarrow \once \DW{\aLoc}{\aVal}).
\end{math}
Although this definition does not mention intervening writes, it is
sufficient for our example.  It is straightforward to establish that
following rule is sound:
\begin{displaymath}
  %\tag{Closing $\aLoc$}
  \frac{
    \afo \text{ is independent of } \aLoc
    \qquad
    \aPS \models \closed(\aLoc) \Rightarrow \afo
  }{
    \nu \aLoc \DOT \aPS \models \afo
  }
\end{displaymath}

The second rule describes composition, in the style of~\citet{Abadi:1993:CS:151646.151649}.  To simplify the presentation, we
consider the special case with a single invariant.
% We view the
% composition result as capturing key aspects of no-ThinAirRead, as will become
% clearer in the examples below.
In order to state the theorem, we generalize the satisfaction relation to
include environment assumptions.

We say that $\afo$ is prefix closed when
$\{ \aPSS \mid \aPSS \models \afo \}$ is.
\begin{proposition}%[Composition]
  Let $\afo$ be prefix-closed.  Let $\aPSS_1, \aPSS_2$ be
  augmentation\hyp{}closed.%\footnote{$\aPS'$ is an augmentation of $\aPS$ if
 %   $\Event'=\Event$, $\aEv\le\bEv$ implies $\aEv\le'\bEv$, $\aEv\gtN\bEv$
 %   implies $\aEv\gtN'\bEv$, and
 %   % $\labeling'(\aEv)=\labeling(\aEv)$
 %   if $\labeling(\aEv) = (\bForm \mid \bAct)$ then
 %   $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies
 %   $\bForm$.}
  Then:
  \begin{displaymath}
    %\tag{Composition}
    \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
  \end{displaymath}
\end{proposition}
\begin{proof}[Proof sketch]
  We will show that all prefixes in the prefix closures of
  $\aPSS_1 \parallel \aPSS_2$ satisfy the required property.  Proof proceeds
  by induction on prefixes of $\aPS \in \aPSS_1 \parallel \aPSS_2$.
  %
  The case for empty prefix  follows from assumption that  $\afo$ is prefix closed.  
  %
  For the inductive case, consider %$\aPS$ in the prefix closure of $\aPSS_1 \parallel \aPSS_2$, i.e.
  $\aPS \in \aPS_1 \parallel \aPS_2$ where
  $\aPS_i \in \aPSS_i$.  Since $\aPSS_1$ and $\aPSS_2$ are augmentation
  closed, we can assume that the restriction of $\aPS$ to the events of
  $\aPS_i$ coincides with $\aPS_i$, for $i=1,2$.
  %
  Consider a prefix $\aPS'$ derived by removing a maximal element $\aEv$ from
  $\aPS$.  Suppose $\aEv$ comes from $\aPS_1$ (the other case is
  symmetric). Since $\aPS_2$ is a prefix of $\aPS'$ and $\aPS' \models \afo$
  by induction hypothesis, we deduce that $\aPS_2 \models \afo$.
  % Thus, $\aPS_2 \in \mods{(\afo)}$.
  Since $\aPS_1 \in \aPSS_1$, by assumption $\afo, \aPSS_1 \models\afo$ we
  deduce that $\aPS \models \afo$.
\end{proof}

This simple principle is sufficient reason about examples similar to
\eqref{lochbihler}, which show that side-effecting computations only
available on one side of a conditional must not be available to the other
side.  In our language, we write this as:
% A more general principle, in the spirit of~\citet{Abadi:1993:CS:151646.151649} can be proved.  We chose the simple case of temporal invariants to illustrate the idea in a simple form.  Even this simple version has interesting consequences. 
\begin{align}
  \label{alan}
  &\VAR  x\GETS0\SEMI \VAR  y\GETS0\SEMI \VAR  z\GETS0\SEMI
  (z\GETS1
  \\[-1ex]
  \nonumber
  &\;\;
  \PAR
    y\GETS x
  \PAR
    \IF{z}\THEN x\GETS1 \ELSE r\GETS y \SEMI x\GETS r \SEMI a\GETS r \FI
  )
\end{align}
Attempting to write $1$ to $a$ results in a cycle:
\begin{tikzdisplay}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{left=2em of rx}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{rz}{\DR{z}{0}}{right=2em of wy}
  \event{ry}{\DR{y}{1}}{right=of rz}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \po{ry}{wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=10,in=170]{rz}{wa}
  \po[out=-15,in=-165]{ry}{wa}
\end{tikzdisplay}
This retaining the essential temporal aspects of
\citeauthor{DBLP:journals/toplas/Lochbihler13}'s example: all threads satisfy
the invariant ``a write to $a$ is preceded by a read of \texttt{z} as $1$.''
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy0}{\DW{y}{0}}{}
%   \event{rx}{\DR{x}{1}}{right=4.5em of wy0}
%   \event{wy}{\DW{y}{1}}{right=of rx}
%   \po{rx}{wy}
%   \wk[bend left]{wy0}{wy}
%   \event{wx0}{\DW{x}{0}}{below=of wy0}
%   \event{rz}{\DR{z}{0}}{right=of wx0}
%   \event{ry}{\DR{y}{1}}{right=of rz}
%   \event{wx}{\DW{x}{1}}{right=of ry}
%   \event{ry1}{\DR{y}{1}}{right=of wx}
%   \event{wa}{\DW{a}{1}}{right=of ry1}
%   \rf{wy}{ry1}
%   \po{ry}{wx}
%   \wk[bend right]{wx0}{wx}
%   \rf{wy}{ry}
%   \rf{wx}{rx}
%   \event{wz0}{\DW{z}{0}}{below=of wx0}
%   \event{wz1}{\DW{z}{1}}{right=of wz0}
%   \rf{wz0}{rz}
%   \wk{wz0}{wz1}
%   \po{ry1}{wa}
%   \po[bend right]{rz}{wa}
% \end{tikzdisplay}
We prove the formula
\begin{math}
  \lnot\once(\DW{a}{1})
\end{math}
holds for the models of this program.  We start with the following invariant,
which holds for each of the three threads, and thus, by composition, for the
aggregate program:
\begin{scope}
\small
\begin{align*}
  [\once\DW{y}{1} \Rightarrow \once\DR{x}{1}]
  \land
  [\once\DW{a}{1} \Rightarrow (\once\DR{y}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{y}{1})]
\end{align*}
\end{scope}
Closing $y$ gives us
\begin{math}
  \once\DR{y}{1} \Rightarrow \once\DW{y}{1}, % \Rightarrow \once\DR{x}{1}
\end{math}
which we substitute into the left conjunct to get
\begin{math}
  \once\DR{y}{1} \Rightarrow \once\DR{x}{1}.
\end{math}
In turn, we substitute into the right conjunct to get:
\begin{displaymath}
  \once\DW{a}{1} \Rightarrow (\once\DR{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{x}{1}))
\end{displaymath}
Closing $x$, we can replace $\once\DR{x}{1}$ with $\once\DW{x}{1}$:
\begin{displaymath}
  \once\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DW{x}{1})
\end{displaymath}
Applying coinduction to the right conjunct, we have:
\begin{displaymath}
  \once\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\lnot \DW{x}{1}))
\end{displaymath}
Simplifying, we have
\begin{math}
  \once\DW{a}{1} \Rightarrow \FALSE,
\end{math}
as required.

This example is superficially similar to the following, which can write $a$
without cycles: $(\DW{x}{1})$ is independent of $(\DR{y}{1})$.
\begin{gather*}
    y\GETS x
  \PAR
    \IF{y}\THEN r\GETS y\SEMI x\GETS r\SEMI a\GETS r \ELSE x\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=2em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=-15,in=-165]{ry}{wa}
    \end{tikzinline}}
\end{gather*}

It is easier to prove that the ``random number generator''
\cite[(\textsc{rng})]{DBLP:conf/esop/SvendsenPDLV18} is incapable of writing
2:
\begin{gather*}
  %\VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI  %\\[-.5ex]
  \begin{aligned}
  (
  y\GETS x+1
  \PAR
  x\GETS y
  )
  &&
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{2}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=3em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \po{ry}{wx}
  %\rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
    \end{tikzinline}} 
  \end{aligned}
  \\
  \hbox{$
  \begin{gathered}
    [(\once\DW{y}{v_1} \land \once\DW{y}{v_2}) \Rightarrow ((v_1 \EQ v_2) \vee (v_1 \EQ 0) \vee (v_2 \EQ 0))] \\[-.5ex]
    \land [\once\DW{x}{1} \Rightarrow \once\DR{y}{1}] \land 
    [\once\DW{y}{2} \Rightarrow \once\DR{x}{1}]  % \land 
    % [\once\DW{z}{2} \Rightarrow \once\DR{y}{2}]
  \end{gathered}$}
\end{gather*}
% \begin{displaymath}
%   \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI  %\\[-.5ex]
%   (
%     y\GETS x+1\SEMI z \GETS y
%   \PAR
%     x\GETS y
%   )
% \end{displaymath}
% \begin{scope}
%   \small
%   \begin{gather*}
%     [(\once\DW{y}{v_1} \land \once\DW{y}{v_2}) \Rightarrow ((v_1 = v_2) \vee (v_1 = 0) \vee (v_2 = 0))] \land\\[-.5ex]
%     [\once\DW{x}{1} \Rightarrow \once\DR{y}{1}] \land 
%     [\once\DW{y}{2} \Rightarrow \once\DR{x}{1}]  \land 
%     [\once\DW{z}{2} \Rightarrow \once\DR{y}{2}]
%   \end{gather*}
% \end{scope}
The attempted execution is disallowed since there is no write to fulfill
$\DR{y}{1}$.  To prove this, we use the invariant above. Closing $y$ on the
last conjunct, we have
\begin{math}
  %\once\DW{z}{2} \Rightarrow \once\DR{y}{2}
  %\once\DW{z}{2} \Rightarrow \once\DW{y}{2}
  \once\DW{y}{2} \Rightarrow \once\DR{x}{1}.
\end{math}
Closing $x$, we then have
\begin{math}
% \once\DW{z}{2} \Rightarrow \once\DW{x}{1}
  \once\DW{y}{2} \Rightarrow \once\DR{y}{1}.
\end{math}
From the first conjunct, we derive
\begin{math}
  \once\DW{y}{2} \Rightarrow \FALSE,
\end{math}
as required.

\citet[Fig.~3]{DBLP:journals/pacmpl/ChakrabortyV19} introduce \weakestmo{} to
disallow the following outcome, which is allowed by the promising semantics
\cite{DBLP:conf/popl/KangHLVD17}:
\begin{gather*}
  \label{weakestmo}
  x\GETS 2\SEMI
  \IF{x\NOTEQ2}\THEN y\GETS 1 \FI
  \PAR
  x\GETS 1\SEMI
  r\GETS x\SEMI
  \IF{y}\THEN x\GETS 3 \FI
  \\\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{\DW{x}{2}}{}
  \event{rx3}{\DR{x}{3}}{right=of wx2}
  \event{wy1}{\DW{y}{1}}{right=of rx3}
  \po{rx3}{wy1}
  \event{wx1}{\DW{x}{1}}{right=2em of wy1}
  \event{rx2}{\DR{x}{2}}{right=of wx1}
  \wk{wx1}{rx2}
  \event{ry1}{\DR{y}{1}}{right=of rx2}
  \event{wx3}{\DW{x}{3}}{right=of ry1}
  \po{ry1}{wx3}
  \wk[in=165,out=15]{rx2}{wx3}
  \rf[in=-170,out=-10]{wy1}{ry1}
  \rf[in=170,out=10]{wx2}{rx2}
  \rf[out=-170,in=-10]{wx3}{rx3}
  \wk[out=-170,in=-10]{wx1}{wx2}
  \wk{wx2}{rx3}
    \end{tikzinline}}
\end{gather*}


\endinput

\paragraph{Load buffering and thin air.}
The program
\begin{math}
  %x\GETS0\SEMI y\GETS0\SEMI
  (y\GETS x \PAR \bReg\GETS y\SEMI x\GETS1)
\end{math}
has top level executions that result in the final outcome $x = y = 1$, such as:
\begin{tikzdisplay}[node distance=1em]
  % \event{wx0}{\DW{x}{0}}{}
  % \event{wy0}{\DW{y}{0}}{below=wx0}
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=3em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  %\po{rx}{wy}
\end{tikzdisplay}
In \textsection\ref{sec:logic} we provide machinery to prove that this
outcome is impossible if there is order from read to write in both
threads.  This order can be achieved by replacing the second thread
\begin{math}
  (\bReg\GETS y\SEMI x\GETS1)
\end{math}
with 
\begin{math}
  (\bReg\GETS y\ACQ\SEMI x\GETS1)
\end{math}
or
\begin{math}
  (\IF{y}\THEN x\GETS 1\FI)
\end{math}
or
\begin{math}
  (x\GETS y).
\end{math}

A more interesting example is the following variant of \eqref{types}:
\begin{displaymath}
  %\label{alan}
  % x\GETS0\SEMI
  %y\GETS0\SEMI   
  (
    y\GETS x
  \PAR
    \IF{z}\THEN x\GETS1 \ELSE x\GETS y\SEMI a\GETS y \FI
  \PAR
    z\GETS0\SEMI z\GETS1
  )
\end{displaymath}
This program is allowed to write $1$ to $a$ under many speculative
memory models
\cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17},
even though the read of $1$ from $y$ in the else branch of the second
thread arises out of thin air.   \citet{DBLP:journals/toplas/Lochbihler13}
argues that such executions compromise type safety unless object allocation
partitions memory by type.
In our model, the attempted execution is:
\begin{tikzdisplay}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{below=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=of rx}
  \event{wx}{\DW{x}{1}}{below=of ry}
  \po{ry}{wx}
  \rf{wy}{ry}
  \rf{wx}{rx}
  \event{rz}{\DR{z}{0}}{right=of ry}
  \event{wz0}{\DW{z}{0}}{right=of rz}
  \rf{wz0}{rz}
  \event{wz1}{\DW{z}{1}}{right=of wz0}
  \wk{wz0}{wz1}
  \event{ry1}{\DR{y}{1}}{below=of rz}
  \rf[bend right]{wy}{ry1}
  \event{wa}{\DW{a}{1}}{right=of ry1}
  \po{ry1}{wa}
  \po{rz}{wa}
\end{tikzdisplay}
This is forbidden by the evident cycle.


\begin{verbatim}



y=x+1; a=y || x=y
prove a!=2

Wyv_1 /\ Wyv_2 => v_1 == v_2 (and maybe v_1==0 \/ v_2==0)
Wx1 => <>-1 Ry1
Wy1 => <>-1 Rx1
\end{verbatim}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
