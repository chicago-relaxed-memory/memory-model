\section{Invariant Reasoning in Temporal Logic}
\label{sec:logic}

A significant challenge for a software memory model is to relax order enough
to allow efficient implementation without admitting anomalous
behaviors---called \emph{out of thin air} (\oota) in the literature
\cite{vacuous,DBLP:conf/esop/BattyMNPS15,BoehmOOTA}.  The most famous example is:
\begin{align}
  \label{oota1}
  (y\GETS x \PAR r\GETS y\SEMI x\GETS r)
  &&
  %\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=2em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \po{ry}{wx}
  \rf{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
    \end{tikzinline}}
\end{align}
Although Java does not allow \oota{} behaviors of \eqref{oota1},
\citet{DBLP:journals/toplas/Lochbihler13} showed that it does allow \oota\
behaviors of \eqref{lochbihler}, from \textsection\ref{sec:intro}.
\citet{DBLP:conf/lics/JeffreyR16} described a logic that rules out \eqref{oota1} but not \eqref{lochbihler}.  In this section, we  provide a more accurate test of \oota{} behaviors  by enhancing their logic with temporal features.
% In this case, the violation is a subtler
% temporal property.  We develop a logic sufficient to prove that our semantics
% disallows \oota\ on \eqref{lochbihler}.  
The logic is not meant to be
definitive; in \textsection\ref{sec:outro}, we discuss \oota{} examples that require non-trivial extensions.

We adapt past linear temporal logic (\pLTL)
\cite{Lichtenstein:1985:GP:648065.747612} to pomsets by dropping the previous
instant operator and adopting strict versions of the temporal operators.
The atoms of our logic are write and read events.
% \begin{displaymath}
%   \afo \QUAD::=\QUAD
%   \DR{\aLoc}{\aVal}
%   \mid
%   \DW\aLoc\aVal
%   \afo \wedge\bfo
%   \mid \lnot \afo
%   \once\afo
%   \mid \always\afo
% \end{displaymath}
%\begin{definition} %[Satisfaction]
Given a pomset $\aPS$ and event $\aEv$, define\footnote{Let $\FALSE$, $\lor$,
  $\Rightarrow$ and $\once$ as usual;
  for example,
  $\once\afo = \lnot(\always\lnot\afo)$.}:
  \begin{displaymath}
    \begin{array}{lrl}
      \aPS,\aEv &\models& \DW{\aLoc}{\aVal}, \text{ if } \labelingAct(\aEv) = \DW{\aLoc}{\aVal} \text{ and } \TRUE \text{ implies } \labelingForm(\aEv) \\
      \aPS,\aEv &\models& \DR{\aLoc}{\aVal}, \text{ if } \labelingAct(\aEv) = \DR{\aLoc}{\aVal} \text{ and } \TRUE \text{ implies } \labelingForm(\aEv) \\
      \aPS,\aEv &\models& \afo\land\bfo, \text{ if } \aPS,\aEv \models  \afo \text{ and } \aPS,\aEv \models  \bfo \\
      \aPS,\aEv &\models& \TRUE\\
      \aPS,\aEv &\models& \lnot\afo, \text{ if } \aPS,\aEv \not\models \afo \\
      \aPS,\aEv &\models& \once\afo,\mkern1.5mu \text{if } (\exists \bEv \lt \aEv)\;  \aPS,\bEv \models \afo \\
      \aPS,\aEv &\models& \always\afo, \text{ if } (\forall \bEv \lt \aEv)\; \aPS,\bEv \models \afo
    \end{array} 
  \end{displaymath}

  % \begin{definition}
  Let $\aPS \models \afo$ if
  $\aPS,\aEv \models\afo$, for all $\aEv \in \Event$.

  Let $\aPSS\models \afo$
  if $\aPS \models\afo$, for all $\aPS \in \aPSS$.
  
Let
  \begin{math}
    \afo, \aPSS \models \bfo  \text{ if } \{ \bPSS \mid \bPSS \models \afo \} \parallel \aPSS \models \bfo.
  \end{math}
%\end{definition}

  Let $\afo$ be \emph{prefix closed} when
  $\{ \bPSS \mid \bPSS \models \afo \}$ is.

% Thus, $\aPS\models \afo \land \always\afo$ whenever $\aPS \models
  % \afo$. This fact relies on the use of universal quantification in the definition.

% We define other connectives as standard:
% $\once\afo = \lnot(\always\lnot\afo)$,
% %$\FALSE = \lnot(\TRUE)$
% $\afo\lor\bfo = \lnot(\lnot(\afo)\land\lnot(\bfo))$, and
% $\afo\Rightarrow\bfo = \lnot(\afo) \lor\ \bfo$.
% \begin{displaymath}
% \begin{array}{lrl}
% \once\afo &=& \lnot(\always\lnot\afo) \\
% \FALSE &=& \lnot(\TRUE) \\
% \afo\lor\bfo &=& \lnot(\lnot(\afo)\land\lnot(\bfo)) \\
% \afo\Rightarrow\bfo &=& \lnot(\afo) \lor\ \bfo
% \end{array}
% \end{displaymath}
%Let $$ be defined as $$. 
%In addition, let $\FALSE$, $\lor$ and $$ be defined in the
%standard way.
% $\afo\lor\bfo$ for $\lnot(\lnot \afo \land \lnot \bfo)$,
% and $\afo \Rightarrow \bfo$ for $\lnot \afo \lor \bfo$.
  The past operators do not include the current instant, and so
  do \emph{not} satisfy
  $(\always\afo\Rightarrow\once\afo)$\footnote{The order-minimal elements always validate
    $\always\afo$ and invalidate
    $\once\afo$.}.
  However, the following hold:
% \begin{align*}  
%   \frac{\aPS \models \afo \Rightarrow\once{\afo}}{\aPS \models \lnot \afo}\text{(Coinduction)}
%   &&
%   \frac{\aPS \models \always\afo \Rightarrow\afo}{\aPS \models \afo}\text{(Induction)}
% \end{align*}
% \begin{lemma}
% Given an pomset $\aPS$.  
\begin{align*}
  \tag{Induction}
  \aPS \models& (\always\afo \Rightarrow\afo) \Rightarrow\afo
  \\[-1ex]
  \tag{Coinduction}
  \aPS \models& (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
  \\[-1ex]
  \tag{Weakening}
  \aPS \models& (\afo \Rightarrow\once{\bfo}) \Rightarrow (\once\afo \Rightarrow\once{\bfo})
\end{align*}
% \end{lemma}
% \begin{proof}
% We prove that any node in a pomset satisfies these formulas.  
%The proof for both rules proceeds by induction on the length of the maximal path from a root to a node. 
%\end{proof}

% \begin{description}
% \item[Coinduction.]
%   \begin{math}
%     (\afo \Rightarrow\once{\afo}) \Rightarrow\lnot \afo
%   \end{math}
% \item[Induction.] 
%   \begin{math}
%     (\always\afo \Rightarrow\afo) \Rightarrow\afo
%   \end{math}
% \end{description}


%We now present two proof rules for programs. 

%\paragraph*{Proof rules for programs}
We present two proof rules for programs. 
The first provides a logical view of \emph{$\aLoc$-closure} (Definition~\ref{def:rf}):
%The soundness proof is straightforward.
% \begin{math}
%   \closed(\aLoc) = (\DR{\aLoc}{\aVal} \Rightarrow \once \DW{\aLoc}{\aVal}).
% \end{math}
% Although this definition does not mention intervening writes, it is
% sufficient for our example.  
\begin{displaymath}
  %\tag{Closing $\aLoc$}
  \frac{
    \afo \text{ is independent of } \aLoc
    \qquad
    %\aPS \models \closed(\aLoc) \Rightarrow \afo
    \aPS \models (\DR{\aLoc}{\aVal} \Rightarrow \once \DW{\aLoc}{\aVal}) \Rightarrow \afo
  }{
    \nu \aLoc \DOT \aPS \models \afo
  }
\end{displaymath}
%It is straightforward to establish that this rule is sound.
% Although it does
% not mention intervening writes, the rule is sufficient for our examples.

The second rule describes concurrent composition, in the style of~\citet{Abadi:1993:CS:151646.151649}.  To simplify the presentation, we
consider the special case with a single invariant.
% We view the
% composition result as capturing key aspects of no-ThinAirRead, as will become
% clearer in the examples below.
% In order to state the theorem, we generalize the satisfaction relation to
% include environment assumptions.

\begin{proposition}%[Composition]
  Let $\afo$ be prefix-closed.  Let $\aPSS_1, \aPSS_2$ be
  augmentation\hyp{}closed.%\footnote{$\aPS'$ is an augmentation of $\aPS$ if
 %   $\Event'=\Event$, $\aEv\le\bEv$ implies $\aEv\le'\bEv$, $\aEv\gtN\bEv$
 %   implies $\aEv\gtN'\bEv$, and
 %   % $\labeling'(\aEv)=\labeling(\aEv)$
 %   if $\labeling(\aEv) = (\bForm \mid \bAct)$ then
 %   $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies
 %   $\bForm$.}
  Then:
  \begin{displaymath}
    %\tag{Composition}
    \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
  \end{displaymath}
\end{proposition}
\begin{proof}[Proof sketch]
  We will show that all prefixes in the prefix closures of
  $\aPSS_1 \parallel \aPSS_2$ satisfy the required property.  Proof proceeds
  by induction on prefixes of $\aPS \in \aPSS_1 \parallel \aPSS_2$.
  %
  The case for empty prefix  follows from assumption that  $\afo$ is prefix closed.  
  %
  For the inductive case, consider %$\aPS$ in the prefix closure of $\aPSS_1 \parallel \aPSS_2$, i.e.
  $\aPS \in \aPS_1 \parallel \aPS_2$ where
  $\aPS_i \in \aPSS_i$.  Since $\aPSS_1$ and $\aPSS_2$ are augmentation
  closed, we can assume that the restriction of $\aPS$ to the events of
  $\aPS_i$ coincides with $\aPS_i$, for $i=1,2$.
  %
  Consider a prefix $\aPS'$ derived by removing a maximal element $\aEv$ from
  $\aPS$.  Suppose $\aEv$ comes from $\aPS_1$ (the other case is
  symmetric). Since $\aPS_2$ is a prefix of $\aPS'$ and $\aPS' \models \afo$
  by induction hypothesis, we deduce that $\aPS_2 \models \afo$.
  % Thus, $\aPS_2 \in \mods{(\afo)}$.
  Since $\aPS_1 \in \aPSS_1$, by assumption $\afo, \aPSS_1 \models\afo$ we
  deduce that $\aPS \models \afo$.
\end{proof}
When all variables are initially bound to $0$, we show that \eqref{oota1}
satisfies
\begin{math}
  \lnot\DW{x}{1}.
\end{math}
 We start with the invariant:
\begin{displaymath}
  [\DW{x}{1}\Rightarrow\once\DR{y}{1}]
  \land
  [\DW{y}{1}\Rightarrow\once\DR{x}{1}]
\end{displaymath}
This invariant holds for each thread; thus, it holds for the
aggregate program by composition.  Closing $y$ yields
\begin{math}
  \DR{y}{1} \Rightarrow \once\DW{y}{1}.
\end{math}
Weakening the right conjunct: % yields
\begin{math}
  \once\DW{y}{1}\Rightarrow\once\DR{x}{1}.
\end{math}
Chaining these together: %yields
\begin{math}
  \DR{y}{1} \Rightarrow \once\DR{x}{1}.
\end{math}
Weakening:  %yields
\begin{math}
  \once\DR{y}{1} \allowbreak\Rightarrow \once\DR{x}{1}. 
\end{math}
Chaining into the left conjunct:  %yields
\begin{math}
  \DW{x}{1} \Rightarrow \once\DR{x}{1}. 
\end{math}
Closing $x$, 
% \begin{math}
%   \DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
weakening, 
% \begin{math}
%   \once\DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
then chaining: %, yields
\begin{math}
  \DW{x}{1} \Rightarrow \once\DW{x}{1}. 
\end{math}
By coinduction, 
\begin{math}
  \lnot\DW{x}{1},
\end{math}
as required.

We consider a variant of
\citeauthor{DBLP:journals/toplas/Lochbihler13}'s example \eqref{lochbihler}:
% A more general principle, in the spirit of~\citet{Abadi:1993:CS:151646.151649} can be proved.  We chose the simple case of temporal invariants to illustrate the idea in a simple form.  Even this simple version has interesting consequences. 
\begin{align*}
  \label{alan}
  %   Z=1;
  % ||
  %   a=X; // 1
  %   Y=a;
  % ||
  %   b=Z; // 0
  %   if(b){
  %     X=1
  %   } else {
  %     c=Y; // 1
  %     X=c;
  %     W=c;
  %   }
  %\VAR  x\GETS0\SEMI \VAR  y\GETS0\SEMI \VAR  z\GETS0\SEMI
  z\GETS1
  \PAR
    y\GETS x
  \PAR
    \IF{z}\THEN x\GETS1 \ELSE r\GETS y \SEMI x\GETS r \SEMI a\GETS r \FI
\end{align*}
This variant retains the essential temporal aspects of \eqref{lochbihler}.
In this case, all threads satisfy the invariant ``a write to $a$ is preceded
by a read of $z$ as $1$.''

Attempting to write $1$ to $a$ results in a cycle:
\begin{tikzdisplay}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{left=2em of rx}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{rz}{\DR{z}{0}}{right=2em of wy}
  \event{ry}{\DR{y}{1}}{right=of rz}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \po{ry}{wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=10,in=170]{rz}{wa}
  \po[out=-15,in=-165]{ry}{wa}
\end{tikzdisplay}
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy0}{\DW{y}{0}}{}
%   \event{rx}{\DR{x}{1}}{right=4.5em of wy0}
%   \event{wy}{\DW{y}{1}}{right=of rx}
%   \po{rx}{wy}
%   \wk[bend left]{wy0}{wy}
%   \event{wx0}{\DW{x}{0}}{below=of wy0}
%   \event{rz}{\DR{z}{0}}{right=of wx0}
%   \event{ry}{\DR{y}{1}}{right=of rz}
%   \event{wx}{\DW{x}{1}}{right=of ry}
%   \event{ry1}{\DR{y}{1}}{right=of wx}
%   \event{wa}{\DW{a}{1}}{right=of ry1}
%   \rf{wy}{ry1}
%   \po{ry}{wx}
%   \wk[bend right]{wx0}{wx}
%   \rf{wy}{ry}
%   \rf{wx}{rx}
%   \event{wz0}{\DW{z}{0}}{below=of wx0}
%   \event{wz1}{\DW{z}{1}}{right=of wz0}
%   \rf{wz0}{rz}
%   \wk{wz0}{wz1}
%   \po{ry1}{wa}
%   \po[bend right]{rz}{wa}
% \end{tikzdisplay}

We prove the formula
\begin{math}
  \lnot\DW{a}{1},
\end{math}
starting with invariant:
% which holds for each of the three threads, and thus, by composition, for the
% aggregate program:
\begin{scope}
\small
\begin{align*}
  [\once\DW{y}{1} \Rightarrow \once\DR{x}{1}]
  \land
  [\notonce\DW{a}{1} \Rightarrow (\once\DR{y}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{y}{1}))]
\end{align*}
\end{scope}
Closing $y$ and chaining into the left conjunct:
% \begin{math}
%   \once\DR{y}{1} \Rightarrow \once\DW{y}{1}. % \Rightarrow \once\DR{x}{1}
% \end{math}
% Chaining this implication on the left:
\begin{math}
  \once\DR{y}{1} \Rightarrow \once\DR{x}{1}.
\end{math}
% We can weaken this to:
% \begin{math}
%   \once\DR{y}{1} \Rightarrow \once\DR{x}{1}. % \Rightarrow \once\DR{x}{1}
% \end{math}
Chaining into the right conjunct:
\begin{displaymath}
  \notonce\DW{a}{1} \Rightarrow (\once\DR{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DR{x}{1}))
\end{displaymath}
Closing $x$:
% \begin{math}
%   \once\DR{x}{1} \Rightarrow \once\DW{x}{1}.
% \end{math}
%  Weakening and chaining again:
%we can replace $\once\DR{x}{1}$ with $\once\DW{x}{1}$:
\begin{math}
  \notonce\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\DW{x}{1} \Rightarrow \once\DW{x}{1}).
\end{math}
Applying coinduction to the right conjunct:
\begin{displaymath}
  \notonce\DW{a}{1} \Rightarrow (\once\DW{x}{1} \land \always(\lnot \DW{x}{1}))
\end{displaymath}
Simplifying:
\begin{math}
  \notonce\DW{a}{1} \Rightarrow \FALSE,
\end{math}
as required.

Many examples are superficially similar, but can write $a$ without cycles.
In the following, $\DW{x}{1}$ is independent of $\DR{y}{1}$.
\begin{gather*}
    y\GETS x
  \PAR
    \IF{y}\THEN r\GETS y\SEMI x\GETS r\SEMI a\GETS r \ELSE x\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{rx}{\DR{x}{1}}{}
  \event{wy}{\DW{y}{1}}{right=of rx}
  \po{rx}{wy}
  \event{ry}{\DR{y}{1}}{right=2em of wy}
  \event{wx}{\DW{x}{1}}{right=of ry}
  \event{wa}{\DW{a}{1}}{right=of wx}
  \rf[out=-15,in=-165]{wy}{ry}
  \rf[out=170,in=10]{wx}{rx}
  \po[out=-15,in=-165]{ry}{wa}
    \end{tikzinline}}
\end{gather*}


% \endinput

% \paragraph{Load buffering and thin air.}
% The program
% \begin{math}
%   %x\GETS0\SEMI y\GETS0\SEMI
%   (y\GETS x \PAR \bReg\GETS y\SEMI x\GETS1)
% \end{math}
% has top level executions that result in the final outcome $x = y = 1$, such as:
% \begin{tikzdisplay}[node distance=1em]
%   % \event{wx0}{\DW{x}{0}}{}
%   % \event{wy0}{\DW{y}{0}}{below=wx0}
%   \event{rx}{\DR{x}{1}}{}
%   \event{wy}{\DW{y}{1}}{right=of rx}
%   \po{rx}{wy}
%   \event{ry}{\DR{y}{1}}{right=3em of wy}
%   \event{wx}{\DW{x}{1}}{right=of ry}
%   \rf{wy}{ry}
%   \rf[out=170,in=10]{wx}{rx}
%   %\po{rx}{wy}
% \end{tikzdisplay}
% In \textsection\ref{sec:logic} we provide machinery to prove that this
% outcome is impossible if there is order from read to write in both
% threads.  This order can be achieved by replacing the second thread
% \begin{math}
%   (\bReg\GETS y\SEMI x\GETS1)
% \end{math}
% with 
% \begin{math}
%   (\bReg\GETS y\ACQ\SEMI x\GETS1)
% \end{math}
% or
% \begin{math}
%   (\IF{y}\THEN x\GETS 1\FI)
% \end{math}
% or
% \begin{math}
%   (x\GETS y).
% \end{math}

% A more interesting example is the following variant of \eqref{types}:
% \begin{displaymath}
%   %\label{alan}
%   % x\GETS0\SEMI
%   %y\GETS0\SEMI   
%   (
%     y\GETS x
%   \PAR
%     \IF{z}\THEN x\GETS1 \ELSE x\GETS y\SEMI a\GETS y \FI
%   \PAR
%     z\GETS0\SEMI z\GETS1
%   )
% \end{displaymath}
% This program is allowed to write $1$ to $a$ under many speculative
% memory models
% \cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17},
% even though the read of $1$ from $y$ in the else branch of the second
% thread arises out of thin air.   \citet{DBLP:journals/toplas/Lochbihler13}
% argues that such executions compromise type safety unless object allocation
% partitions memory by type.
% In our model, the attempted execution is:
% \begin{tikzdisplay}[node distance=1em]
%   \event{rx}{\DR{x}{1}}{}
%   \event{wy}{\DW{y}{1}}{below=of rx}
%   \po{rx}{wy}
%   \event{ry}{\DR{y}{1}}{right=of rx}
%   \event{wx}{\DW{x}{1}}{below=of ry}
%   \po{ry}{wx}
%   \rf{wy}{ry}
%   \rf{wx}{rx}
%   \event{rz}{\DR{z}{0}}{right=of ry}
%   \event{wz0}{\DW{z}{0}}{right=of rz}
%   \rf{wz0}{rz}
%   \event{wz1}{\DW{z}{1}}{right=of wz0}
%   \wk{wz0}{wz1}
%   \event{ry1}{\DR{y}{1}}{below=of rz}
%   \rf[bend right]{wy}{ry1}
%   \event{wa}{\DW{a}{1}}{right=of ry1}
%   \po{ry1}{wa}
%   \po{rz}{wa}
% \end{tikzdisplay}
% This is forbidden by the evident cycle.


% \begin{verbatim}



% y=x+1; a=y || x=y
% prove a!=2

% Wyv_1 /\ Wyv_2 => v_1 == v_2 (and maybe v_1==0 \/ v_2==0)
% Wx1 => <>-1 Ry1
% Wy1 => <>-1 Rx1
% \end{verbatim}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
