\begin{figure}
\begin{eqnarray*}
  \sem{\SKIP}
  & = & \TIKZ{\final{f}{}{}} 
  \\
  \sem{\aLoc\GETS\aExp}
  & = & \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\aExp=\aVal\mid\DW\aLoc\aVal)}{}\final{f}{\aExp/\aLoc}{right=of a}}
  \\
  \sem{\aReg\GETS\aLoc}
  & = &
  \TIKZ{\final{f}{\aLoc/\aReg}{}}
  \cup
  \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\DR\aLoc\aVal)}{}\final{f}{\aLoc/\aReg}{right=of a}\po{a}{f}}
  \\
  \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
  & = & \bigl((\aExp \neq 0) \guard \sem{\aCmd}\bigr) \parallel \bigl((\aExp=0) \guard \sem{\bCmd}\bigr)
  \\
  \sem{\aCmd \SEQ \bCmd}
  & = & \sem{\aCmd} \sequence \sem{\bCmd}
  \\
  \sem{\aCmd \PAR \bCmd}
  & = & \sem{\aCmd}\fork \parallel \sem{\bCmd}
  \\
  \sem{\VAR\aLoc\SEMI \aCmd}
  & = & \nu \aLoc \DOT \sem{\aCmd}
\end{eqnarray*}
\caption{Semantics of a concurrent shared-memory language}
\label{fig:semi:programs}
\end{figure}

\section{Sequential Composition}
\label{sec:semi:model}
\subsection{Data models}
\label{sec:semi:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{substitutions} $\Sub$, ranged over by
  $\aSub$ and $\bSub$,
\end{itemize}
% Let $\LR=\Loc\cup\Reg$, be the set of \emph{locations}, ranged over by
% $\aLR$.  Let $\Sub=\LR\partialfun\Exp$ be the set of \emph{substitutions},
% ranged over by $\aSub$ and $\bSub$.
Let $\aActSub$ and $\bActSub$ range over $(\Act\cup\Sub)$.
% The empty substitution is written as $[\,]$.

We require that data models satisfy the following:
\begin{itemize}
\item substitutions include at least $[\aLoc/\aReg]$ and $[\aExp/\aLoc]$,
\item substitutions are closed under composition,
\end{itemize}
% By composition, it follows that substitutions must include $[\aExp/\aReg]$
% which is equal to $[\aLoc/\aReg][\aExp/\aLoc]$.

\subsection{Modal pomsets}
\label{sec:semi:pomsets}

We fix the alphabet $\Alphabet=(\Formulae\times(\Act\cup\Sub))$.  With this
alphabet, the labeling of a pomset determines two disjoint sets of events.
We refer to those that map to actions $\Sub$ as \emph{final}, and those that
map to substitutions $\Act$ as \emph{nonfinal}.
When we need to distinguish these, we let the set of events
$\Event=\EAct\uplus\ESub$, where $\EAct$ denotes the nonfinal events 
and $\ESub$ denotes the final events.

We write pairs in $(\Formulae\times(\Act\cup\Sub))$ as $(\aForm \mid \aActSub)$.
\subsection{Semantics of programs}
\label{sec:semi:semantics}

Semantics in Figure~\ref{fig:semi:programs}

We give the semantics using combinators over sets of pomsets, defined below.
Using $\aPSS$ to range over sets of pomsets, these are:
\begin{itemize}
\item \emph{forking} $\aPSS\fork$, which removes final states from
  $\aPSS$, 
\item \emph{sequencing} $\aPSS_1\sequence\aPSS_2$, which prepends
  $\aPSS_1$ to $\aPSS_2$, calculating dependencies between the two.
\end{itemize}

Forking is %and substitution each perform
a simple transformation on each pomset
in a set of pomsets.

\begin{definition}
Let $\aPSS\fork$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \EAct$,
$\labeling'\subseteq\labeling$,
$\aEv\le'\bEv$ whenever $\aEv\le\bEv$, and
$\aEv\gtN'\bEv$ whenever $\aEv\gtN\bEv$.
\end{definition}

\subsection{Sequencing}
\begin{definition}
  \label{def:semi:seq}
  Let $\aPS' \in (\aPSS_1 \sequence \aPSS_2)$ whenever there are
  $\aPS_1 \in \aPSS_1$ and $\aPS_{\cEv}\in\aPSS_2$, for every
  $\cEv\in\ESub_1$, such that:
\begin{itemize}
\item $\Event' = \EAct_1 \cup \bigcup_{\cEv}\Event_{\cEv}$,
\item if $\bEv \le_1 \aEv$ or $\bEv\le_{\cEv} \aEv$ then $\bEv \le' \aEv$,
\item if $\bEv \gtN_1 \aEv$ or $\bEv\gtN_{\cEv} \aEv$ then $\bEv \gtN' \aEv$,
\item if $\bEv\in\EAct_1$ then $\labeling'(\bEv) = \labeling_1(\bEv)$, and
\item if $\labeling_1(\bEv) = (\dontcare \mid \aAct)$ and
  $\labeling_{\cEv}(\aEv) = (\bForm \mid \bAct)$ then:
  \begin{itemize}
  \item if $\aAct$ is an acquire or $\bAct$ is a release then $\bEv \lt' \aEv$,
  \item if $\aAct$ is an acquire then $\bForm$ is independent of every $\bLoc$,
  \item either $\aAct$ and $\bAct$ are provably separable, or both are reads, or
    $\bEv \gtN' \aEv$, and
  \item if $\aAct$ and $\bAct$ conflict
    then $\bEv \gtN' \aEv$, and
  \end{itemize}
\item 
  if
  $\labeling_1(\cEv) = (\dontcare \mid \aSub)$, and
  $\labeling_{\cEv}(\aEv) = (\bForm \mid \bActSub)$ then
  $\labeling'(\aEv) = (\bForm' \mid \bActSub\aSub)$ where:
  \begin{itemize}
  \item $\bForm'$ implies
    $\lor\{\aForm\mid\bEv\in\ESub_1 \land \aEv\in\aPS\!_{\bEv}
    \land \labeling_1(\bEv)=(\aForm{\mid}\dontcare)\}$,
  \item $\bForm'$ implies $\bForm\aSub$, and
  \item either $\bForm'$ implies $\bForm$ or $\bEv\lt_1\cEv$ implies $\bEv\lt'\aEv$.
    %$\bEv\in\EAct_1$ such that.
  \end{itemize}
\end{itemize}
\end{definition}


\begin{comment}
The first constraint ensures that events are ordered before a release and
after an acquire.  The second constraint ensures that thread-local reads do
not cross acquire fences.
 
The second constraint prevents bad executions like the following:
   x=1; rel; acq; if (x) {y=1};  ||  acq; x=0; rel; 
where the second thread is interleaved between the rel and acq of the first.

Note that you cannot require that $\bForm'$ is independent of every $\bLoc$
because then it's not augment closed.
\end{comment}


% To see that we need $[\aExp/\aLoc]$ in the rule for write, rather than $[\aVal/\aLoc]$
% consider example:
% \begin{verbatim}
% r=y; if (r) {x=r} else {x=r}; s=x; if (r==s) {z=1}
% \end{verbatim}
% or simplified:
% \begin{verbatim}
% r=y;x=r;s=x; if(s==r){z=1}
% \end{verbatim}
% If you read 37 for $y$, then the predicate on \texttt{Wz1} before the
% read is either $r=r$ or $v=r$, where $v=37$, for example.  In one case you
% get a dependency and in the other you do not.



% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
