\section{Efficient Implementation on ARMv8}
\label{sec:arm}

In this section, we consider the fragment of our language without
restriction.  For simplicity, we allow release and acquire synchronization
but ban fences.  We assume that all memory locations are initialized to $0$
and parallel-composition occurs only at top level.  We take the set of memory
locations to be finite.  In other words, we assume that programs have the
form
\begin{displaymath}
  {\aLoc_1}\GETS{0}\SEMI
  \cdots\SEMI
  {\aLoc_m}\GETS{0}\SEMI
  (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
\end{displaymath}
where $\aCmd^1$, \ldots, $\aCmd^n$ do not include composition, restriction or
fence operations.

Our language can be translated to ARM using \textsf{ldr} for relaxed read,
\textsf{ldar} for acquiring read, \textsf{str} for relaxed write, and
\textsf{stlr} for releasing write.  Relative to the ARM specification, we
have removed loops and read-modify-write (RMW) operations, in addition to
fences.

We show that any ARM-consistent execution graph for this sublanguage can be
considered an execution of our semantics.  

% Syntactically, we drop the superscript \textsf{rlx} on relaxed reads and
% writes; in addition, we use structured conditionals rather than the more
% general \textsf{goto}.  We refer to this sublanguage as $\muIMM$.
% (Because the source language lacks RMW operations, the ``is
% exclusive'' flag on every read will be \textsf{not-ex} and the RMW mode on
% every write will be \textsf{normal}.)

Due to space limitations, we do not include a full description ARM
consistency.  Interested readers should see \textsection\ref{sec:arm:proof}
for further details.  

Here we provide a birds eye view of the details, drawing on the intuitions gleaned from~\citet{DBLP:journals/pacmpl/PulteFDFSS18}.  

An ARM execution graph $G$ defines many relations, including program order
($\rpox$), reads-from ($\rrfx$), coherence ($\rco$) and several dependency
orders.  From these are derived:
\begin{itemize}
\item ${\rpoloc}$, which is the subrelation of $\rpox$ that only relates
  actions on the same location,
\item ${\rob}$, which is required to be acyclic (\ref{external}), and
\item $\reco$, with the requirement that ${\rpoloc}\cup{\reco}$ be acyclic (\ref{sc-per-loc}).
\end{itemize}
% Let $G$ be an execution graph satisfying the ARM consistency 
%requirements.
Given an execution graph $G$, we say that $\aEv$ is an \emph{internal read} if $\aEv\in\fcodom({\rpox}\cap {\rrfx})$.

The ${\rob}$ order is an acyclic global order on events, agreed upon by all threads, reflecting the progress of time in an \armeight\ execution.  The cross thread component of the ordering is induced by the ordering on conflicting actions on the same location from different threads.    The intra thread component of the ordering is induced by barrier ordering and data ordering.  Notably, these dependencies  are determined syntactically.  In particular, $\rob$
may not necessarily include the intra thread component of $\rpoloc$ ordering.  

This motivates the translation of an \armeight\ execution into our setting.  In our setting, the progress of time is given by $\lt$, and we accommodate intra-thread reordering by internal read and write actions, thus excusing us from the obligation of placing them on the global timeline associated with $\lt$.  

Formally, from $G$ we construct a candidate pomset $\aPS$ as follows:
\begin{itemize}
\item $\Event= \textsf{E}$,
\item $\labelingAct(\aEv)=\tau \mathsf{lab}(e)$, if $\aEv$ is a relaxed
  internal read, 
\item $\labelingAct(\aEv)=\mathsf{lab}(e)$, if $\aEv$ is not a relaxed
  internal read,
\item $\labelingForm(\aEv)=\TRUE$,
\item ${\le} = {\rob}^?$, where $?$ denotes reflexive closure, and
\item ${\gtN} = ({\rob} \cup {\reco})^*$, where $*$ denotes reflexive and transitive closure.
\end{itemize}

\begin{theorem}
  If $G$ is ARM consistent, the constructed candidate satisfying the
  requirements for a top-level memory model pomset.
\end{theorem}
It is straightforward to observe that any $\lt$ ordering imposed in our model is enforced by \armeight, since our notion of semantic dependency is more permissive than the syntactic dependency used in \armeight.   So, the acylicity of $\lt$ is clear.  By the definition of $\gtN$, it is also clear that $\lt \subseteq \gtN$.  

The heart of the proof is thus establishing the other two properties relating $\lt,\gtN$ and $\reco$, namely  (Consistency) of definition~\ref{def:3valued} and the constraints on top-level pomsets arising from definition~\ref{def:x-closed}.  Both of these constraints are coherence conditions relating $\lt$ and $\reco$, and are satisfied by ensuring that  $\lt \cup \reco$ is acyclic.  

The key to this portion of the proof are the following facts about ARM-consistent execution graphs, which we establish in \textsection\ref{sec:arm:proof}.  The subtle cases for the following where the $\reco$ relationships are intra-thread; in these cases, each of the following is immediately reflects ways in which the external order $\rob$ composes with intra thread $\reco$.  

Suppose $\aEv$, $\bEv$ and $\aEv$ are distinct events.
\begin{itemize}
\item If $\cEv\xob\bEv\xeco\aEv$ then $\cEv\xob\aEv$.
\item If $\cEv\xeco\bEv\xob\aEv$ then $\cEv\xob\aEv$.
\item If $\cEv\xob\bEv$ then $\lnot(\bEv\xeco\cEv)$.
\end{itemize}

\begin{remark}[Proof for TSO]
The proof for compilation into \tso\ is very similar.  Replace $\rob$ by the (transitive closure of the) propagation relation for $\tso$~\citet{alglave}.  The above three key facts hold for \tso\ with this substitution for $\rob$.
\end{remark}

