Relaxed memory models must simultaneously achieve efficient implementability
and thread-compositional reasoning.  Is that why they have become so
complicated?  We argue that the answer is no: It is possible to achieve these
goals by combining an idea from the 60s (preconditions) with an idea from the
 80s (pomsets), at least for \textsc{x64} and \armeight.  We show that the
resulting model (1) supports compositional reasoning for temporal safety
properties, (2) supports all expected sequential compiler optimizations,
(3) satisfies the \drfsc\ criterion, and (4) compiles to \textsc{x64} and \armeight{}
microprocessors without requiring extra fences on relaxed accesses.

\endinput

Relaxed memory models must simultaneously achieve efficient implementability
and thread-compositional reasoning.  Is that why they have become so
complicated?  We argue that the answer is no: It is possible to achieve these
goals by combining an idea from the 60s (preconditions) with an idea from the
80s (pomsets), at least for X64 and ARMv8.  We show that the resulting model
(1) supports compositional reasoning for temporal safety properties, (2)
supports all expected sequential compiler optimizations, (3) satisfies the
DRF-SC criterion, and (4) compiles to X64 and ARMv8 microprocessors without
requiring extra fences on relaxed accesses.


DePaul Abstract:

A memory model is a contract between a programmer and a system implementor
which indicates the allowed outcomes of any given program.  Some of the
things allowed on your computer might surprise you!

In your first systems class you learned a simple model of virtual memory: a
nice flat address space.  You also learned that this is a lie!  Memory
systems are remarkably complicated.  The situation is even more complex when
you consider the aggressive optimization performed by current compilers.
Although system designers are able to hide much of this complexity, they
can't hide it all without killing performance.  For fifteen years,
researchers have been looking for a model that is understandable to
programmers while still allowing efficient implementation.

In this talk, we present a (relatively) simple model that does almost
everything we want.  The model combines an idea from the 60s (preconditions)
with an idea from the 80s (pomsets).  We show that the resulting model (1)
supports compositional reasoning for temporal safety properties, (2) supports
all reasonable sequential compiler optimizations, (3) allows programmers to
use a simplistic model for race-free programs, and (4) compiles to X64 and
ARMv8 microprocessors without requiring extra fences on relaxed accesses.