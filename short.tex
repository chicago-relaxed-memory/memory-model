\section{Efficient Implementation on ARMv8}
\label{sec:arm}

We consider the fragment of our language where concurrent composition occurs
only at top level and there are no location declarations.  Using the
translation strategy of \citet{DBLP:journals/pacmpl/PodkopaevLV19}, we show
that any \emph{consistent} \armeight{} execution graph for this sublanguage
can be considered a top-level execution of our semantics.  Consistency is
defined by \citet{DBLP:journals/pacmpl/PulteFDFSS18}.  The key step is
constructing the order for the derived pomset candidate.  We would like to
take ${\gtN} = ({\rob} \cup {\reco})^*$, where $\rob$ is the \armeight{}
acyclicity relation, and ${\reco}$ is the \armeight{} extended coherence
order, as discussed after Definition~\ref{def:rf}.  But this does not quite
work.

The definition is complicated by \armeight's \emph{internal reads}, manifest
in ${\rrfi}$, which relates reads to writes that are fulfilled by the same
thread.  \armeight{} drops $\rob$-order \emph{into} an internal read.  As
discussed in \textsection\ref{sec:model}, however, our semantics drops pomset
order \emph{out of} an internal read.  To accommodate this, we drop these
dependencies from the \armeight{} \emph{dependency order before} ($\rdob$)
relation.
%
The relation ${\rdobi}$ is defined from ${\rdob}$ by restricting the order
into and out of a read that is in the codomain of the $\rrfi$ relation. More
formally, let $\bEv\xdobi\aEv$ when $\bEv\xdob\aEv$ and
$\bEv\notin\fcodom(\rrfi), \aEv \notin\fcodom(\rrfi)$.
%
% Let $\bEv\xdobi\aEv$ when $\bEv\xdob\aEv$ and
% $\bEv\notin\fcodom(\rrfi)$.
%
Let $\robi$ be defined as for $\rob$, simply replacing $\rdob$ with $\rdobi$.

% The definition is complicated by \armeight's \emph{internal reads}, manifest
% in ${\rrfi}$, which relates reads to writes that are fulfilled by the same
% thread.  \armeight{} drops $\rob$-order \emph{into} an internal read.  As
% discussed in \textsection\ref{sec:model}, however, our semantics drops pomset
% order \emph{out of} an internal read.  To accommodate this, 
% we define ${\robi}$ from ${\rob}$ by restricting the order into and out of an
% read that is in the codomain of the $\rrfi$ relation.  Formally, we drop
% these dependencies from the \armeight{} \emph{dependency order before}
% ($\rdob$) relation: let $\bEv\xdobi\aEv$ when $\bEv\xdob\aEv$ and
% $\bEv\notin\fcodom(\rrfi), \aEv \notin\fcodom(\rrfi)$.  Then $\robi$ be
% defined as for $\rob$, simply replacing $\rdob$ with $\rdobi$.


For pomset order, we then take ${\gtN}=({\robi}\cup{\reco})^*$.

We prove the following theorem in \textsection\ref{sec:arm:proof}.
\begin{theorem}
  For any consistent \armeight{} execution graph, the constructed candidate
  is a top-level memory model pomset.
\end{theorem}

The proof for compilation into \tso\ is very similar.  The necessary
properties hold for \tso, where $\rob$ is replaced by (the transitive closure
of) the \tso\ propagation relation \citep{alglave}.

% weakestmo:
% \begin{verbatim}
% Rsc ldar
% Wsc stlr
% \end{verbatim}
% Comparison to C11 from
% \cite[\textsection8.2]{Dolan:2018:BDR:3192366.3192421}:
% \begin{verbatim}
% volatile read:   dmb ld; ldar R, [x]
% volatile write:  L: ldaxr; stlxr; cbnz L; dmb st
% \end{verbatim}
% The second difference is that our atomic writes have stronger semantics,
% which is why we use atomic exchanges instead of stlr on ARMv8. Consider the
% following, using an atomic (SC atomic) location x and a nonatomic (relaxed)
% location y
% \begin{gather*}
%   r\GETS y\SEMI x^\modeSC\GETS1\SEMI s\GETS x
%   \PAR
%   % y\GETS0\SEMI
%   x^\modeSC\GETS2 \SEMI y\GETS1
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DR{y}{1}}{}
%       \event{b}{\DW[\modeSC]{x}{1}}{right=of a}
%       \po{a}{b}
%       \event{bb}{\DR{x}{2}}{right=of b}
%       \po{b}{bb}
%       % \event{c}{\DW{y}{0}}{right=2em of bb}
%       % \event{d}{\DW[\modeSC]{x}{2}}{right=of c}
%       % \po{c}{d}
%       \event{d}{\DW[\modeSC]{x}{2}}{right=2em of bb}
%       \event{e}{\DW{y}{1}}{right=of d}
%       \po{d}{e}
%       %\rf[out=170,in=10]{d}{bb}
%       \rf{d}{bb}
%       \rf[out=-170,in=-10]{e}{a}
%       \wk[in=165,out=15]{b}{d}
%     \end{tikzinline}}
% \end{gather*}
% In our model, if x = 2 afterwards, then r = 0. This is clear from the
% operational semantics: the step r = y must precede x = 1,which must precede x
% = 2 and y = 1. However, in C++ the outcome x = 2 and r = 1 is possible. In C++, SC
% atomic events are totally ordered, so r = y must happen-before x = 1, which
% must precede in the SC ordering x = 2, which must happen-before y =
% 1. However, these two orderings do not compose, and in particular r = y does
% not happen-before y = 1, and it is permissible for r = y to read-from y = 1.

% This behaviour cannot be explained operationally without either allowing
% reads to read from future writes, or allowing atomic locations to contain
% multiple or incoherent values, so it is not permitted in our simple
% operational model. However, this means that we must choose an alternative
% compilation scheme on ARMv8 and similar architectures.


\section{Data Race Free Executions are Sequentially Consistent}
\label{sec:sc}

When constructing a pomset, define \emph{program order} $(\xpox)$ in the
obvious way.  Define $\bEv\xsw\aEv$ exactly when $\bEv$ fulfills $\aEv$,
$\bEv$ is a release, $\aEv$ is an acquire, and $\lnot(\bEv\xpox\aEv)$.
Define ${\xhb}=({\xpox}\cup{\xsw})^*$.  A pomset has a
\emph{data race} if there are conflicting events that are unordered by
$\rhb$.

Note that the definition of a data-race does not mention \emph{pomset} order.
Instead, it relies on the auxiliary definition of \emph{program} order.  Thus
it is stable with respect to augmentation.

Let a \emph{generator} for $\aCmd$ be a top-level pomset that is minimal with
respect to augmentation and implication.  Let $\semsc{\aCmd}$ be the
executions as defined in Candidate~\ref{cand:sc}. % of \textsection\ref{sec:model}.

We prove the following theorem in \textsection\ref{drfproof}.
\begin{theorem}
  Let $\aPS$ be a generator for $\aCmd$.
  (a) If $\aPS$ does not have a data race, then $\aPS \in \semsc{\aCmd}$.
  (b) If $\aPS$ has a data race, then there is some
    $\aPS'\in \semsc{\aCmd}$ that also has a data race.
\end{theorem}
