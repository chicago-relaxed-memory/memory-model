
\section{Introduction}
\citet{Manson:2005:JMM:1047659.1040336} identify the central problem in the design of software relaxed memory models: ``The memory model must strike a balance between ease-of-use for programmers and implementation flexibility for system designers.''   This paper provides a solution.

%In order to sharpen the criteria to evaluate memory models, we first outline desiderata  that concretize the above prescription.  

There are two dimensions to ``implementation flexibility'':
\begin{itemize}
\item The model should be realizable on modern hardware with minimal synchronization.  A canonical example is that the relaxed atomics of C11 (or the plain variables of Java) should not require any extra synchronization.

\item The  model should facilitate compiler transformations.    Ideally, the model should support the known transformations used to optimize  synchronization free single threaded code.  A canonical example is the  commuting of independent statements.
\end{itemize}

There are also two dimensions to ``ease-of-use'':
\begin{itemize}
\item The \emph{data race free-sequentially consistent (\drfsc)} criterion~\cite{DBLP:journals/tpds/AdveH93, DBLP:conf/isca/AdveH90} permits the programmer to forget about relaxed memory for correctly synchronized programs.  

\item All programs, including those with data races,  should support compositional reasoning on temporal safety properties~\cite{PnueliSafety,Misra:1981:PNP:1313338.1313770,StarkSafety,Abadi:1993:CS:151646.151649}.  The simplest form of such a composition principle is:
\[
  \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
\]
where $\afo$ is a temporal safety property on read and write actions, and $\afo, \aPSS_1 \models\afo$ indicates that $\aPSS_1$ satisfies $\afo$ if the environment satisfies $\afo$.  This cyclical compositional proof rule permits us to reason separately about individual threads. 
\end{itemize}

We illustrate the last criterion with two examples.   
First, consider the well-known ``Out Of Thin Air'' (\oota) litmus test, with all variables initialized to $0$:
\begin{equation}
  \label{oota1}
  %x\GETS0\SEMI y\GETS0\SEMI
  (y\GETS x \PAR x \GETS y)
\end{equation}
Informally, both threads satisfy the invariant that conjoins ``A write of 1  to x  requires a prior read  of 1 from y'' and ``A write of 1  to y  requires a prior read  of 1 from x ''.  If composition holds, the full program satisfies the invariant.  Since the variable declaration closes the program from other writes to $x,y$, we  deduce the conjunction of  ``A write of 1  to x  requires a prior write  of 1 to x'' and ``A write of 1  to y  requires a prior write  of 1 from x'' . Thus, we deduce that ``A write of 1  to x  requires a prior write  of 1 to x'', and consequently ``there is no write of 1 to x''. 
Composability  of safety properties provides an  {\em objectively  falsifiable} measurement of \oota\ in a memory model. 


Now we consider the ``type unsafety'' example, from
\citep[Figure 8]{DBLP:journals/toplas/Lochbihler13}:
\begin{equation}
  \label{types}
  %x\GETS 0 \SEMI  y\GETS 0  \SEMI  b\GETS 0 \SEMI  
  x\GETS y
  \PAR
  \aReg\GETS x \SEMI \IF{b} \THEN \bReg \GETS \NEW \texttt{C()} \ELSE \aReg \GETS \NEW \texttt{D()} \FI  \SEMI y \GETS \aReg \SEMI  
  \PAR
  b \GETS 1   
\end{equation}
Prima facie, the allocation operation can pick the same address for the two new objects, because only one of them occurs in any one execution.   This causes type safety to break for racy programs in the JMM, forcing~\citeauthor{DBLP:journals/toplas/Lochbihler13} to include the type information in the address itself.
%
Informally, all threads satisfy the invariant that conjoins ``a creation of a \texttt{C} object is preceded by a read of \texttt{b} as $1$'' and ``a creation of a \texttt{D} object is preceded by a read of \texttt{b} as $0$''.  If composition holds, the full program satisfies the invariant.   
%
Composability of safety properties provides the temporal context needed to prevent the ``pointer forging''  within a single execution.  


None of the extant memory models validate both ``implementation flexibility'' and ``ease-of-use''.  

Models that validate ``ease-of-use'' include Sequential Consistency (SC)~\citet{Lamport:1979:MMC:1311099.1311750}, \citet{Dolan:2018:BDR:3192366.3192421}, \citet{DBLP:conf/pldi/LahavVKHD17}, \citet{DBLP:conf/lics/JeffreyR16}, RC11 model\cite{DBLP:conf/pldi/LahavVKHD17} and~\citet{BoehmOOTA}.  However, {\em all} of them invalidate reordering of independent statements.  \cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA,DBLP:conf/lics/JeffreyR16} forbid breaking of the program order from reads to writes and thus require extra fences after read actions in hardware implementations.  \citet{Boehm:2014:OGA:2618128.2618134} show that the RC11 model\cite{DBLP:conf/pldi/LahavVKHD17} forces a dependency or a fence between a relaxed atomic
read and a subsequent relaxed atomic write.  


As quoted at the beginning of this section, the JMM was designed with these two aims.  However, the JMM and the related models of~\citet{DBLP:conf/esop/JagadeesanPR10} and \citet{DBLP:conf/popl/KangHLVD17} invalidate compositional reasoning.  In \textsection\ref{sec:logic} we formalize a variant of \citeauthor{DBLP:journals/toplas/Lochbihler13}'s type unsafety example which demonstrates this.  
%It is also known that the JMM does not support reordering of independent statements.

Our approach builds on are  traditional gadgets from concurrency theory, namely pomsets~\citep{Plotkin:1997:TSP:266557.266600}, enriched with sequential preconditions~\citep{Hoare:1969:ABC:363235.363259}, and~\citet{DBLP:journals/dc/Lamport86}'s  analysis of time.   This simple combination of traditional features eschews the now familiar paraphernalia associated with models of relaxed memory, such as  additional relations and thread ids; instead, providing a conceptual foundation for the notion of time in our model of relaxed memory.  Sequential preconditions enable sequential evolution to proceed without the progress of global time.  ~\citet{DBLP:journals/dc/Lamport86}'s relations --- that coincide with  three-valued partial orders in modal transition systems~\citep{DBLP:conf/avmfss/Larsen89,DBLP:conf/esop/HuthJS01} in this setting --- provide an axiomatic basis for a global notion of time, as envisioned in chapter 3.3 of~\citet{AlglaveThesis}.  Thus, we  capture the essence of multi-copy atomicity (\mca) in a software memory model, whereas traditionally \mca\ is explored in hardware memory models(eg, see \citet{DBLP:journals/pacmpl/PulteFDFSS18}).  
\tso\ and recent architectures, such as \armeight, are \mca, but not older architectures, such as \ppc\ or \armseven.

We show the following.

%\paragraph{Our results. }

% \paragraph{Our results. } We describe a software relaxed memory model based on pomsets whose events are decorated by logical  preconditions.   Our model satisfies the desiderata outlined earlier.

\begin{itemize}
\item The model satisfies the \drfsc\ criterion  (\textsection\ref{sec:sc}).

\item The model compiles to \armeight\ and \tso\ {\em without} extra synchronization for raw variables  (\textsection\ref{sec:arm}).
However, a semantic version of \mca\ in our model means that a compilation to \armseven\ or \ppc\ requires extra synchronization.  

\item The model validates a variety of single threaded transformations including reordering of independent statements and roach motel laws for synchronization  (\textsection\ref{sec:opt}).
%
We provide two forms of abstract evidence that our model supports as many sequential transformations as can be expected.  First, we show a precise relationship with standard Hoare-triples for sequential code provides abstract evidence for the support afforded for compiler  transformations of traditional sequential code.  Second, we prove a ``full abstraction'' style completeness  theorem: any two synchronization free threads that are distinguished by our model can be done so with a parallel thread that is also synchronization free. 

\item The model validates compositional reasoning on safety properties (\textsection\ref{sec:logic}).  Thus, it supports the infrastructure required to prove a realistic type safety theorem that includes racy programs without requiring that that the type information is included in the address itself.
\end{itemize}
In addition, the presentation of our model provides a simple way to adapt it to forbid the relaxing of the program order from reads to writes, thus modeling\cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA}.  Perforce, this variant limits the compiler transformations, and it is already know that it satisfies the properties of \drfsc\ and hardware compilation.   The reader interested in models that forbid load buffering, can read this paper as providing an approach to validating data-sensitive compiler optimizations and compositional reasoning of temporal properties.   


%\paragraph*{Rest of the paper. }  We begin with an informal introduction to the modeling ideas in \textsection\ref{sec:model:intro}, developing the precise formalities in \textsection\ref{sec:model}.   \textsection\ref{sec:sc} proves the DRF theorem, whereas \textsection\ref{sec:arm} provides a compilation into \armeight\ and \tso.  Single threaded optimizations, and the associated completeness theorems are addressed in \textsection\ref{sec:opt}.  \textsection\ref{sec:logic} describes a temporal logic, and a compositional proof principle for proving safety properties.  \textsection\ref{sec:examples}.develops more illustrative examples.  We address related work in \textsection\ref{sec:ldrf} and conclude after.  An appendix contains details of proofs and further examples.

We give an informal introduction to the model in \textsection\ref{sec:model:intro} before presenting the precise formalities in \textsection\ref{sec:model}.
% \textsection\ref{sec:sc} proves the DRF theorem, whereas \textsection\ref{sec:arm} provides a compilation into \armeight\ and \tso.  Single threaded optimizations, and the associated completeness theorems are addressed in \textsection\ref{sec:opt}.  \textsection\ref{sec:logic} describes a temporal logic, and a compositional proof principle for proving safety properties.
We present additional examples in \textsection\ref{sec:examples} and end with
a discussion of related work in \textsection\ref{sec:ldrf}.
% An appendix
% contains details of proofs and further examples.



