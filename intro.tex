
\section{Introduction}
\citet{Manson:2005:JMM:1047659.1040336} identify the central problem in the design of software relaxed memory models: ``The memory model must strike a balance between ease-of-use for programmers and implementation flexibility for system designers.''   This paper provides a solution.

%In order to sharpen the criteria to evaluate memory models, we first outline desiderata  that concretize the above prescription.  

There are two dimensions to ``implementation flexibility'':
\begin{itemize}
\item The model should be realizable on modern hardware with minimal synchronization.  A canonical example is that the relaxed atomics of C11 (or the plain variables of Java) should not require any extra synchronization.

\item The  model should facilitate compiler transformations.    Ideally, the model should support the known transformations used to optimize  synchronization free single threaded code.  A canonical example is the  commuting of independent statements.
\end{itemize}

There are also two dimensions to ``ease-of-use'':
\begin{itemize}
\item The \emph{data race free-sequentially consistent (DRF-SC)} criterion~\cite{DBLP:journals/tpds/AdveH93, DBLP:conf/isca/AdveH90} permits the programmer to forget about relaxed memory for correctly synchronized programs.  

\item All programs, including those with data races,  should support compositional reasoning on temporal safety properties~\cite{PnueliSafety,Misra:1981:PNP:1313338.1313770,StarkSafety,Abadi:1993:CS:151646.151649}.  The simplest form of such a composition principle is:
\[
  \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
\]
where $\afo$ is a temporal safety property on read and write actions, and $\afo, \aPSS_1 \models\afo$ indicates that $\aPSS_1$ satisfies $\afo$ if the environment satisfies $\afo$.  This cyclical compositional proof rule permits us to reason separately about individual threads. 
\end{itemize}

We illustrate the last criterion with two examples.   
First, consider the well-known ``Out Of Thin Air'' (\oota) litmus test, with all variables initialized to $0$:
\begin{align*}
  \tag{*}\label{oota1}
  %x\GETS0\SEMI y\GETS0\SEMI
  (y\GETS x \PAR x \GETS y)
\end{align*}
Informally, both threads satisfy the invariant that conjoins ``A write of 1  to x  requires a prior read  of 1 from y'' and ``A write of 1  to y  requires a prior read  of 1 from x ''.  If composition holds, the full program satisfies the invariant.  Since the variable declaration closes the program from other writes to $x,y$, we  deduce the conjunction of  ``A write of 1  to x  requires a prior write  of 1 to x'' and ``A write of 1  to y  requires a prior write  of 1 from x'' . Thus, we deduce that ``A write of 1  to x  requires a prior write  of 1 to x'', and consequently ``there is no write of 1 to x''. 
Composability  of safety properties provides an  {\em objectively  falsifiable} measurement of \oota\ in a memory model. 


Now we consider the ``type unsafety'' example, from
\citep[Figure 8]{DBLP:journals/toplas/Lochbihler13}:
\begin{align*}
  %x\GETS 0 \SEMI  y\GETS 0  \SEMI  b\GETS 0 \SEMI  
  x\GETS y
  \PAR
  \aReg\GETS x \SEMI \IF{b} \THEN \bReg \GETS \NEW \texttt{C()} \ELSE \aReg \GETS \NEW \texttt{D()} \FI  \SEMI y \GETS \aReg \SEMI  
  \PAR
  b \GETS 1   
\end{align*}
Prima facie, the allocation operation can pick the same address for the two new objects, because only one of them occurs in any one execution.   This causes type safety to break for racy programs in the JMM, forcing~\citeauthor{DBLP:journals/toplas/Lochbihler13} to include the type information in the address itself.
%
Informally, all threads satisfy the invariant that conjoins ``a creation of a \texttt{C} object is preceded by a read of \texttt{b} as $1$'' and ``a creation of a \texttt{D} object is preceded by a read of \texttt{b} as $0$''.  If composition holds, the the full program satisfies the invariant.   
%
Composability of safety properties provides the temporal context needed to prevent the ``pointer forging''  within a single execution.  


None of the extant memory models validate both ``implementation flexibility'' and ``ease-of-use''.  

Models that validate ``ease-of-use'' include Sequential Consistency (SC)~\citet{Lamport:1979:MMC:1311099.1311750}, \citet{Dolan:2018:BDR:3192366.3192421}, \citet{DBLP:conf/pldi/LahavVKHD17}, \citet{DBLP:conf/lics/JeffreyR16}, RC11 model\cite{DBLP:conf/pldi/LahavVKHD17} and~\citet{BoehmOOTA}.  However, {\em all} of them invalidate reordering of independent statements.  \cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA,DBLP:conf/lics/JeffreyR16} forbid breaking of the program order from reads to writes and thus require extra fences after read actions in hardware implementations.  \citet{Boehm:2014:OGA:2618128.2618134} show that the RC11 model\cite{DBLP:conf/pldi/LahavVKHD17} forces a dependency or a fence between between a relaxed atomic
read and a subsequent relaxed atomic write.  


As quoted at the beginning of this section, the JMM was designed with these two aims.  However, the JMM and the related models of~\citet{DBLP:conf/esop/JagadeesanPR10} and \citet{DBLP:conf/popl/KangHLVD17} invalidate compositional reasoning.  In \textsection\ref{sec:logic} we formalize a variant of \citeauthor{DBLP:journals/toplas/Lochbihler13}'s type unsafety example which demonstrates this.  
%It is also known that the JMM does not support reordering of independent statements.

Recently, multi-copy atomicity (\mca) has been proposed as a sensible
restriction on processor architecture that improves understandability without
compromising performance. Under \mca, it is not possible for a write to
become ``visible to some other threads before becoming visible to all''
\citep{DBLP:journals/pacmpl/PulteFDFSS18}.  \tso\ and recent architectures,
such as \armeight, are \mca, but not older architectures, such as \ppc\ or
\armseven.

In order to capture security flaws, such as Spectre
\cite{DBLP:journals/corr/abs-1801-01203}, \citet{2019-sp} model
microarchitecture using two well-understood relations over events that have
been in the literature since the 1980s.

\paragraph{Our results. }
In this paper, we show that (with small adjustments) the model of
\citep{2019-sp} provides a natural, abstract view of \mca\ architectures,
without the necessity of additional relations, thread ids, and similar
machinery that complicates many relaxed memory models.


% \paragraph{Our results. } We describe a software relaxed memory model based on pomsets whose events are decorated by logical  preconditions.   Our model satisfies the desiderata outlined earlier.

\begin{itemize}
\item The model satisfies the ``DRF criterion''  (\textsection\ref{sec:sc}).

\item The model compiles to \armeight\ and \tso\ {\em without} extra synchronization for raw variables  (\textsection\ref{sec:arm}).
However, a semantic version of \mca\ in our model means that a compilation to \armseven\ or \ppc\ requires extra synchronization.  

\item The model validates a variety of single threaded transformations including reordering of independent statements and roach motel laws for synchronization  (\textsection\ref{sec:opt}).
%
We provide two forms of abstract evidence that our model supports as many sequential transformations as can be expected.  First, we show a precise relationship with standard Hoare-triples for sequential code provides abstract evidence for the support afforded for compiler  transformations of traditional sequential code.  Second, we prove a ``full abstraction'' style completeness  theorem: any two synchronization free threads that are distinguished by our model can be done so with a parallel thread that is also synchronization free. 

\item The model validates compositional reasoning on safety properties (\textsection\ref{sec:logic}).  Thus, it supports the infrastructure required to prove a realistic type safety theorem that includes racy programs without requiring that that the type information is included in the address itself.
\end{itemize}
In addition, the presentation of our model provides a simple way to adapt it to forbid the relaxing of the program order from reads to writes, thus modeling\cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA}.  Perforce, this variant limits the compiler transformations, and it is already know that it satisfies the properties of ``DRF'' and hardware compilation.   To the reader interested in models that forbid load buffering, we gently suggest reading our paper as providing an appraoch to validate data-sensitive compiler optimizations and compositional reasoning of temporal properties.   


%\paragraph*{Rest of the paper. }  We begin with an informal introduction to the modeling ideas in \textsection\ref{sec:model:intro}, developing the precise formalities in \textsection\ref{sec:model}.   \textsection\ref{sec:sc} proves the DRF theorem, whereas \textsection\ref{sec:arm} provides a compilation into \armeight\ and \tso.  Single threaded optimizations, and the associated completeness theorems are addressed in \textsection\ref{sec:opt}.  \textsection\ref{sec:logic} describes a temporal logic, and a compositional proof principle for proving safety properties.  \textsection\ref{sec:examples}.develops more illustrative examples.  We address related work in \textsection\ref{sec:ldrf} and conclude after.  An appendix contains details of proofs and further examples.

We give an informal introduction to the model in \textsection\ref{sec:model:intro} before presenting the precise formalities in \textsection\ref{sec:model}.
% \textsection\ref{sec:sc} proves the DRF theorem, whereas \textsection\ref{sec:arm} provides a compilation into \armeight\ and \tso.  Single threaded optimizations, and the associated completeness theorems are addressed in \textsection\ref{sec:opt}.  \textsection\ref{sec:logic} describes a temporal logic, and a compositional proof principle for proving safety properties.
We present additional examples in \textsection\ref{sec:examples} and end with
a discussion of related work in \textsection\ref{sec:ldrf}.
% An appendix
% contains details of proofs and further examples.



