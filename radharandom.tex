\section{RadhaRandomness}

\newcommand{\acylic}{\mathit{acyclic}}

\tikzstyle{varsc} = [->]
\newcommand{\fvarsc}{\mathit{varsc}}
\newcommand{\rvarsc}{\ensuremath{\mathrel{\mathsf{varsc}}}}%
\newcommand{\xvarsc}{\xarrowtikz{varsc}{varsc}}

\newcommand{\reads}{\mathit{Reads}}
\newcommand{\Seq}{{\tt Sequential}}

\newcommand{\writes}{\mathit{Writes}}
\newcommand{\pomf}[1]{Fun_{#1}}
\newcommand{\pomFn}{\mathit{PomFn}}
\newcommand{\power}{\mathcal{P}}
\newcommand{\aFn}{F}
\newcommand{\aRSet}{R}
\newcommand{\bRSet}{S}
\newcommand{\aWSet}{U}
\newcommand{\bWSet}{V}
\newcommand{\aWrite}{\aAct_w}
\newcommand{\bPS}{\aPS'}


For any $\aPS$, then $\closed(\aPS)$ is set enriched with useless reads
(preserving augmentation closure) and where we remove any event whose
precondition is not a tautology.

For top level programs:
\begin{displaymath}
  \semClosed{\VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)}
  =
  \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\semClosed{\aCmd^1} \PAR \cdots \PAR \semClosed{\aCmd^n})
\end{displaymath}

\begin{definition}
A thread: top level component of a parallel composition
\end{definition}

\begin{definition}
$\aPS$ is a generator of a set of pomsets $\aPSS$ if for all $\bPS \in \aPSS$ such that $\aPS$ augments $\bPS$, $\aPS$ is isomorphic to $\bPS$.
\end{definition}

\section{The semantics  of threads, explained}
We are considering finite programs without loops.  So,  all pomsets in the semantics of threads are finite.  Thus, there are no infinite descending chains of augmentations, and  generators exist for semantics of threads.

\begin{lemma}
Let $\aCmd$ be a thread.  Then, all generators $\aPS$ of  $\semClosed{\aCmd}$  are such that:
\begin{itemize}
\item  If $\aEv\lt\bEv$ and $\aEv$ is a write, then $\bEv$ is a release action.
\item  If $\aEv\lt\bEv$ and $\bEv$ is a read, then $\aEv$ is an acquire action.
\item  If both $\aEv$ and $\bEv$ touch the same variable and at least one of them is a write, then $\bEv \gtN \aEv$ or $\bEv \gtN \aEv$.
\item $\aEv \gtN \bEv$ if $ \bEv (\lt \cup \rvarsc)^* \aEv$, where
            $ \aEv \xvarsc  \bEv$ if both $\aEv$ and $\bEv$ touch the same variable and $\bEv \gtN \aEv$.
\end{itemize}
\end{lemma}
\begin{proof}
Formally, the proof proceeds by structural induction on the semantics of commands, by considering the minimal requirements on the order relations imposed by the semantics.


The key case is prefixing.  

The only required $\lt$-edges out of writes are into release actions, and the only required $\lt$-edges into reads arise from read actions. The only required $\gtN$ relationships arise from actions touch the same variable and one of them is a write.   
\end{proof}

In particular, if there are no release or acquire actions in $\aCmd$, then, the first two conditions simplify to:
\begin{itemize}
\item Writes are maximal
\item Reads are minimal
\end{itemize}
thus providing a particularly simple view of the semantics of threads without synchronization primitives.   

\begin{definition}
$\reads$ is the finite powerset of read actions, ordered by subset.  

A write multiset is a pair $(\aWSet,\gtN)$ where $\gtN$ is union of total orders, one for each variable. $\writes$ is the space of write multisets ordered as:
$(\aWSet,\gtN) \preceq (\aWSet',\gtN')$ iff $\aWSet \subseteq\aWSet'$ and $\gtN \subseteq \gtN'$.
\end{definition}

$\reads$ is a lattice, with least upper bounds ($\sqcup$) (resp. greatest lower bound, $\sqcap$)  induced by union (resp. intersection).  Similarly for $\writes$. 

\begin{definition}[Pomset Functions]
Let $\pomFn: \reads \rightarrow \writes$ be the space of finitary monotone and stable functions, ie, $\aFn \in \pomFn$ satisfies:
\begin{itemize}
\item $\aRSet \subseteq \bRSet \Longrightarrow\ \aFn(\aRSet) \subseteq \aFn(\bRSet)$
\item There exists $\aRSet_{\aFn}$ such that $\forall \aRSet$, $\aFn(\aRSet) \preceq \aFn(\aRSet_{\aFn})$
\item $\aFn(\aRSet \sqcap \bRSet) =  \aFn(\aRSet) \sqcap \aFn(\bRSet)$
\end{itemize}
\end{definition}
Thus, for each write  $\aWrite$ in $\aFn(\aRSet)$ we have a minimum cause $\min(\aWrite) \subseteq \aRSet$ that captures the reads that need to be satisfied to cause it.   

Let $\aCmd$ be a synchronization free thread.  Then, 
With every generator $\aPS$ of  $\sem{\aCmd}$, we associate $\pomf{\aPS}$ as follows:
\[ \pomf{\aPS}(\aRSet) = \langle \aWSet = \{ \bAct \mid \aAct \in \aRSet, \aAct \lt \bAct \}, \gtN_{\aPS} \restrict \aWSet \rangle \]
Multiplicativity  of $\pomf{\aPS}$ is ensured because every write in $\aPS$ has a unique cause, namely the reads that precede it in $\lt$.

Similarly, given $\aFn \in \pomFn$, we can generate $\aPS$ as follows:
\begin{itemize}
\item There is a unique event of $\aPS$ for each element in $\aRSet_{\aFn}$ and $\aFn(\aRSet_{\aFn})$.  In the rest of this discussion, we conflate the event with its label.
\item For each event $\bEv$ from $\aFn(\aRSet_{\aFn})$, $\aEv \lt \bEv$ for all $\aEv \in \min(\bEv)$
\item $\aEv \gtN \bEv$ if $ \bEv (\lt \cup \pi_2(\aFn(\aRSet_{\aFn}))^* \aEv$.
\end{itemize}

Examples??.  
a) x= 1
x=2

b  r =x
   if r =1  {y=1}
   else      {y =2}

\section{Generators for semantics of programs with parallel composition}
\begin{lemma}\label{pargen}
Consider the subset of pomsets of $\sem{\aCmd \PAR \bCmd}$ that are  $\aLoc$-closed for all $\aLoc$.  
All generators $\aPS$   are such that the following hold.

If $\aEv\lt\bEv$ and $\aEv \in \sem{\aCmd}$ and  $\bEv \in \sem{\bCmd}$, then at least one of the following holds:
\begin{itemize}
\item  $\aEv$ is a write, $\bEv$ is a read, and $\bEv$ reads-from $\aEv$.
\item There exists a release action $\aEv'$ in $\sem{\aCmd}$, a matching acquire action $\bEv'$ in $\sem{\bCmd}$ such that $\aEv \lt \aEv'$, $\bEv' \lt \bEv$ and $\aEv' \lt \bEv'$.
\end{itemize}

$\aEv \gtN \bEv$ if $ \bEv (\lt \cup \rvarsc)^* \aEv$, where
            $ \aEv \xvarsc  \bEv$ if both $\aEv$ and $\bEv$ touch the same variable and $\bEv \gtN \aEv$.

\end{lemma}

\section{DRF Proof}

\begin{definition}
$ \aEv \xvarsc  \bEv$ if both $\aEv$ and $\bEv$ touch the same variable and $\aEv \xird \bEv$ or $\aEv \xrb \bEv$ or $\aEv\xird \bEv$ or $\bEv \gtN \aEv$.
\end{definition}

\begin{definition}
$\aPS$ is \Seq\ if  $\acylic(\rpox \cup \lt \cup \xvarsc)$
\end{definition}
We argue that \Seq\ is an accurate measure of sequential consistency.  

\begin{definition}
$\aPS \in \sem{\aCmd}$ demonstrates a race if $\aPS$ is \Seq\ and  there is a race in $\aPS$.
\end{definition}

              

\begin{theorem}[DRF1]
Let $\aPS \in \sem{\aCmd}$ be a generator.  
If $\aPS$ does not have a race, $\aPS$ is \Seq.
\end{theorem}
\begin{proof}
We first show that if $\aPS$ is not \Seq, then $\aPS$ has a race.  By assumption, there is a cycle in  $\rpox \cup \lt \cup \xvarsc$.  Let this cycle be $\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ where for all $i$, $\aEv_i \xpox \aEv'_i$ and $\aEv'_i  \not\xpox \aEv'_{i+1}$.
If for all $i$, $\aEv'_i  \xhb \aEv'_{i+1}$, then the above is a cycle in $\rhb$, which is a contradiction.
So, there is at least one $i$ such that $\aEv'_i  \not\xhb \aEv'_{i+1}$.  There are two cases to consider.
\begin{itemize}
\item $\aEv'_i  \xvarsc \aEv'_{i+1}$.   In this case, there is a race.
\item  $\aEv'_i  \lt \aEv'_{i+1}$.  In this case, using lemma~\ref{pargen}, we deduce that $\aEv'_i$ is a write and $\aEv'_{i+1}$ is a conflicting read, so there is a race. 
\end{itemize}

\end{proof}
\begin{theorem}[DRF2]
Let $\aPS \in \sem{\aCmd}$ be a generator.   If $\aPS$ has a race, then there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.
\end{theorem}
\begin{proof}
For generators $\aPS$ of $\sem{\aCmd}$, we define a size $|\aPS|$ as follows: $|\aPS|$ is the sum of the number of events in $\aPS$ and $|\rird_{\aPS}|$ (the number of tuples in the relation $\rird$).    Since we are considering loop free programs, there is a generator $\aPS \in \sem{\aCmd}$ with maximum size, which we identify as $|\aCmd|$.  

We prove by induction on $|\aCmd| - |\bPS|$ that given $(\aPS, \bPS)$ such that:
\begin{itemize}
\item $\bPS$ is \Seq\ 
\item $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$ 
\item $\aPS$ has a race
\end{itemize}
there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.

The required theorem follows by setting $\bPS$ to be the empty pomset.

For the base case, $\bPS = |\aPS|$.  In this case, $\aPS$ is the required witness.

Otherwise, consider a maximal prefix, extending $\bPS$, wrt to all of  $\xpox,\gtN,\lt$.  If it strictly contains $\bPS$, result follows from induction hypothesis.  

If not, $\bPS$ is already maximal.  Choose events in $\aPS \setminus \bPS$ that are minimal wrt the lexicographic ordering $\langle \xpox, \lt \rangle$.    Thus, there are events
$\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ such that:
\[
\begin{array}{lrl}
\aEv_i \xpox\ \aEv'_i \\
\aEv'_i \xpox\ \aEv'_{(i+1) \mod\ n}
\end{array}
\]


\end{proof}







\endinput
===================

Def: Let P be a pomset.  e an event in P
   after(e) = {f in P | f = e (OR) e s--> f }
   strictlyAfter(e) = {f in P | f = e (OR) e s--> f }

   

Closure properties:
  a. Let P in [| C |].  Let e be a read, (R x v). v' chosen as any value.   
           Then, there is a pomset Q in [| C |]
                     there is a maximal event e' = (R x v'), for any v'
                     Q agrees with P on P \ after(e)

  b. Let P in [| C |] be minimal. 
     Let e (resp. f) be writes on same var such that 
               e not(s-->) f
               e w--> f
               no other write f' (on same var) such that:
                      e w--> f' w--> f

     Then, there is a minimal pomset Q in [| C |] 
           Q only differs from P in weak order, such that 
                f w--> e 
           in Q
    Proof: Only change the weak order.
         Changes in Q:
           (i)      f w-->e in r     
          (ii)  For all reads r matched to e in P, change from;
                    r w--> f to f w--> r
         (iii) For all reads r matched to f in P, change from;           
                    e w--> r to r w--> e

                    
Def: 

Def: If P is SEQ, def Explicate(P):
For each ird edge
      W x i --> f
add a new event R x i and edges:
      R x i s--> f
      W x i s--> R x i
and any induced edges
   e s--> W x i  ==> e s--> R x i  [same for weak]
   f s--> e      ==> R x i s--> e  [same for weak]
  
Lemma:
   If P is SEQ, explicate(P) is a valid pomset
Proof:
      * No s--> cyclts (since any cyclt in explicate(P) involving new event induces a cyclt in P)
      * Visibility maintained since W x i is immediate s--> predecessor of new event

Lemma.  Let P in [| C |] is SEQ,  then explicate(P) in SEQ[| C |]

Proof: (* Structural induction *)
  

Def: Two events are in conflict if they are on same variablt and at ltast one of them is a write 

Def: A race is a pair of conflicting events unrelated by hb
 

  
Thm:
Given a minimal P.
    if P does not have a race, then P is SEQ
    if P has a race, then there exists Q in [| C |] that demonstrates a race

Lemma.Given (P,Q) where:
          a) P, Q are minimal eltments of an execution.  P has a race
          b) Q is a prefix of P under all of po, s-->, WeakPerVar
          c) Q is SEQ
    Then,Q can be extended into a SEQ Q' in [| C |] that demonstrates a race.
          
Proof:    
Count size of events for W with ird inedges as 1 + #Ird-Edges 

Indn on -|Q|



Otherwise, 

Let this subset be e0... en

Let  be the next events wrt po that are minimal wrt 

  There are e0'..en'  such that:
                ei   po  ei'
                ei'  WPV-> e[(i+1) mod k]

  If all  ei   po  ei' is such that
           ei s--> ei'
  we have a  cyclt in w--> on a SingltVar.  Contradiction.


  So, there is an ej po ej' is such that not(ej s--> ej').  Choose:

  Case (a): ej is a read.  
                  Use Closure (a) change read to read a value from previous(ej)
                  (e'(j-1), ej) race is unaffected.
                  |Q| goes up

  Case (b): ej is a write.
                 ej is hb minimal.
                 So, for all writes f on same var such that f w--> ej, we know that not (f s--> ej) 
                 Use Closure (b) to move ej after such fs.

                 So, wlog we can assume that e'(j-1) is a read.  
                 Use Closure (a) change read to read ej
                 (e'(j-1), ej) race is unaffected.
                 |Q| goes up

      