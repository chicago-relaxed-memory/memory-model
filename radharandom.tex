\section{RadhaRandomness}

\newcommand{\acylic}{\mathit{acyclic}}

\tikzstyle{eco} = [->]
\newcommand{\feco}{\mathit{eco}}
\newcommand{\reco}{\ensuremath{\mathrel{\mathsf{eco}}}}%
\newcommand{\xeco}{\xarrowtikz{eco}{eco}}

\newcommand{\reads}{\mathit{Reads}}
\newcommand{\Seq}{{\tt Sequential}}

\newcommand{\writes}{\mathit{Writes}}
\newcommand{\pomf}[1]{Fun_{#1}}
\newcommand{\pomFn}{\mathit{PomFn}}
\newcommand{\power}{\mathcal{P}}
\newcommand{\aFn}{F}
\newcommand{\aRSet}{R}
\newcommand{\bRSet}{S}
\newcommand{\aWSet}{U}
\newcommand{\bWSet}{V}
\newcommand{\aWrite}{\aAct_w}
\newcommand{\bPS}{\aPS'}
\newcommand{\cPS}{\aPS_1}
\newcommand{\dPS}{\aPS'_1}
\newcommand{\after}{\mathit{after}}
\newcommand{\size}{\mathit{size}}


For any $\aPS$, then $\closed(\aPS)$ is set enriched with useless reads
(preserving augmentation closure) and where we remove any event whose
precondition is not a tautology.

For top level programs:
\begin{displaymath}
  \semClosed{\VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)}
  =
  \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\semClosed{\aCmd^1} \PAR \cdots \PAR \semClosed{\aCmd^n})
\end{displaymath}

\begin{definition}
A thread: top level component of a parallel composition
\end{definition}

\begin{definition}
$\aPS$ is a generator of  $\semClosed{\aCmd}$ if for all $\bPS \in \semClosed{\aCmd}$ such that $\aPS$ augments $\bPS$, $\aPS = \bPS$.
\end{definition}

\begin{definition}
 $ \aEv' \xeco  \bEv'$ if both $\aEv'$ and $\bEv'$ touch the same location, $\bEv' \gtN \aEv'$, and at least one of them is a write.  
\end{definition}

\section{The semantics  of threads, explained}
We are considering finite programs without loops.  So,  all pomsets in the semantics of threads are finite.  Thus, there are no infinite descending chains of augmentations, and  generators exist for semantics of threads.

\begin{lemma}
Let $\aCmd$ be a thread.  Then, all generators $\aPS$ of  $\semClosed{\aCmd}$  are such that:
\begin{itemize}
\item  If $\aEv\lt\bEv$ and $\aEv$ is a release or a write, then $\bEv$ is a release action.
\item  If $\aEv\lt\bEv$ and $\bEv$ is an acquire or a read, then $\aEv$ is an acquire action.
\item  If both $\aEv$ and $\bEv$ touch the same location and, then $\bEv \gtN \aEv$ or $\aEv \gtN \bEv$.
\item  Let

$\aEv \gtN \bEv$ if and only if $ \bEv [\lt \cup (\le; \reco;\le)] \aEv$. 
            
\end{itemize}
\end{lemma}
\begin{proof}
The proof proceeds considering the minimal requirements on the order relations imposed by the semantics.  The key case is prefixing.  

The only required $\lt$-edges out of writes are into release actions, and the only required $\lt$-edges into reads arise from read actions. The only required $\gtN$ relationships arise from actions touch the same location and one of them is a write.   
\end{proof}

In particular, if there are no release or acquire actions in $\aCmd$:
\begin{itemize}
\item Writes are maximal
\item Reads are minimal
\end{itemize}
thus providing a particularly simple view of the semantics of threads without synchronization primitives.   

\begin{definition}
$\reads$ is the finite powerset of read actions, ordered by subset.  

A write multiset is a pair $(\aWSet,\gtN)$ where $\aWSet$ is a finite multiset of write actions and $\gtN$ is union of total orders, one for each location. 

$\writes$ is the space of write multisets ordered as:
$(\aWSet,\gtN) \preceq (\aWSet',\gtN')$ iff $\aWSet \subseteq\aWSet'$ and $\gtN \subseteq \gtN'$.
\end{definition}

$\reads$ is a lattice, with least upper bounds ($\sqcup$) (resp. greatest lower bound, $\sqcap$)  induced by union (resp. intersection).  Similarly for $\writes$. 

\begin{definition}[Pomset Functions]
Let $\pomFn: \reads \rightarrow \writes$ be the space of finitary monotone and stable functions, ie, $\aFn \in \pomFn$ satisfies:
\begin{itemize}
\item $\aRSet \subseteq \bRSet \Longrightarrow\ \aFn(\aRSet) \preceq \aFn(\bRSet)$
\item There exists $\aRSet_{\aFn}$ such that $\forall \aRSet$, $\aFn(\aRSet) \preceq \aFn(\aRSet_{\aFn})$
\item $\aFn(\aRSet \sqcap \bRSet) =  \aFn(\aRSet) \sqcap \aFn(\bRSet)$
\end{itemize}
\end{definition}
Thus, for each write  $\aWrite$ in $\aFn(\aRSet)$ we have a minimum cause $\min(\aWrite) \subseteq \aRSet$ that captures the reads that need to be satisfied to cause it.   

Let $\aCmd$ be a synchronization free thread.   With every generator $\aPS$ of  $\semClosed{\aCmd}$, we associate $\pomf{\aPS}$ as follows:
\[ \pomf{\aPS}(\aRSet) = \langle \aWSet = \{ \bAct \mid \aAct \in \aRSet, \aAct \lt \bAct \}, \gtN_{\aPS} \restrict \aWSet \rangle \]
Multiplicativity  of $\pomf{\aPS}$ is ensured because every write in $\aPS$ has a unique cause, namely the reads that precede it in $\lt$.

Similarly, given $\aFn \in \pomFn$, we can generate $\aPS$ as follows:
\begin{itemize}
\item There is a unique event of $\aPS$ for each element in $\aRSet_{\aFn}$ and $\aFn(\aRSet_{\aFn})$.  In the rest of this discussion, we conflate the event with its label.
\item For each event $\bEv$ from $\aFn(\aRSet_{\aFn})$, $\aEv \lt \bEv$ for all $\aEv \in \min(\bEv)$
\item $\aEv \gtN \bEv$ if $ \bEv\ (\lt \cup \le;\pi_2(\aFn(\aRSet_{\aFn})); \le) \  \aEv$.
\end{itemize}

Examples??.  
a) x= 1
x=2

b  r =x
   if r =1  {y=1}
   else      {y =2}

\section{Generators for semantics of programs with parallel composition}
\begin{lemma}\label{pargen}
Consider the subset of pomsets of $\semClosed{\aCmd \PAR \bCmd}$ that are  $\aLoc$-closed for all $\aLoc$.  All generators $\aPS$  satisfy:

\begin{itemize}
\item  If $\aEv\lt\bEv$ and $\aEv \in \semClosed{\aCmd} \setminus \semClosed{\bCmd}$ and  $\bEv \in \semClosed{\bCmd} \setminus \semClosed{\aCmd}$, then there are $\aEv' \in \semClosed{\aCmd}, \bEv' \in \semClosed{\bCmd}$ such that 
$\aEv \lt \aEv', \bEv' \lt \bEv$, 
$\aEv'$ is a write, $\bEv'$ is a read, and $\bEv'$ reads-from $\aEv'$.

\item $\aEv \gtN \bEv$ only if $ \bEv  [\lt \cup (\le; \reco;\le)]  \aEv$.

% \item If $\aEv\lt\bEv$ and $\aEv, \bEv \in \semClosed{\aCmd}$, 
%then there exists 

%There exists a release action $\aEv'$ in $\sem{\aCmd}$, a 
%matching acquire action $\bEv'$ in $\sem{\bCmd}$ such that $
%\aEv \lt \aEv'$, $\bEv' \lt \bEv$ and $\aEv' \lt \bEv'$.
\end{itemize}


\end{lemma}

\section{Closure properties}

\begin{definition}
Let $\aEv \in \aPS$.  Then:$ \aPS \after\ \aEv = \{ \bEv \mid \aEv \le \bEv \}$
\end{definition}

\begin{lemma}\label{inputen}
Let $\aCmd = \vec{\aLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)$.
Let $\aPS \in \semClosed{\aCmd}$.  
Let $\aEv \in \aPS$ read from $\aLoc \in \vec{\aLoc}$, such that the matching write event $\bEv$ is in a race with $\aEv$ in $\aPS$. 

 Then, there exists $\bPS \in \semClosed{\aCmd}$ such that:
\begin{itemize}
\item $(\exists \aEv' \in \Event_{\bPS})$ such that $\Event_{\bPS}$ is the disjoint union of  $\Event_{\aPS} \setminus  (\aPS\ \after\ \aEv))$ and $(\bPS\ \after\ \aEv')$.
\item $\aEv'$ reads from $\aLoc$, and the matching write event is not in a race with $\aEv'$ in $\bPS$
\item $\aPS$ and $\bPS$ agree on the restrictions of $\le$ and $\gtN$ to $\Event_{\aPS} \setminus  (\aPS\ \after\ \aEv))$.
\end{itemize}
\end{lemma}

\begin{lemma}\label{cohsat}
Let $\aPS \in \sem{\aCmd}$ be a generator.  Let $\bEv \gtN \aEv$ be writes to $\aLoc$ such that  forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$,  it is the case that  $ \neg(\aEv \lt \cEv)$ and $\neg(\aEv \xpox \cEv) ]$. 

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that:
\begin{itemize}
\item $\Event_{\aPS} = \Event_{\bPS}$
\item $\le_{\aPS} = \le_{\bPS}$
\item $\aEv \gtN \bEv$ in $\bPS$
\end{itemize}
\end{lemma}
\begin{proof}
We show how to interchange $\aEv, \bEv$ adjacent in $\gtN$, ie. we assume that  $\neg(\exists \cEv) \  \bEv \gtN \cEv \gtN \aEv$.  The full proof follows by induction.

Since  $\sem{\aCmd}$ is augmentation closed, it suffices to show that we can build $\bPS$ while satisfying the constraints between $\lt,\gtN$.  We list the changes below.
\begin{itemize}
\item $\aEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\aEv$, change from $\bEv \gtN \cEv$ in $\aPS$ to $\cEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\bEv$, change from $\cEv \gtN \aEv$ in $\aPS$ to $\aEv \gtN \cEv$ in $\bPS$
\end{itemize}

\end{proof}

        

\section{DRF Proof}

\begin{definition}
$ \aEv \xeco  \bEv$ if both $\aEv$ and $\bEv$ touch the same location, at least one is a write, and $\aEv \xird \bEv$  or $\aEv \xrb \bEv$ or $\aEv\xird \bEv$ or $\bEv \gtN \aEv$.
\end{definition}

\begin{definition}
$\aPS$ is \Seq\ if  $\acylic(\rpox \cup \lt \cup \xeco)$
\end{definition}
We argue that \Seq\ is an accurate measure of sequential consistency.  

\begin{definition}
$\aPS \in \sem{\aCmd}$ demonstrates a race if $\aPS$ is \Seq\ and  there is a race in $\aPS$.
\end{definition}

              

\begin{theorem}[DRF1]
Let $\aPS \in \sem{\aCmd}$ be a generator.  
If $\aPS$ does not have a race, $\aPS$ is \Seq.
\end{theorem}
\begin{proof}
We first show that if $\aPS$ is not \Seq, then $\aPS$ has a race.  By assumption, there is a cycle in  $\rpox \cup \lt \cup \xeco$.  Let this cycle be $\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ where for all $i$, $\aEv_i \xpox \aEv'_i$ and $\aEv'_i  \not\xpox \aEv'_{i+1}$.
If for all $i$, $\aEv'_i  \xhb \aEv'_{i+1}$, then the above is a cycle in $\rhb$, which is a contradiction.
So, there is at least one $i$ such that $\aEv'_i  \not\xhb \aEv'_{i+1}$.  There are two cases to consider.
\begin{itemize}
\item $\aEv'_i  \xeco \aEv'_{i+1}$.   In this case, there is a race.
\item  $\aEv'_i  \lt \aEv'_{i+1}$.  In this case, using lemma~\ref{pargen}, we deduce that $\aEv'_i$ is a write and $\aEv'_{i+1}$ is a conflicting read, so there is a race. 
\end{itemize}

\end{proof}
\begin{theorem}[DRF2]
Let $\aPS \in \sem{\aCmd}$ be a generator.   If $\aPS$ has a race, then there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.
\end{theorem}
\begin{proof}
For generators $\aPS$ of $\sem{\aCmd}$, we define a size $|\aPS|$ as follows: $\size(\aPS)$ is the number of events in $\aPS$.    Since we are considering loop free programs, there is a generator $\aPS \in \sem{\aCmd}$ with maximum size, which we identify as $\size(\aCmd)$.  

We prove by induction on $\size(\aCmd) - \size(\bPS)$ that given $(\aPS, \bPS)$ such that:
\begin{itemize}
\item $\bPS$ is \Seq\ 
\item $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$ 
\item $\aPS$ has a race
\end{itemize}
there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.

The required theorem follows by setting $\bPS$ to be the empty pomset.

For the base case, $\bPS = |\aPS|$.  In this case, $\aPS$ is the required witness.

Otherwise, consider a maximal prefix, extending $\bPS$, wrt to all of  $\xpox,\gtN,\lt$.  If it strictly contains $\bPS$, result follows from induction hypothesis.  

If not, $\bPS$ is already maximal.  Choose events in $\aPS \setminus \bPS$ that are minimal wrt the lexicographic ordering $\langle \xpox, \lt \rangle$.    Thus, there are events
$\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ such that:
\[
\begin{array}{lrl}
\aEv_i \xpox\ \aEv'_i \\
\aEv'_i \  (\gtN \cup \lt)  \ \aEv_{(i+1)\mod n}
\end{array}
\]

If there is a $j$ such that $\aEv_{j}$ is a write, $\aEv_{(j-1)\mod n}$ is also a write.  Since $\aEv_{j}$ is minimal in $\le$, we deduce that $\aEv_j \gtN \aEv_{(j-1)\mod n}$ and that the hypothesis of lemma~\ref{cohsat} are satisfied.  Thus, we can use lemma~\ref{cohsat} to construct $\aPS' \in \sem{C}$  such that $\aEv_{j}$ is also minimal in $\reco$.  Let $\bPS'$ be derived from $\bPS$ by adding $\aEv_j$.  Proof follows from inductive hypothesis by considering $(\aPS', \bPS')$.  

So, we are left with the case when $\aEv_i$ is a read forall $i$.  

In this case, if forall $i$, $\aEv_i \lt \aEv'_i$, then $\aEv_0 \gtN \aEv'_n \gtN \aEv_0$, which is a contradiction since by~\ref{pargen}, $\aEv_0, \aEv'_n$ are actions on the same location.  

So, there is a $j$ such that $\aEv_j \not\lt \aEv'_j$. We construct $(\cPS,\dPS)$ such that:
\begin{itemize}
\item $\dPS$ is a prefix of $\cPS$ under all of $\xpox,\gtN,\lt$ 
\item $\cPS$ has a race
\item $\size(\dPS) = \size(\bPS) + 1$
\end{itemize}
We use lemma~\ref{inputen} on the pomset $\aPS$ and read $\aEv_{j}$ to construct $\cPS$ that changes the value read in $\aEv_{j}$ to the hb read value.  $\dPS$  is derived from $\bPS$ by adding the modified read to it. We observe that:
\begin{itemize}
\item There is still a race between $\aEv'_{(j-1)\mod n}$ and the modified read $\aEv_{j}$.  

\item $\bPS$ is still a prefix of $\cPS$ under all of $\xpox,\gtN,\lt$, since $\bPS$ is still a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$. 

\item $\dPS$ is \Seq\  since $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$.
\end{itemize}

\end{proof}
\endinput





\endinput
===================

Def: Let P be a pomset.  e an event in P
   after(e) = {f in P | f = e (OR) e s--> f }
   strictlyAfter(e) = {f in P | f = e (OR) e s--> f }

   

Closure properties:
  a. 

  b. 

                    
Def: 

Def: If P is SEQ, def Explicate(P):
For each ird edge
      W x i --> f
add a new event R x i and edges:
      R x i s--> f
      W x i s--> R x i
and any induced edges
   e s--> W x i  ==> e s--> R x i  [same for weak]
   f s--> e      ==> R x i s--> e  [same for weak]
  
Lemma:
   If P is SEQ, explicate(P) is a valid pomset
Proof:
      * No s--> cyclts (since any cyclt in explicate(P) involving new event induces a cyclt in P)
      * Visibility maintained since W x i is immediate s--> predecessor of new event

Lemma.  Let P in [| C |] is SEQ,  then explicate(P) in SEQ[| C |]

Proof: (* Structural induction *)
  

Def: Two events are in conflict if they are on same variablt and at ltast one of them is a write 

Def: A race is a pair of conflicting events unrelated by hb
 

  
Thm:
Given a minimal P.
    if P does not have a race, then P is SEQ
    if P has a race, then there exists Q in [| C |] that demonstrates a race

Lemma.Given (P,Q) where:
          a) P, Q are minimal eltments of an execution.  P has a race
          b) Q is a prefix of P under all of po, s-->, WeakPerVar
          c) Q is SEQ
    Then,Q can be extended into a SEQ Q' in [| C |] that demonstrates a race.
          
Proof:    
Count size of events for W with ird inedges as 1 + #Ird-Edges 

Indn on -|Q|



Otherwise, 

Let this subset be e0... en

Let  be the next events wrt po that are minimal wrt 

  There are e0'..en'  such that:
                ei   po  ei'
                ei'  WPV-> e[(i+1) mod k]

  


  So, there is an ej po ej' is such that not(ej s--> ej').  Choose:

  Case (a): ej is a read.  
                  Use Closure (a) change read

  Case (b): ej is a write.
                 ej is hb minimal.
                 So, for all writes f on same var such that f w--> ej, we know that not (f s--> ej) 
                 Use Closure (b) to move ej after such fs.

                 So, wlog we can assume that e'(j-1) is a read.  
                 Use Closure (a) change read to read ej
                 (e'(j-1), ej) race is unaffected.
                 |Q| goes up

      