\section{RadhaRandomness}

\newcommand{\acylic}{\mathit{acyclic}}

\tikzstyle{eco} = [->]
\newcommand{\feco}{\mathit{eco}}
\newcommand{\reco}{\ensuremath{\mathrel{\mathsf{eco}}}}%
\newcommand{\xeco}{\xarrowtikz{eco}{eco}}

\newcommand{\reads}{\mathit{Reads}}
\newcommand{\Seq}{{\tt Sequential}}

\newcommand{\writes}{\mathit{Writes}}
\newcommand{\pomf}[1]{Fun_{#1}}
\newcommand{\pomFn}{\mathit{PomFn}}
\newcommand{\power}{\mathcal{P}}
\newcommand{\aFn}{F}
\newcommand{\aRSet}{R}
\newcommand{\bRSet}{S}
\newcommand{\aWSet}{U}
\newcommand{\bWSet}{V}
\newcommand{\aWrite}{\aAct_w}
\newcommand{\bPS}{\aPS'}
\newcommand{\cPS}{\aPS_1}
\newcommand{\dPS}{\aPS'_1}
\newcommand{\after}{\mathit{after}}
\newcommand{\size}{\mathit{size}}


For any $\aPS$, then $\closed(\aPS)$ is set enriched with useless reads
(preserving augmentation closure) and where we remove any event whose
precondition is not a tautology.

For top level programs:
\begin{displaymath}
  \semClosed{\VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)}
  =
  \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\semClosed{\aCmd^1} \PAR \cdots \PAR \semClosed{\aCmd^n})
\end{displaymath}

\begin{definition}
A thread: top level component of a parallel composition
\end{definition}

\begin{definition}
$\aPS$ is a generator of  $\semClosed{\aCmd}$ if for all $\bPS \in \semClosed{\aCmd}$ such that $\aPS$ augments $\bPS$, $\aPS = \bPS$.
\end{definition}

\begin{definition}
 $ \aEv' \xeco  \bEv'$ if both $\aEv'$ and $\bEv'$ touch the same location, $\bEv' \gtN \aEv'$, and at least one of them is a write.  
\end{definition}

Since the program we consider are loop free, for any command $\aCmd$, the size of the pomsets in $\aCmd$ are bounded by a constant, that we denote by $\size(\aCmd)$.  
 

\section{The semantics  of threads, explained}
We are considering finite programs without loops.  So,  all pomsets in the semantics of threads are finite.  Thus, there are no infinite descending chains of augmentations, and  generators exist for semantics of threads.

\begin{lemma}
Let $\aCmd$ be a thread.  Then, all generators $\aPS$ of  $\semClosed{\aCmd}$  are such that:
\begin{itemize}
\item  If $\aEv\lt\bEv$ and $\aEv$ is a release or a write, then $\bEv$ is a release action.
\item  If $\aEv\lt\bEv$ and $\bEv$ is an acquire or a read, then $\aEv$ is an acquire action.
%\item  If both $\aEv$ and $\bEv$ touch the same location and, 
%then $\bEv \gtN \aEv$ or $\aEv \gtN \bEv$.
% \item  $\aEv \gtN \bEv$ if and only if $ \aEv [\lt \cup (\le; \reco; 
%\le)] \bEv$. 
            
\end{itemize}
\end{lemma}
\begin{proof}
The proof proceeds considering the minimal requirements on the order relations imposed by the semantics.  The key case is prefixing.  

The only required $\lt$-edges out of writes are into release actions, and the only required $\lt$-edges into reads arise from read actions. 
% The only required $\gtN$ relationships arise from actions touch 
% the same location and one of them is a write.   
\end{proof}

In particular, if there are no release or acquire actions in $\aCmd$:
\begin{itemize}
\item Writes are maximal
\item Reads are minimal
\end{itemize}
thus providing a particularly simple view of the semantics of threads without synchronization primitives.   

\begin{definition}
$\reads$ is the finite powerset of read actions, ordered by subset.  

A write multiset is a pair $(\aWSet,\gtN)$ where $\aWSet$ is a finite multiset of write actions and $\gtN$ is union of total orders, one for each location. 

$\writes$ is the space of write multisets ordered as:
$(\aWSet,\gtN) \preceq (\aWSet',\gtN')$ iff $\aWSet \subseteq\aWSet'$ and $\gtN \subseteq \gtN'$.
\end{definition}

$\reads$ is a lattice, with least upper bounds ($\sqcup$) (resp. greatest lower bound, $\sqcap$)  induced by union (resp. intersection).  Similarly for $\writes$. 

\begin{definition}[Pomset Functions]
Let $\pomFn: \reads \rightarrow \writes$ be the space of finitary monotone and stable functions, ie, $\aFn \in \pomFn$ satisfies:
\begin{itemize}
\item $\aRSet \subseteq \bRSet \Longrightarrow\ \aFn(\aRSet) \preceq \aFn(\bRSet)$
\item There exists $\aRSet_{\aFn}$ such that $\forall \aRSet$, $\aFn(\aRSet) \preceq \aFn(\aRSet_{\aFn})$
\item $\aFn(\aRSet \sqcap \bRSet) =  \aFn(\aRSet) \sqcap \aFn(\bRSet)$
\end{itemize}
\end{definition}
Thus, for each write  $\aWrite$ in $\aFn(\aRSet)$ we have a minimum cause $\min(\aWrite) \subseteq \aRSet$ that captures the reads that need to be satisfied to cause it.   

\begin{definition}[Functions from Pomsets]
Let $\aCmd$ be a command without synchronization and parallel composition.   With every generator $\aPS$ of  $\semClosed{\aCmd}$, we associate $\pomf{\aPS}$ as follows:
\[ \pomf{\aPS}(\aRSet) = \langle \aWSet = \{ \bAct \mid \aAct \in \aRSet, \aAct \lt \bAct \}, \gtN_{\aPS} \restrict \aWSet \rangle \]
\end{definition}
Multiplicativity  of $\pomf{\aPS}$ is ensured because every write in $\aPS$ has a unique cause, namely the reads that precede it in $\lt$.

\begin{definition}[Pomsets from Functions]
Given $\aFn \in \pomFn$, we can generate $\aPS_{\aFn}$ as follows:
\begin{itemize}
\item $\Event = \aRSet_{\aFn} \cup \aFn(\aRSet_{\aFn}$.  The action label of the events are the actions themselves.  
\item For each event $\bEv$ from $\aFn(\aRSet_{\aFn})$, $\aEv \lt \bEv$ if and only if $\aEv \in \min(\bEv)$.
\item $\aEv \gtN \bEv$ if $ \aEv\ (\lt \cup \le;\pi_2(\aFn(\aRSet_{\aFn})); \le) \  \bEv$.
\end{itemize}
\end{definition}

Examples??.  
a) x= 1
x=2

b  r =x
   if r =1  {y=1}
   else      {y =2}

\section{Generators for semantics of programs with parallel composition}
All generators $\aPS$  satisfy the following factorization of cross-thread $\lt$.  

\begin{lemma}\label{pargen}
Consider the subset of pomsets of $\semClosed{\aCmd \PAR \bCmd}$ that are  $\aLoc$-closed for all $\aLoc$.  

Let $\aPS$  be any generator.  Let $\aEv\lt\bEv$ and $\aEv \in \semClosed{\aCmd} \setminus \semClosed{\bCmd}$ and  $\bEv \in \semClosed{\bCmd} \setminus \semClosed{\aCmd}$.  

The,  then there is a write  $\aEv' \in \semClosed{\aCmd}$, and  a read $\bEv' \in \semClosed{\bCmd}$ such that  $\bEv'$ reads-from $\aEv'$ and $\aEv \lt \aEv' \lt \bEv' \lt \bEv$. 
% \item $\aEv \gtN \bEv$ only if $ \aEv  [\lt \cup (\le; \reco;\le)]  
%\bEv$.

% \item If $\aEv\lt\bEv$ and $\aEv, \bEv \in \semClosed{\aCmd}$, 
%then there exists 

%There exists a release action $\aEv'$ in $\sem{\aCmd}$, a 
%matching acquire action $\bEv'$ in $\sem{\bCmd}$ such that $
%\aEv \lt \aEv'$, $\bEv' \lt \bEv$ and $\aEv' \lt \bEv'$.

\end{lemma}

\section{Closure properties}

\begin{definition}
Let $\aEv \in \aPS$.  Then:$ \aPS \after\ \aEv = \{ \bEv \mid \aEv \le \bEv \}$
\end{definition}

The semantics of read is ``input''-enabled, since it permits the read of any visible value.   Thus, any racy read in a program can be replaced by a read of a earlier value (wrt $\reco$), even while  the races with existing independent writes are maintained. 
\begin{lemma}\label{inputen}
Let $\aCmd = \vec{\aLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)$.
Let $\aPS \in \semClosed{\aCmd}$.  
Let $\aEv \in \aPS$ read from write event $\bEv$  on $\aLoc \in \vec{\aLoc}$.  Let $\neg(\bEv \xhb \aEv)$ in $\aPS$. 

Then, there exists $\bPS \in \semClosed{\aCmd}$ such that:
\begin{itemize}
%\item $(\exists \aEv' \in \Event_{\bPS})$ such that $
%\Event_{\bPS}$ is the disjoint union of  $\Event_{\aPS} \setminus  
%(\aPS\ \after\ \aEv))$ and $(\bPS\ \after\ \aEv')$.
\item $\aEv'$ reads from $\aLoc$, with matching write event $\bEv'$, such that $\bEv' \xeco \bEv$ in $\bPS$
\item The restriction of $\le$ (resp. $\gtN$) in $\aPS$ to $\Event_{\aPS} \setminus  (\aPS\ \after\ \aEv)$ agrees with the the restriction of $\le$ (resp. $\gtN$) in $\bPS$ to $\Event_{\bPS} \setminus  (\aPS\ \after\ \aEv)$  in  $\bPS$.  
\end{itemize}
\end{lemma}
\begin{proof}
The key observation behind the proof is that change in a  prefixing read action can only affect the events that are dependent, ie. in the $\lt$ order to the read action.  

The form of the command in the hypothesis of the proof initializes the locations in $\vec{\aLoc}$, thus  ensuring that there is always a value visible to be read. 
\end{proof}
In particular, in the above lemma, $\bEv,\bEv'$ are events of both $\aPS$ and $\bPS$, and  $\bPS$ continues to witness the race of $\aEv', \bEv$ in $\bPS$.   

In the following lemma,  invert the $\reco$ relationship between a read and a write. 
\begin{lemma}\label{removerw}
 Let $\aCmd = \vec{\aLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)$.
Let $\aPS \in \semClosed{\aCmd}$.   

Let $\bEv \in \aPS$ be a write on $\aLoc$. 
Let $\aEv_1, \ldots,\aEv_n \in \aPS$ be all the reads from $\aLoc \in \vec{\aLoc}$ such that for all $i$, $\aEv_i \xeco \bEv$ and $\neg(\aEv_i \lt \bEv)$.  

Then, there exists $\bPS \in \semClosed{\aCmd}$ such that:
\begin{itemize}
%\item $(\exists \aEv' \in \Event_{\bPS})$ such that $
%\Event_{\bPS}$ is the disjoint union of  $\Event_{\aPS} \setminus  
%(\aPS\ \after\ \aEv))$ and $(\bPS\ \after\ \aEv')$.
\item  If $\aEv'$ reads from $\aLoc$ with matching write event $\bEv'$ in $\bPS$, and $\bEv' \xeco \bEv$ in $\bPS$ then $\bEv' \in 
\Event_{\aPS} \setminus \bigcup_i (\aPS\ \after\ \aEv_i)$. 
\item The restriction of $\le$ (resp. $\gtN$) in $\aPS$ to $\Event_{\aPS} \setminus \bigcup_i (\aPS\ \after\ \aEv_i)$ agrees with the the restriction of $\le$ (resp. $\gtN$) in $\bPS$ to $\Event_{\bPS} \setminus \bigcup_i (\aPS\ \after\ \aEv_i)$.  
\end{itemize}
\end{lemma}
\begin{proof}
The proof proceeds as follows.  Similar to the above proof, replace the values read in the events $\aEv_i$ to come from a write that precedes $\bEv$ in  $\reco$.  The process is repeated if the new pomset is has any new reads that precede $\bEv$ in $\reco$.  The termination of the process is guaranteed by the finite bound on the size of pomsets in $ \sem{\aCmd}$.
\end{proof}


The $\reco$ order between writes that are not related by $\lt$ can be reversed. 
\begin{lemma}\label{cohww}
Let $\aPS \in \sem{\aCmd}$ be a generator.  Let $\bEv, \aEv$ be a writes to $\aLoc$ such that:
\begin{itemize}
\item $\bEv\gtN \aEv$  
\item forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$,  it is the case that  $ \neg(\cEv \lt \aEv)$ and $\neg(\cEv \xpox \aEv)$
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that $\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$
, and $\aEv \gtN \bEv$ in $\bPS$.
\end{lemma}
\begin{proof}
We show how to interchange $\aEv, \bEv$ adjacent in $\gtN$, ie. we assume that  $\neg(\exists \cEv) \  \bEv \gtN \cEv \gtN \aEv$.  The full proof follows by induction.

Since  $\sem{\aCmd}$ is augmentation closed, it suffices to show that we can build $\bPS$ while satisfying the constraints between $\lt,\gtN$.  We list the changes below.
\begin{itemize}
\item $\aEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\aEv$, change from $\bEv \gtN \cEv$ in $\aPS$ to $\cEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\bEv$, change from $\cEv \gtN \aEv$ in $\aPS$ to $\aEv \gtN \cEv$ in $\bPS$
\end{itemize}

\end{proof}


\section{DRF Proof}
\begin{definition}
$\aPS$ is \Seq\ if  $\acylic(\rpox \cup \lt \cup \xeco)$
\end{definition}
\Seq\ is an accurate measure of sequential consistency.  Clearly, any total order that linearizes the acyclic relation is consistent with the dependency relation $\lt$ and the program order $\rpox$.  The consistency with $\xeco$ ensures that only the last write to a location is read in such a total order.  

\begin{theorem}[DRF1]
Let $\aPS \in \sem{\aCmd}$ be a generator.  
If $\aPS$ does not have a race, $\aPS$ is \Seq.
\end{theorem}
\begin{proof}
We first show that if $\aPS$ is not \Seq, then $\aPS$ has a race.  By assumption, there is a cycle in  $\rpox \cup \lt \cup \xeco$.  Let this cycle be $\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ where for all $i$, $\aEv_i \xpox \aEv'_i$ and $\aEv'_i  \not\xpox \aEv'_{i+1}$.
If for all $i$, $\aEv'_i  \xhb \aEv'_{i+1}$, then the above is a cycle in $\rhb$, which is a contradiction.
So, there is at least one $i$ such that $\aEv'_i  \not\xhb \aEv'_{i+1}$.  There are two cases to consider.
\begin{itemize}
\item $\aEv'_i  \xeco \aEv'_{i+1}$.   In this case, there is a race.
\item  $\aEv'_i  \lt \aEv'_{i+1}$.  In this case, using lemma~\ref{pargen}, we deduce that $\aEv'_i$ is a write and $\aEv'_{i+1}$ is a conflicting read, so there is a race. 
\end{itemize}

\end{proof}
\begin{theorem}[DRF2]
Let $\aPS \in \sem{\aCmd}$ be a generator.   If $\aPS$ has a race, then there exists $\bPS\in \sem{\aCmd}$ such that $\bPS$ is \Seq\ and has a race.
\end{theorem}
\begin{proof}
For generators $\aPS$ of $\sem{\aCmd}$, we define a size $|\aPS|$ as follows: $\size(\aPS)$ is the number of events in $\aPS$.    Since we are considering loop free programs, there is a generator $\aPS \in \sem{\aCmd}$ with maximum size, which we identify as $\size(\aCmd)$.  

We prove by induction on $\size(\aCmd) - \size(\bPS)$ that given $(\aPS, \bPS)$ such that:
\begin{itemize}
\item $\bPS$ is \Seq\ 
\item $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$ 
\item $\aPS$ has a race
\end{itemize}
there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.

The required theorem follows by setting $\bPS$ to be the empty pomset.

For the base case, $\bPS = |\aPS|$.  In this case, $\aPS$ is the required witness.

Otherwise, consider a maximal \Seq\ prefix, extending $\bPS$, wrt to all of  $\rpox,\reco,\lt$.  If it strictly contains $\bPS$, result follows from induction hypothesis.  

If not, $\bPS$ is already maximal.  Consider the set of all events in $\aPS \setminus \bPS$ that are minimal wrt $\rhb$.  In particular, these events will also be minimal wrt $\rpox$.  

If one of these events, say $\aEv$  is a write, we proceed as follows.   Using lemma~\ref{pargen} and $\rhb$-minimality of $\aEv$, we deduce that $\aEv$ is $\lt$-minimal .  Using lemma~\ref{removerw}, we build $\aPS_1$ from $\aPS$ without changing $\bPS$ to ensure that there are is no read $\bEv \in \aPS_1 \setminus \bPS$ such that $\bEv \xeco \aEv$.  Using lemma~\ref{cohww}, we build $\aPS_2$ from $\aPS_1$ without changing $\bPS$ to ensure that there are is no write $\bEv \in \aPS_2 \setminus \bPS$ such that $\bEv \xeco \aEv$.  Thus, $\aEv$ is $\reco$-minimal in $\aPS_2 \setminus \bPS$.  Result follows from induction hypothesis by considering $(\aPS_2,\bPS_1)$ where $\bPS_1$ is got from $\bPS$ by adding $\aEv$.  


So, we can assume that  all events in $\aPS \setminus \bPS$, say $\aEv_0, \ldots, \aEv_n$  that are minimal wrt $\rhb$ are reads, and we have  events 
$\aEv'_0, \aEv'_1, \ldots, \aEv'_n, \aEv_0$ such that:
\[
\begin{array}{lrl}
\aEv_i \xpox\ \aEv'_i \\
\aEv'_i \  (\reco\ \cup \lt)  \ \aEv_{(i+1)\mod n}
\end{array}
\]
Let $\bEv$ be the matching write for $\aEv_{(i+1)\mod n}$. If $\bEv_i \in \bPS$bEv , then by $\reco$ prefix closure of $\bPS$, $\bEv \xeco\ \aEv'_i$ and $\aEv_{(i+1)\mod n} \reco\ \aEv'_i$, which is a contradiction to $\reco$ being a total order per location.  So, we can assume that $\aEv'_i \  \lt  \ \aEv_{(i+1)\mod n}$. 

We proceed as follows.  We use lemma~\ref{inputen} on the  pomset $\aPS$ and read $\aEv_{(i+1)\mod n}$ and write $\aEv'_i$ to construct $\cPS$ that changes the value read in $\aEv_{j}$ to a value from $\bPS$.  $\dPS$  is derived adding the modified read yielded by lemma~\ref{inputen} to $\bPS$.  Result follows by induction hypothesis since $\dPS$ is a prefix of $\cPS$ under all of $\xpox,\lt, \reco$,  $\cPS$ has a race, and $\size(\dPS) = \size(\bPS) + 1$. 


\end{proof}
\endinput

The proof of lemma~\ref{cohsat} yields the following two corollaries.
\begin{corollary}\label{cohrw}
Let $\aPS \in \sem{\aCmd}$ be a generator. Let 
\begin{itemize}
\item $\bEv'$ be a read from $\aLoc$ with matching write $\bEv$.  \item $\aEv$ be a write to $\aLoc$ such that  $\bEv' \gtN \aEv$.   \item Forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$,  it is the case that  $ \neg(\bEv' \lt \cEv)$ and $\neg(\bEv \xpox \cEv) ]$
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that $\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$, and $\aEv \gtN \bEv'$ in $\bPS$.
\end{corollary}
\begin{corollary}\label{cohwr}
Let $\aPS \in \sem{\aCmd}$ be a generator. Let 
\begin{itemize}
\item $\aEv'$  read from $\aLoc$ with matching write $\aEv$. 
\item $\bEv$ be a  write to $\aLoc$ such that  $\bEv \gtN \aEv'$.  \item Forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$ and $\cEv \not= \aEv$,  it is the case that  $ \neg(\cEv \lt \aEv')$ and $\neg(\cEv \xpox \aEv) ]$. 
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that:
$\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$, and 
$\aEv' \gtN \bEv$ in $\bPS$.  

\end{corollary}
        

===============good lemma. Not used. ==================







 

We first consider the case when there is a $j$ such that 
   $\aEv'_{(j-1)\mod n}  \gtN\ \aEv_{j}$ and $\aEv'_{(j-1)\mod n}  \not\lt  \ \aEv_{j}$.  We proceed by cases on the types of the two actions involved.
\begin{itemize}
\item Both are writes.  Since $\aEv_{j}$ is $\xpox$ and $\lt$ minimal, we deduce that forall writes $\cEv$ to $\aLoc \in \aPS \setminus \bPS$ such that  $ \aEv'_{(j-1)\mod n}  \gtN \cEv \gtN \aEv_{j} $,  it is the case that  $ \neg(\cEv \lt \aEv_j)$ and $\neg(\cEv \xpox \aEv_J) ]$.  So, the hypothesis of lemma~\ref{ww} apply.

\item $\aEv'_{(j-1)\mod n}$ is a write and $\aEv_{j}$ is a read.  Since $\aEv_{j}$ is $\lt$  minimal, the matching write $\bEv$ is in $\bPS$.  But, that leads to a contradiction to closure of $\bPS$ under $\\gtN$ because because $\aEv'_{(j-1)\mod n} \gTn \bEv$.

\item $\aEv'_{(j-1)\mod n}$ is a read and $\aEv_{j}$ is a write. Let $\bEv$ be the matching write to $\aEv'_{(j-1)\mod n}$.   Since $\aEv_{j}$ is $\xpox$ and $\lt$ minimal, we deduce that 

If there is a read event $\aEv$ in this set, .   There 


We construct $(\cPS,\dPS)$ such that:
\begin{itemize}
\item 
\end{itemize}





If there is a $j$ such that $\aEv_{j}$ is a write.  Since $\aEv_{j}$ is minimal in $\le$, we deduce that $\aEv_j \gtN \aEv_{(j-1)\mod n}$ and that the hypothesis of lemma~\ref{cohsat}  are satisfied.  Thus, we can use lemma~\ref{cohsat} to construct $\aPS' \in \sem{C}$  such that $\aEv_{j}$ is also minimal in $\reco$.  Let $\bPS'$ be derived from $\bPS$ by adding $\aEv_j$.  Proof follows from inductive hypothesis by considering $(\aPS', \bPS')$.  

So, we are left with the case when $\aEv_i$ is a read forall $i$.  

In this case, if forall $i$, $\aEv_i \lt \aEv'_i$, then $\aEv_0 \gtN \aEv'_n \gtN \aEv_0$, which is a contradiction since by~\ref{pargen}, $\aEv_0, \aEv'_n$ are actions on the same location.  

So, there is a $j$ such that $\aEv_j \not\lt \aEv'_j$.  We observe that:
\begin{itemize}
\item There is still a race between $\aEv'_{(j-1)\mod n}$ and the modified read $\aEv_{j}$.  

\item $\bPS$ is still a prefix of $\cPS$ under all of $\xpox,\gtN,\lt$, since $\bPS$ is still a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$. 

\item $\dPS$ is \Seq\  since $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$.
\end{itemize}







\endinput

\begin{definition}
$ \aEv \xeco  \bEv$ if both $\aEv$ and $\bEv$ touch the same location, at least one is a write, and $\aEv \xird \bEv$  or $\aEv \xrb \bEv$ or $\aEv\xird \bEv$ or $\bEv \gtN \aEv$.
\end{definition}


===================

Def: Let P be a pomset.  e an event in P
   after(e) = {f in P | f = e (OR) e s--> f }
   strictlyAfter(e) = {f in P | f = e (OR) e s--> f }

   

Closure properties:
  a. 

  b. 

                    
Def: 

Def: If P is SEQ, def Explicate(P):
For each ird edge
      W x i --> f
add a new event R x i and edges:
      R x i s--> f
      W x i s--> R x i
and any induced edges
   e s--> W x i  ==> e s--> R x i  [same for weak]
   f s--> e      ==> R x i s--> e  [same for weak]
  
Lemma:
   If P is SEQ, explicate(P) is a valid pomset
Proof:
      * No s--> cyclts (since any cyclt in explicate(P) involving new event induces a cyclt in P)
      * Visibility maintained since W x i is immediate s--> predecessor of new event

Lemma.  Let P in [| C |] is SEQ,  then explicate(P) in SEQ[| C |]

Proof: (* Structural induction *)
  

Def: Two events are in conflict if they are on same variablt and at ltast one of them is a write 

Def: A race is a pair of conflicting events unrelated by hb
 

  
Thm:
Given a minimal P.
    if P does not have a race, then P is SEQ
    if P has a race, then there exists Q in [| C |] that demonstrates a race

Lemma.Given (P,Q) where:
          a) P, Q are minimal eltments of an execution.  P has a race
          b) Q is a prefix of P under all of po, s-->, WeakPerVar
          c) Q is SEQ
    Then,Q can be extended into a SEQ Q' in [| C |] that demonstrates a race.
          
Proof:    
Count size of events for W with ird inedges as 1 + #Ird-Edges 

Indn on -|Q|



Otherwise, 

Let this subset be e0... en

Let  be the next events wrt po that are minimal wrt 

  There are e0'..en'  such that:
                ei   po  ei'
                ei'  WPV-> e[(i+1) mod k]

  


  So, there is an ej po ej' is such that not(ej s--> ej').  Choose:

  Case (a): ej is a read.  
                  Use Closure (a) change read

  Case (b): ej is a write.
                 ej is hb minimal.
                 So, for all writes f on same var such that f w--> ej, we know that not (f s--> ej) 
                 Use Closure (b) to move ej after such fs.

                 So, wlog we can assume that e'(j-1) is a read.  
                 Use Closure (a) change read to read ej
                 (e'(j-1), ej) race is unaffected.
                 |Q| goes up

      