\section{The Basic Model}
\label{sec:model}

The model adapts our previous work on microarchitecture \cite{2019-sp} to the
architectural level.  In this section, we define the model and use it to give
the semantics of a concurrent language.  The semantics given here is
simplified: as discussed in \textsection\ref{sec:refine}, it fails to
validate some important optimizations.  We give the full semantics in
\textsection\ref{sec:refine}.  In \textsection\ref{sec:variants}, we define
extensions that incorporate fences, read-modify-write operations, and address
computation.

\begin{comment}
https://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/

Cannot encode R/A actions with actions+fences...

A release operation prevents preceding memory operations from being delayed
past it (a;Rel =/=> Rel;a)
 
A release fence prevents preceding memory operations from being delayed past
subsequent writes (a;FR;w =/=> w;a;FR)

An acquire operation prevents subsequent memory operations from being advanced
before it (Acq;a =/=> a;Acq)

An acquire fence prevents subsequent memory operations from being advanced
before prior reads (r;FA;a =/=> FA;a;r)

https://www.modernescpp.com/index.php/fences-as-memory-barriers

StoreLoad: Full fence allows a store before to be reordered with respect to a
load after (wx;F;ry) ===> (ry;F;wx)

StoreLoad+LoadLoad: Release fence also allows (rx;FR;ry) ===> (ry;FR;rx)

StoreLoad+StoreStore: Acquire fence also allows (wx;FR;wy) ===> (wy;FR;wx)

LoadStore: No fence allows a prior load to reorder w.r.t. a subsequent store
(rx;FR;wy) =/=> (wy;FR;rx)

https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/
Good news is that a fullFence does it.

Bizarrely, it seems this is not supported in C++... You have to go to assembly.
\end{comment}

The model is based on \emph{partially ordered multisets}~\cite{{GISCHER1988199,Plotkin:1997:TSP:266557.266600}},
where events are labelled with reads and writes, and
the partial order tracks control and data dependencies, coherence, concurrent reads and writes using shared memory, and fencing.
Here, we are only using one order, which stands in stark contrast with
other models that use many different relations.

For example the semantics of \eqref{OOTA?} %  (including explicit initialization
% with zero, and explicit $\DSTOP$ to indicate termination)
contains the
expected pomset (where $\DSTOP$ indicates termination):
\begin{gather}
  \label{OOTA?}
  \begin{gathered}
  y\GETS 0 \SEMI x\GETS 0\SEMI (y\GETS x
  \PAR
  r\GETS y\SEMI \IF{r}\THEN 
  x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI)
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{left=of wx0}
  \event{rx0}{\DR{x}{0}}{right=3em of wx0}
  \event{wy0a}{\DW{y}{0}}{right=of rx0}
  \event{ry0}{\DR{y}{0}}{right=3em of wy0a}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{stop}{\DSTOP}{right=of wx1}
  \rf{wx0}{rx0}
  \rf{wy0a}{ry0}
  \wk[out=15,in=165]{rx0}{wx1}
  \wk[out=15,in=165]{wy0}{wy0a}
  \po{rx0}{wy0a}
  \sync{wx1}{stop}
  \sync[out=20,in=160]{ry0}{stop}
      \end{tikzinline}}
  \end{gathered}
  % \end{gather*}
% \begin{tikzdisplay}[node distance=2em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wy0}{\DW{y}{0}}{below=1ex of wx0}
%   \event{rx0}{\DR{x}{0}}{right=3em of wx0}
%   \event{wy0a}{\DW{y}{0}}{right=of rx0}
%   \event{ry0}{\DR{y}{0}}{right=3em of wy0a}
%   \event{wx1}{\DW{x}{1}}{right=of ry0}
%   \event{stop}{\DSTOP}{right=of wx1}
%   \rf{wx0}{rx0}
%   \rf{wy0a}{ry0}
%   \wk[out=20,in=160]{rx0}{wx1}
%   \wk[out=0,in=200]{wy0}{wy0a}
%   \po{rx0}{wy0a}
%   \sync{wx1}{stop}
%   \sync[out=30,in=150]{ry0}{stop}
% \end{tikzdisplay}
\intertext{but also the unexpected one:}
% \begin{gather}
%   \\[-1.2\baselineskip]
  \label{unexpected}
  \smash{\hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{left=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{z}{1}}{right=of wx1}
  \event{stop}{\DSTOP}{right=of wa1}
  \rf[out=-165,in=-15]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=12,in=168]{wx0}{wx1}
  \wk[out=15,in=165]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=20,in=160]{ry1}{wa1}
  \sync[out=20,in=160]{wx1}{stop}
  \sync{wa1}{stop}
\end{tikzinline}}}
\end{gather}
The interesting fact about these pomsets is that there is no control dependency between
reading $y$ and writing $x$, since the $(\DW{x}{1})$ event happens on both sides of the conditional.
% Compare this with \eqref{OOTA!}, where there is a control dependency:
% \begin{gather*}
%   y\GETS x
%   \PAR
%     r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS2 \FI
%   \\[-1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wy0}{\DW{y}{0}}{left=of wx0}
%   \event{rx0}{\DR{x}{0}}{right=3em of wx0}
%   \event{wy0a}{\DW{y}{0}}{right=of rx0}
%   \event{ry0}{\DR{y}{0}}{right=3em of wy0a}
%   \event{wx2}{\DW{x}{2}}{right=of ry0}
%   \event{stop}{\DSTOP}{right=of wx2}
%   \rf{wx0}{rx0}
%   \rf{wy0a}{ry0}
%   \wk[out=15,in=165]{rx0}{wx2}
%   \wk[out=15,in=165]{wy0}{wy0a}
%   \po{rx0}{wy0a}
%   \po{ry0}{wx2}
%   \sync{wx2}{stop}
%   \sync[out=30,in=150]{ry0}{stop}
% \end{tikzinline}}
% \end{gather*}

An attempt to replicate this execution with \eqref{OOTA!} fails,
since it introduces a cycle:
\begin{gather}
  \label{OOTA!}
  \begin{gathered}
  y\GETS 0 \SEMI x\GETS 0\SEMI (  y\GETS x
  \PAR
    r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS2 \FI)
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{left=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{z}{1}}{right=of wx1}
  \event{stop}{\DSTOP}{right=of wa1}
  \rf[out=-165,in=-15]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=12,in=168]{wx0}{wx1}
  \wk[out=15,in=165]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=20,in=160]{ry1}{wa1}
  \sync[out=20,in=160]{wx1}{stop}
  \sync{wa1}{stop}
  \po{ry1}{wx1}
\end{tikzinline}}
\end{gathered}
\end{gather}

We stress that in these diagrams, color plays no formal role.  It is purely
to help the reader see where the order comes from:
\begin{itemize}
\item $(\DR{x}{1})\xpo(\DW{y}{1})$ is a \emph{dependency} requirement,
  relating reads to writes that depend on them.

\item $(\DW{x}{1})\xrf(\DR{x}{1})$ is a \emph{reads-from} requirement,
  relating writes to reads they fulfill.% : the read of $x$
  % is fulfilled by a matching write from another thread.

\item $(\DW{x}{0})\xwk(\DW{x}{1})$ is a \emph{coherence} requirement,
  relating actions that touch the same location. % : the write of $1$
  % must follow the write of $0$, since these are to the same location.

\item $(\DWRel{z}{1})\xsync(\DSTOP)$ is a \emph{fencing} requirement,
  involving fences and synchronization actions.
  % (in this case the fence is at the end of the program, but
  % concurrency controls introduce fencing)
\end{itemize}

In addition to actions, each pomset event is labeled with a
\emph{precondition}.  Whereas read actions represent an obligation that must
be \emph{fulfilled} concurrently by a matching write (Definition
\ref{def:rf}), preconditions represent an obligation that must be
\emph{satisfied} sequentially via substitution.

To get a sense of how preconditions are satisfied, let us consider the
evolution of the precondition of $(\DW{x}{1})$ during the calculation of
\eqref{unexpected}.
% \begin{gather*}
%     y\GETS 0 \SEMI x\GETS 0\SEMI (y\GETS x
%   \PAR
%   r\GETS y\SEMI \IF{r}\THEN 
%   x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI)
%   \\
%   %\label{unexpected}
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wy0}{\DW{y}{0}}{left=of wx0}
%   \event{rx1}{\DR{x}{1}}{right=3em of wx0}
%   \event{wy1}{\DW{y}{1}}{right=of rx1}
%   \event{ry1}{\DR{y}{1}}{right=3em of wy1}
%   \event{wx1}{\DW{x}{1}}{right=of ry1}
%   \event{wa1}{\DW{z}{1}}{right=of wx1}
%   \event{stop}{\DSTOP}{right=of wa1}
%   \rf[out=-165,in=-15]{wx1}{rx1}
%   \rf{wy1}{ry1}
%   \wk[out=12,in=168]{wx0}{wx1}
%   \wk[out=15,in=165]{wy0}{wy1}
%   \po{rx1}{wy1}
%   \po[out=30,in=150]{ry1}{wa1}
%   \sync[out=30,in=150]{wx1}{stop}
%   \sync{wa1}{stop}
% \end{tikzinline}}
% \end{gather*}
First consider the else-branch of the conditional: the semantics of
``${\IF{\lnot r}\THEN x\GETS1 \FI}$'' contains $(r{=}0 \mid \DW{x}{1})$,
indicating the control dependency.  The then-branch is more complex: the
semantics of ``${\IF{r}\THEN x\GETS r \FI}$'' contains
$(r{\neq}0 \land r{=}1 \mid \DW{x}{1})$ indicating both a control and a data
dependency.  This can be simplified to $(r{=}1 \mid \DW{x}{1})$.  Combining
the two branches of the conditional, we have
$(r{=}0 \lor r{=}1 \mid \DW{x}{1})$.  Prepending $r\GETS y$ substitutes
$[y/r]$, resulting in $(y{=}0 \lor y{=}1 \mid \DW{x}{1})$.  Prepending the
initializer $y\GETS 0$ substitutes $[0/y]$, resulting in
$(0{=}0 \lor 0{=}1 \mid \DW{x}{1})$.  This is a tautology, which we write as
$(\DW{x}{1})$.   We repeat this calculation in \textsection\ref{sec:pop},
after giving the formal definitions.

The same calculation fails for $(\DW{x}{1})$ in \eqref{OOTA!}.  In this case,
the two sides of the conditional do not coalesce; combining both sides of the
conditional, we have $(r{=}1 \mid \DW{x}{1})$, rather than $(r{=}0 \lor r{=}1
\mid \DW{x}{1})$.  And thus, the dependency is enforced.

% though missing the features designed to capture
% speculative execution attacks. We will present the model in this section,
% but readers familiar with or earlier work can skip ahead.

\subsection{Data models}
\label{sec:data:models}
A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\cVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$, and $\cExp$, % and $\dExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by $\aLoc$ and
  $\bLoc$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$, and
% \item a set of \emph{thread ids} $\Thrd$, ranged over by
%   $\aThrd$ and $\bThrd$, and
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$.
\end{itemize}

Let $\aSub$ range over substitutions of the form
$[\aLoc/\aReg]$ or $[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item values, registers, and memory locations are disjoint,
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
%\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations, % or the operator $\REF{\aExp}$,
\item formulae include at least %$\TRUE$, $\FALSE$, and
  equalities %of the form
  $(\aExp=\aVal)$, % and $(\REF{\aExp}=\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution\footnote{Since formulae are closed under substitutions of the
    form $\aForm[\aLoc/\aReg]$, they must include equalities of the form
    $(\aEExp=\aVal)$ where $\aEExp$ is an \emph{extended expression} that
    includes memory locations.  By composition, formulae must also be closed
    under that substitutions of the form
    $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.}, and
\item there is a relation $\vDash$ between formulae, with the expected semantics.
\end{itemize}

For the actions of a data model, we require that
% \begin{itemize}
% \item
% there is a function $\f: \Act \fun (\Loc \times \Val)$
there are partial functions $\rreads$ and
$\rwrites: \Act \fun (\Loc \times \Val)$, and there are subsets of $\Act$:
$\Acq$, $\Rel$, $\SC$, and $\Term$.
% We derive the partial function
% $\floc: \Act \fun \Loc$ as follows: $\floc(\aAct)= \aLoc$ if
% $\rreads(\aAct) = (\aLoc,\dontcare)$ or
% $\rwrites(\aAct) = (\aLoc,\dontcare)$.
% there are partial functions $\rreads$ and
% $\rwrites: \Act \fun (\Thrd \times \Loc \times \Val)$, and there are subsets
% of $\Act$: $\Acq$, $\Rel$, $\SC$, and $\Term$.  We derive the partial
% functions $\fthrd: \Act \fun \Thrd$ and $\floc: \Act \fun \Loc$ from
% $\rreads$ and $\rwrites$.  For example, define $\floc(\aAct)= \aLoc$ if
% $\rreads(\aAct) = (\dontcare,\aLoc,\dontcare)$ or
% $\rwrites(\aAct) = (\dontcare,\aLoc,\dontcare)$.
  % such that
  % $\SC\cap\fdom(\rreads)\subseteq\Acq$,
  % $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
  % and
  % $\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.
  % , and
% \item there is a function $\finternalize: \Act \fun \Act$ that
%   satisfies the restrictions given below.
%\end{itemize}

% $\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes to}
% $\aLoc$ when $\rwrites(\aAct) = (\aLoc,\aVal)$, for some $\aVal$. % (possibly $\bot$).
%
% Actions that read or write values are \emph{external},
% actions that read or write $\bot$ are \emph{internal}.
% % Actions in
% % $\Ext=\fdom(\rreads)\cup\fdom(\rwrites)$ are \emph{external}, whereas those
% % in $\Int=\Act\setminus\Ext$ are \emph{internal}.
%
  \begin{itemize}    
  \item We say that action $\aAct$ is a \emph{read} if
    $\aAct\in\fdom(\rreads)$ and $\aAct$ is a \emph{write} if
    $\aAct\in\fdom(\rwrites)$.  When $\rreads(\aAct) = (\aLoc,\aVal)$,
    we say that $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$, and
    similarly for writes.  We say that $\aAct$ \emph{accesses} $\aLoc$ if it
    reads or writes $\aLoc$.

  \item Actions in $\Acq$, $\Rel$ and $\SC$, are \emph{synchronization} and
    \emph{fencing} actions.  We say that $\aAct$ is an \emph{acquire} if
    $\aAct\in\Acq$, $\aAct$ is a \emph{release} if $\aAct\in\Rel$, and
    $\aAct$ is \emph{SC} if $\aAct\in\SC$.  We require that every SC read is
    an acquire, and every SC write is a release.
  % Note that these are \emph{not}
  % disjoint.
% % We say that $\aAct$ is a
% % \emph{synchronization} if it is either a release or an acquire.

% $\SC\cap\fdom(\rreads)\subseteq\Acq$,
% $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
% and
    
  \item Actions in $\Term$ are \emph{termination} actions. We require that
    termination events are releasing.
  \end{itemize}

  Our example language includes actions of the form $(\DSTOP)$, which is a
  \emph{termination}, $(\DR[\amode][\aThrd]{\aLoc}{\aVal})$, which
  \emph{reads} $\aVal$ from $\aLoc$ and
  $(\DW[\amode][\aThrd]{\aLoc}{\aVal})$, which \emph{writes} $\aVal$ to
  $\aLoc$.
% The \emph{mode} $\amode$ is either \emph{relaxed} ($\modeRLX$),
% \emph{release-acquire} ($\modeRA$) or \emph{sequentially-consistent} ($\modeSC$).
The \emph{access mode} $(\amode \!\!\BNFDEF\!\! \modeRLX \!\BNFSEP\! \modeRA \!\BNFSEP\! \modeSC)$ is
either \emph{relaxed}, \emph{release-acquire}, or
\emph{sequentially-consistent}.
$\modeRA$/$\modeSC$ reads are acquires, and $\modeRA$/$\modeSC$ writes are releases.
%We elide thread identifiers when possible.
We systematically elide the $\modeRLX$-mode annotation, writing $(\DR{\aLoc}{\aVal})$
as shorthand for $(\DR[\modeRLX]{\aLoc}{\aVal})$.

We do not explicitly include C11-style \emph{plain} access.  If thin-air
executions are disallowed, plain access is the same as relaxed access for
data race free programs; data races on plain access result in undefined
behavior \cite{undefined}.
\begin{comment}
  Thin air example from referee: if (x) y := 1 || if (y) x := 1 .
\end{comment}
% We write $\modeREL$ and $\modeACQ$ as synonyms for $\modeRA$.

  % $\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.


% The actions listed above are \emph{external}.  Each external action has a
% corresponding \emph{internal} action, denoted by prefixing $\tau$.  Internal
% actions also read and write locations, just as external actions do,
% but are not used to model communication between threads,
% so we do not record their value.
% \footnote{Fences have a limited role in our
% discussion.  We inappropriately refer to them as synchronizations for
% simplicity.}.

\paragraph{Formulae} Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.  Formulae are \emph{open}, in that
occurrences of register names and memory locations are subject to
substitutions of the form $\aForm[\aLoc/\aReg]$ and $\aForm[\bExp/\aLoc]$.
% where %$\aLoc$ is a memory location, $\aReg$ is a register and
% $\bExp$ is an
% memory-location-free expression.
Actions are not subject to substitution.

We use expressions as formulae, coercing $\aExp$ to $\aExp\neq 0$.

% % We require that $\finternalize$ satisfy the following:
% % \begin{itemize}
% % \item $\finternalize(\aAct)$ reads $\bot$ from $\aLoc$ exactly when $\aAct$ reads from $\aLoc$,
% % \item $\finternalize(\aAct)$ writes $\bot$ to $\aLoc$ exactly when $\aAct$ writes to $\aLoc$,
% % %\item the codomain of $\finternalize$ includes only internal actions, %$\fcodom(\finternalize)\subseteq\Int$,
% % \item $\finternalize(\aAct)$ is an acquire exactly when $\aAct$ is an acquire, 
% % \item $\finternalize(\aAct)$ is a release exactly when $\aAct$ is a release, and
% % \item $\finternalize(\aAct)$ is SC exactly when $\aAct$ is SC. 
% % \end{itemize}

% As noted in \textsection\ref{sec:model:intro}, our example language includes
% SC read $(\DRSC{\aLoc}{\aVal})$, acquiring
% read $(\DRAcq{\aLoc}{\aVal})$, relaxed read $(\DR{\aLoc}{\aVal})$, SC write
% $(\DWSC{\aLoc}{\aVal})$, releasing
% write $(\DWRel{\aLoc}{\aVal})$, and relaxed write $(\DW{\aLoc}{\aVal})$.
% For each external action, we also define a corresponding internal action
% %which replaces the letter $\mathsf{R}$ or $\mathsf{W}$ with $\tau$.
% $(\iDRSC{\aLoc}{\aVal})$,
% $(\iDRAcq{\aLoc}{\aVal})$,
% $(\iDR{\aLoc}{\aVal})$,
% $(\iDWSC{\aLoc}{\aVal})$,
% $(\iDWRel{\aLoc}{\aVal})$, and
% $(\iDW{\aLoc}{\aVal})$.
% In pictures, we draw internal actions grayed out,
% rather than using $\bot$.  % For example, the ``read'' action is internal in:
% % \begin{tikzdisplay}[node distance=1em]
% %   \event{wx1}{\DW{x}{1}}{}
% %   \internal{rx1}{\DR{x}{1}}{below right=of rx1}
% %   \event{wy1}{\DW{y}{1}}{above right=of wy0}
% %   \po{wx1}{wy1}
% % \end{tikzdisplay}

%We also include acquire-release fences of the form $(\DF)$.

% In examples, we use fence actions of the form $(\DF{\aF})$, where the annotation
% indicates that the fence is a release ($\FR$), an acquire ($\FA$) or both ($\FF$):
% \begin{displaymath}
%   \aF\BNFDEF\FR\BNFSEP\FA\BNFSEP\FF
% \end{displaymath}

% \subsection{3-valued pomsets with preconditions}

% Fix an alphabet $\Alphabet=(\Formulae\times\Act)$.

%For the formulae of the data model,
\begin{definition}
  We say $\aForm$ is \emph{independent of $\aLoc$} if, for every
  $\aVal$, $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$; it is
  \emph{dependent} otherwise.
  % We say that $\aForm$ is \emph{dependent on $\aLoc$} otherwise.
  % We say that
  We say $\aForm$ is \emph{location independent} if it is independent of
  every location.
%
  We say
  $\aForm$ \emph{implies} $\bForm$ if $\aForm\vDash\bForm$.
  % We say that
  We say
  $\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
  % We say that
  We say
  $\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.
\end{definition}

\subsection{Semantic domain}
\label{sec:domain}
We model single {executions} as \emph{pomsets with
  preconditions}---\emph{pomsets}, for short---ranged over by $\aPS$.  These
extend the well-known model of partially ordered
multisets~\cite{GISCHER1988199} with formulae and a termination event.

The pomset order relation, $\le$, represents \emph{causality}.  We visualize
pomsets as directed graphs.  For example, the semantics of
\begin{math}
  \VAR\aLoc\SEMI(
  x\GETS 0
  \SEMI
  x\GETS 1
  \PAR
  y\GETS x
  \SEMI
  z^\modeRA\GETS 1
  )
  %\aReg\GETS x\SEMI y\GETS \aReg)
\end{math}
includes:
\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{wz1}{\DWRel{z}{1}}{right=of wy1}
  \event{stop}{\DSTOP}{right=of wz1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \po{rx1}{wy1}
  \sync{wy1}{wz1}
  \sync{wz1}{stop}
\end{tikzdisplay}
We visualize order using arrows that indicate the reason that the order
arises.
$(\DW{x}{0})\xwk(\DW{x}{1})$ is a \emph{coherence} requirement: the write of $1$
must follow the write of $0$, since these are in \emph{conflict} and in program order.
$(\DW{x}{1})\xrf(\DR{x}{1})$ is a \emph{reads-from} requirement: the read of $x$
must be \emph{fulfilled} by a matching write.
$(\DR{x}{1})\xpo(\DW{y}{1})$ is a \emph{dependency} requirement: the write to $y$
\emph{depends on} the read of $x$.
$(\DW{y}{1})\xsync(\DWRel{z}{1})$ and $(\DWRel{z}{1})\xsync(\DSTOP)$ are
\emph{fencing/synchronization} requirements.

% Although we use multiple arrows, we emphasize that they are all part
% of the same $\le$ relation.

A pomset is \emph{completed} if it contains a unique termination action,
ordered after all other events.  We henceforth elide the
termination event in drawings, unless it is relevant to the discussion.



% \todo{Preconditions are introduced by write actions and
%   conditionals.  They are satisfied by substitutions generated by lets and read and write actions.}
% The \emph{preconditions} associated with events provide a \emph{sequential
%   requirement} for the event to execute.  For example, the following commands
% gives rise to the pomset below them.
% \begin{align}
%   \label{ex-1}
%   \begin{gathered}
%     y\GETS r
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{r=1\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     \IF{r<0}\THEN y\GETS1 \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{r<0\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align}
% The pomsets on the left says that $y\GETS r$ can produce the action
% $\DW{y}{1}$ if $r=1$, capturing the \emph{data dependency} between register
% $r$ and location $y$.  The pomsets on the right says that
% $\IF{r<0}\THEN y\GETS1 \FI$ can produce the action $\DW{y}{1}$ if $r<0$,
% capturing the \emph{control dependency} between $r$ and $y$.

% Pomsets are subject to two \emph{top-level} restrictions: Every read must be
% \emph{fulfilled}, and every precondition must be \emph{satisfied}.  Reads are
% fulfilled by writes, which may be concurrent (Definition \ref{def:rf}).
% Preconditions can only be satisfied by substitutions, which can only derive
% from prefixing in the same thread (Definition \ref{def:prefix}).  Thus reads
% give rise to \emph{inter-thread} dependencies, whereas preconditions give
% rise to \emph{intra-thread} dependencies.  

% There is a mapping between Hoare triples $\hoare{\aForm}{\aCmd}{\bForm}$ and
% the pomsets of $\aCmd$.  The postcondition $\bForm$ represents a set of write
% actions, and $\aForm$ represents their preconditions.
% % Each write in a pomset corresponds to a Hoare triple, where the formulae
% % gives the precondition, and the write action gives the postcondition.  
% For example, interpreting the pomset on the left this way yields the valid
% Hoare triple $\hoare{\aReg =1}{y\GETS \aReg}{y=1}$.

Each pomset represents a single execution.  Thus we require that all
preconditions are \emph{consistent}.  For example, the semantics of
$\IF{r<0}\THEN y\GETS1 \ELSE z\GETS1\FI$ includes pomsets with either
$(r<0\mid\DW{y}{1})$ or $(r\geq0\mid\DW{z}{1})$, but not with both, since
$(r<0\land r\geq0)$ is unsatisfiable.

Preconditions are linked to pomset order via \emph{causal strengthening},
which requires that formulae do not weaken over time, as measured by $\le$.
We give an example that requires causal strengthening on page \pageref{page:strengthening}.
% The precondition on $\DW{x}{1}$ is required by the data dependency induced by
% $\bReg$ (see page \pageref{page:strengthening}).
% For example, the semantics of $\bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg$ includes:
% \begin{displaymath}
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{a2}{\aReg{=}2\mid\DR{\REF{2}}{1}}{}
%   \event{a3}{\aReg{=}2\mid\DW{x}{1}}{right=of a2}
%   \po{a2}{a3}
%     \end{tikzinline}}
% \end{displaymath}
% The precondition on $\DW{x}{1}$ is required by the data dependency induced by
% $\bReg$ (see page \pageref{page:strengthening}).
Note that, by causal strengthening, the precondition of the termination event
of a completed pomset must imply the preconditions of all other events.

\begin{definition}
  \label{def:mmpomset}
  A \emph{pomset with preconditions} is a tuple
  $(\Event, {\le}, %{\leloc},
  \labeling)$: %, such that
  \begin{itemize}
  \item $\Event$ is a set of \emph{events},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, 
  % \item ${\le} \subseteq (\Event\times\Event)$ and ${\leloc} \subseteq (\Event\times\Event)$ are partial orders, 
  \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
    from which we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$,
    % define $\labelingForm(\aEv)=\aForm$ and $\labelingAct(\aEv)=\aAct$ when
    % $\labelingForm(\aEv)=(\aForm\mid\aAct)$,
  % \item ${\gtN} \subseteq (\Event\times\Event)$ is a partial order,
  % \item ${\le} \subseteq {\gtN}$ is a partial order, and
  \item $\bigwedge_{\aEv}\labelingForm(\aEv)$ is satisfiable
    \emph{(consistency)}, and
  \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
    $\labelingForm(\bEv)$ \emph{(causal strengthening)}, and
  % \item if $\floc(\labelingAct(\bEv))=\floc(\labelingAct(\aEv))$ and
  %   $\bEv\le\aEv$ then $\bEv\leloc\aEv$ \emph{(observation)}.
  \end{itemize}
  % A pomset is \emph{completed} if $\exists\aEv.\;\labelingAct(\aEv)=\DSTOP$. % and $\forall\bEv.\;\bEv\le\aEv$.
\end{definition}
% From $\labeling$, we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$.


We write pairs in $(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$, eliding
$\aForm$ when it is a tautology.
%
We write $\bEv\lt\aEv$ when $\bEv\le\aEv$ and $\bEv\neq\aEv$.
%We write $\bEv\ltloc\aEv$ when $\bEv\leloc\aEv$ and $\bEv\neq\aEv$.
%
We often elide explicit universal quantifiers in phrases such as ``\emph{for
  all $\aEv$}, $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.''  We
lift terminology and notation from actions and formulae to events.  For
example, we may say that $\aEv$ is a read when $\labelingAct(\aEv)$ is a
read.






% The semantics of programs is given as sets of pomsets, with each pomset
% representing a completed execution.
% %
% We expect sets of pomsets given by the semantics to be closed with
% respect to \emph{augmentation}, \emph{implication} and \emph{isomorphism}:
The notion of \emph{downset} for pomsets is similar to the notion of
\emph{prefix} for strings:
\begin{definition}
  \label{def:downset}
  $\aPS'$ is a \emph{downset} of $\aPS$ if
  $\Event \supseteq \Event' \supseteq \{ \bEv \in \Event \mid
  \exists\aEv\in\Event'.\; \bEv\le\aEv\}$, ${\le'}={\le}\restrict{\Event'}$,
  and ${\labeling'}={\labeling}\restrict{\Event'}$.
\end{definition}
We say that $\aPSS$ is \emph{downset-closed} if $\aPS\in\aPSS$ and $\aPS'$ is
a downset of $\aPS$ implies $\aPS'\in\aPSS$.


% (We identify
% pomsets up to isomorphism on the event set.)

The semantics of programs is given as sets of completed pomsets that are
closed with respect to order \emph{augmentation}, which may add order, and
\emph{implication}, which may have stronger formulae.  In examples, we draw
pomsets that are \emph{augmentation\hyp{}minimal} and
\emph{implication\hyp{}minimal}.
\begin{definition}
  We say that
  $\aPS'$ is an \emph{augment} of $\aPS$ if $\Event'=\Event$,
  ${\labeling'}={\labeling}$, and ${\le'}\supseteq{\le}$. 
  
  We say that
  $\aPS'$ \emph{implies} $\aPS$ if $\Event'=\Event$, ${\le'}={\le}$,
  $\labelingAct'=\labelingAct$, and $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$. 
\end{definition}
 
% Each pomset $\aPS\in\sem{\aCmd}$ is a \emph{completed} execution of $\aCmd$;
% we sometimes refer to pomsets as \emph{executions}.  Because they are
% completed executions, we do not expect $\sem{\aCmd}$ to be downset closed.
% However, implication closure in a memory-model pomset does give something
% similar: any event $\aEv$ can be given an unsatisfiable precondition, which
% means that every event ordered after $\aEv$ must also be unsatisfiable, as
% per Definition~\ref{def:mmpomset}.  In many applications of the model,
% unsatisfiable events are ignored, thus providing a kind of downset closure.
% % \begin{definition}
% %   $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$, ${\labeling'}={\labeling}$,
% %   ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
% %   and ${\gtN}\subseteq{\gtN'}$. %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$,
% %   % $\labelingAct'=\labelingAct$, and  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.
% %   % if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies $\bForm$.
% % \end{definition}

\subsection{Example Language}
\begin{comment}
\footnote{We only consider executions where register state is empty in
  forked threads.  Given item~\ref{pre-acquire} of
  Candidate~\ref{def:prefix}, a sufficient condition is that parallel
  composition is always preceded by an acquire fence, as in programs of the
  form:
  \begin{displaymath}
    \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
  \end{displaymath}
  where $\aCmd^1$, \ldots, $\aCmd^n$ do not include $\PAR$.  To avoid clutter
  in drawings, we often drop the explicit fence.}.
\end{comment}
% \begin{align*}
% \aCmd,\,\bCmd
% \BNFDEF& \SKIP \tag{No Operation}
% \\[-1ex]\BNFSEP& \FENCE\SEMI \aCmd \tag{Full fence}
% \\[-1ex]\BNFSEP& \REF{\cExp}\GETS\aExp\SEMI \aCmd \tag{Relaxed write to memory}
% \\[-1ex]\BNFSEP& \REF{\cExp}\REL\GETS\aExp\SEMI \aCmd \tag{Releasing write to memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\SEMI \aCmd \tag{Relaxed read from memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\ACQ\SEMI \aCmd
% \\[-1ex]\BNFSEP& \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
% \\[-1ex]\BNFSEP& \aCmd \PAR \bCmd
% \\[-1ex]\BNFSEP& \VAR\aLoc\SEMI \aCmd
% \end{align*}
%The syntax of statements is as follows.


We define the language by prefixing individual reads and writes.  % In
% \textsection\ref{sec:semicolon} we provide an equivalent semantics that supports
% full sequential composition of the form $(\aCmd\SEMI\bCmd)$.
\begin{align*}
  % \amode \BNFDEF& \modeRLX \BNFSEP \modeRA \BNFSEP \modeSC
  % \\
\aCmd,\,\bCmd
\BNFDEF& \SKIP
\BNFSEP \aReg\GETS\aExp\SEMI \aCmd
\BNFSEP \aReg\GETS\aLoc^{\amode}\SEMI \aCmd 
\BNFSEP \aLoc^{\amode}\GETS\aExp\SEMI \aCmd
\\[-.5ex]
\BNFSEP&\aCmd \PAR[\aThrd][\bThrd] \bCmd
\BNFSEP \VAR\aLoc\SEMI \aCmd
\BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\end{align*}




We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.

We write
$\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$ and
$\IF{\aExp} \THEN \aCmd^1 \ELSE \aCmd^2 \FI \SEMI \bCmd$ as shorthand for
$\IF{\aExp} \THEN \aCmd^1 \SEMI \bCmd\ELSE \aCmd^2 \SEMI \bCmd\FI$.
% and
% $\VAR\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for
% $\VAR\aLoc\SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\REL\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\FENCE_{\FR} \SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\ACQ\aReg\GETS\aLoc\SEMI \aCmd$ as shorthand for $\aReg\GETS\aLoc\SEMI \FENCE_{\FA}\SEMI \aCmd$.

The semantic function $\sem[\aThrd]{-}$ takes a command and
yields a set of pomsets, ranged over by $\aPSS$.

% Unless it is important to the context, we elide the thread identifier,
% writing simply $\sem{\aCmd}$.

%\subsection{Semantics of the Example Language}
% In the remainder of \textsection\ref{sec:model}, we explain the semantics of our example
% language.

% By far the most complex operators are the prefixing
% operators---read and write---which introduce new actions.  We build the
% definition of prefixing from first principles, starting in
% \textsection\ref{sec:pop}.  The final definition of prefixing appears in
% \textsection\ref{sec:rwe}.

% Of the other operators, it will not be surprising to students of concurrency
% theory that the most interesting are local declarations ($\VAR\aLoc\SEMI\aCmd$)
% and parallel composition ($\aCmd \PAR \bCmd$).

\subsection{Fulfillment, Local Declarations, and Top-Level Pomsets}
At the point that $\aLoc$ is bound, we can require that every read of $\aLoc$
be \emph{fulfilled}.  Fulfillment plays the role that \emph{reads-from} and
\emph{coherence} play in other relaxed memory models, yet it is not the same.

\begin{definition}
   \label{def:rf}
 Two actions \emph{conflict} if one writes a location and the other
either reads or writes the same location.
We say $\bEv$ \emph{fulfills $\aEv$ (on $\aLoc$)} if 
% \begin{itemize}    
% \item
\labeltextsc[F1]{(F1)}{rf1} $\bEv$ \externally writes $\aVal$ to $\aLoc$, 
% \item
\labeltextsc[F2]{(F2)}{rf2} $\aEv$ \externally reads $\aVal$ from $\aLoc$,
% \item
\labeltextsc[F3]{(F3)}{rf3} $\bEv \lt \aEv$, and
% \item
\labeltextsc[F4]{(F4)}{rf4} for every conflicting write $\cEv$, either $\cEv
\gtN \bEv$ or $\aEv \gtN \cEv$. %, or $\fthrd(\aEv)=\fthrd(\cEv)$ and $\aEv \leloc \cEv$.
% \end{itemize}
\end{definition}
% Throughout this section, we will ignore the last disjunct in \ref{rf4}; we
% discuss it in \textsection\ref{

Item \ref{rf3} requires that a write $\bEv$ is ordered before any read $\aEv$
it fulfills; this order is typically called \emph{reads from}.  Item
\ref{rf4} requires that any conflicting write $\cEv$ is ordered before $\bEv$
or after $\aEv$; this order is typically called \emph{extended coherence}.
For readability, we draw the order required by \ref{rf3} using bold green
arrows and the order required by \ref{rf4} using dashed red arrows.
% The causal order required by \ref{rf4} is part
% of, and we draw it with dashed red
% arrows.  % In our model, these are not separate orders.  We include the
% % \emph{reason} for the order only to improve readability. 
As an example, consider:
\begin{gather*}
  \taglabel{Co1}
  x\GETS 1
  \PAR
  x\GETS2
  \PAR
  x\GETS 3
  \PAR
  x\GETS 4
  \PAR
  x\GETS 5
  \PAR
  r\GETS x\SEMI r\GETS x \SEMI r\GETS x \SEMI r\GETS x \SEMI r\GETS x
  \\
  \hbox{\begin{tikzinline}[node distance=.7em and 2em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1a}{\DR{x}{1}}{above right=of wx1}
  \event{rx1b}{\DR{x}{1}}{above=of rx1a}
  \event{wx2}{\DW{x}{2}}{below right=of rx1a}
  \event{rx2a}{\DR{x}{2}}{above right=of wx2}
  \event{rx2b}{\DR{x}{2}}{above=of rx2a}
  \event{wx3}{\DW{x}{3}}{above right=of rx2a}            
  \event{wx4}{\DW{x}{4}}{right=of rx2a}
  \event{wx5}{\DW{x}{5}}{below right=of wx4}
  \event{rx5}{\DR{x}{5}}{above right=of wx5}
  \rf{wx1}{rx1a}
  \rf{wx1}{rx1b}
  \rf{wx2}{rx2a}
  \rf{wx2}{rx2b}
  \wk{rx1a}{wx2}
  \wk{rx1b}{wx2}
  \wk{rx2a}{wx3}
  \wk{rx2a}{wx4}
  \wk{rx2b}{wx3}
  \wk{rx2b}{wx4}
  \wk{wx3}{wx5}
  \wk{wx4}{wx5}
  \rf{wx5}{rx5}
    \end{tikzinline}}
\end{gather*}
A write is \emph{relevant} if it is read from.  In order to fulfill all of
the reads on $x$ in the example, we pick a total order on the relevant
writes: in this case, $(\DW{x}{1})\le (\DW{x}{2})\le(\DW{x}{5})$.  The reads
slot between these, immediately after their fulfilling write.  Reads are not
necessarily ordered with respect to each other, even if they come from the
same thread, as do the reads here.  Irrelevant writes also float relative to
each other, as do $(\DW{x}{3})$ and $(\DW{x}{4})$.  But irrelevant writes
must be ordered with respect to relevant writes and reads.  The resulting
order is somewhat weaker than traditional extended coherence, which requires
a total order on the writes, regardless of whether they are relevant.  We
discuss coherence further on page \pageref{page:coherence2}.

% The restriction of pomset order to conflicting events is called the
% \emph{extended coherence order} ($\reco$).  This relation can always be
% extended to totally order all conflicting events, as is common in hardware
% memory models.

% When a location is bound, every read of that location must be {fulfilled} by a
% matching write.
In order to be $\aLoc$-closed, a pomset must be ``done'' with $\aLoc$, in
both the concurrent and the sequential semantics.  The concurrent semantics
requires that all reads of $\aLoc$ be fulfilled.  The sequential semantics
requires that all formulae be \emph{independent of $\aLoc$}, as defined
in \textsection\ref{sec:data:models}:
$\forall\aVal.\;\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$.


\begin{definition}
  A pomset is \emph{$\aLoc$-closed} if every \external read on $\aLoc$ is fulfilled,
  and every formula is independent of $\aLoc$.
  Let $(\nu\aLoc\!\DOT\!\aPSS)$ be  $\aPSS'{\subseteq}\aPSS$ such that $\aPS'{\in}\aPSS'$
  when $\aPS'$ is $\aLoc$-closed.
  We define:
\begin{align*}
  \sem[\aThrd]{\VAR\aLoc\SEMI \aCmd} & \eqdef
  \nu \aLoc \DOT \sem[\aThrd]{\aCmd}  
\end{align*}
  A pomset is \emph{top-level} if it is $\aLoc$-closed for every location
  $\aLoc$.  
\end{definition}
Together with \ref{rf4}, the definition of $x$-closed disallows the following execution:
\begin{gather}
  \label{blocker}
  \begin{gathered}
  \VAR x\SEMI (x\GETS 1 \SEMI y_1^\modeRA\GETS1
  \PAR
  \IF{z_1}\THEN x\GETS2\FI\SEMI y_2^\modeRA\GETS1
  \PAR
  r\GETS z_2^\modeRA\SEMI s\GETS x)
  \\[-.5ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a}{\DW{x}{1}}{}
  \event{b}{\DW[\modeRA]{y_1}{1}}{right=of a}
  \event{c}{\DR{z_1}{1}}{right=1.8em of b}
  \event{d}{\DW{x}{2}}{right=of c}
  \event{e}{\DW[\modeRA]{y_2}{1}}{right=of d}
  \event{f}{\DR[\modeRA]{z_2}{1}}{right=1.8em of e}
  \event{g}{\DR{x}{1}}{right=of f}
  \sync{a}{b}
  \po{c}{d}
  \sync{d}{e}
  \sync{f}{g}
  \rf[out=8,in=172]{a}{g}
    \end{tikzinline}}
\end{gathered}
\end{gather}
In order to close $x$, we must choose whether $(\DW{x}{2})$ is
preceding $(\DW{x}{2}\xwk\DW{x}{1})$ or following
$(\DR{x}{1}\xwk\DW{x}{2})$.  This prevents $(\DW{x}{2})$ from blocking the
read after parallel composition.  For example, 
if \eqref{blocker} were placed in the context
\begin{math}
  b\GETS a
  \PAR
  d\GETS c
  \PAR
  \hole{},
\end{math}
we would have:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a}{\DW{x}{1}}{}
  \event{b}{\DW[\modeRA]{y_1}{1}}{right=of a}
  \event{w}{\DR{y_1}{1}}{right=1.8em of b}
  \event{x}{\DW{z_1}{1}}{right=of w}
  \event{c}{\DR{z_1}{1}}{right=1.8em of x}
  \event{d}{\DW{x}{2}}{right=of c}
  \event{e}{\DW[\modeRA]{y_2}{1}}{right=of d}
  \event{y}{\DR{y_2}{1}}{right=1.8em of e}
  \event{z}{\DW{z_2}{1}}{right=of y}
  \event{f}{\DR[\modeRA]{z_2}{1}}{right=1.8em of z}
  \event{g}{\DR{x}{1}}{right=of f}
  \sync{a}{b}
  \po{c}{d}
  \sync{d}{e}
  \sync{f}{g}
  \po{w}{x}
  \rf{b}{w}
  \rf{x}{c}
  \po{y}{z}
  \rf{e}{y}
  \rf{z}{f}
    \end{tikzinline}}
\end{gather*}
This violates the conventional, weaker statement of \ref{rf4}: there is no
conflicting write $\cEv$ such that $\bEv<\cEv<\aEv$.  By requiring order on
$(\DW{x}{2})$ we forbid this blocker and
% Since \ref{rf4}
% quantifies over \emph{all} writes to $x$, the semantics
validate scope extrusion (\textsection\ref{sec:valid}).

% \todo{finish this}: Our formulation of fulfillment is As we noted in
% \cite[\textsection B]{2019-sp}, scope extrusion fails if fulfillment
% requirement \ref{rf4}---for every conflicting write $\cEv$, either
% $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$---is replaced by an existential---there
% is no conflicting write $\cEv$ such that $\bEv<\cEv<\aEv$.


% Such conflicting writes are called \emph{blockers}.  The universal
% quantification ensures that parallel threads cannot turn a non-blocker into a
% blocker.  In that paper, we advocated the use of \emph{three-valued pomsets},
% which use strong order for \ref{rf3} and weak order for \ref{rf4}.  The
% pomsets studied in this paper are far simpler.


%\subsection{Fulfillment and Location Binding}


%\subsection{Composition, Concurrency and Conditional}
% Conditional execution is defined using pomset union and filtering, which
% selects pomsets satisfying a formula.

% \begin{definition}
%   Let $\aPS' = (\aPS^1 \cup \aPS^2)$ when $\Event' = \Event^1 \cup \Event^2$,
%   ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
%   ${\labeling'}\supseteq{\labeling^1}\cup{\labeling^2}$.

%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   Let $\aPS'\in \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}$  when
%   $\aPS\cup\aPS^1\in\sem{\aCmd}$,
%   $\aPS\cup\aPS^2\in\sem{\bCmd}$,
%   and ether\bigl(\aExp
%   \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard
%   \sem{\bCmd}\bigr)
% \end{definition}

% Composition is roughly union:
% $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.  For example, we have the
% following execution, which unions the two sides:
% \begin{gather*}
%   \IF{r<0}\THEN y\GETS1\FI
%   \PAR
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gather*}
% In addition to this execution, we allow that events with the same label to
% coalesce, taking the disjunction of their preconditions.  Thus, the semantics
% of this program also includes:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' = \Event^1 \cup \Event^2$,
% ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
% either
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% \begin{aligned}
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

%\subsection{Composition, Concurrency and Conditional}
\subsection{Composition}
Parallel composition is roughly pomset union, allowing that some events may
\emph{coalesce}, with the resulting precondition being the disjunction of the
precondition taken from the two sides.  Composition is used to define
conditionals (as in \cite{2019-sp}).  We also use it to define address
calculation (\textsection\ref{sec:variants}).  % In both cases, the use of
% composition is required to ensure disjunction closure
% (Definition~\ref{def:dis}).

Because of consistency
(Definition~\ref{def:mmpomset}), we do not include events with contradictory
preconditions.
% : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
% To make coalescing more explicit in the following examples, we show the
% element of the carrier set $\Event$ to left of its label.
Consider:
\begin{align*}
\begin{gathered}
  \IF{r<0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx1}{r<0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \IF{r\geq0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}
The parallel composition includes pomsets with either one of the two events, but not
both: including both would violate consistency.  However,  events with the same label may coalesce, taking the
disjunction of their preconditions.  Thus, the semantics of the combined
program also includes
\begin{math}
  (r<0\lor r\geq0\mid\DW{y}{1})
  % \IF{r<0}\THEN y\GETS1\FI
  % \PAR
  % \IF{r\geq0}\THEN y\GETS1\FI
  % \\
  %\hbox{\begin{tikzinline}[node distance=1.5em]
  %(\eventl{a}{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
  % \end{tikzinline}}
\end{math}.
Coalesced events inherit order from both sides.
\begin{definition}
  \label{def:par}
  % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
  % $\Event' \subseteq \Event^1 \cup \Event^2$,
  % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
  % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
  % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
  % unsatisfiable.
  Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
  when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$
  such that
$\aPS^1$ is completed exactly when $\aPS^2$ is completed,
$\Event' = \Event^1 \cup \Event^2$,
there is at most one termination in $\Event'$,
${\le'}\supseteq{\le^1}\cup{\le^2}$,
and for all $\aEv\in\Event'$,
either:
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^i \mid \exists\aEv\in\Event'.\; \bEv\le^i\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
\begin{gather*}
  \begin{aligned}
    \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
    &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
    &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
  \end{aligned}
\end{gather*}
% \end{gather*}
% if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% \labelingForm^2(\aEv)$ is unsatisfiable.
%\begin{gather*}
  We then define:
\begin{align*}
  \sem[\aThrd]{\aCmd \PAR[\bThrd][\bThrd'] \bCmd} & \eqdef
  \sem[\bThrd]{\aCmd} \parallel \sem[\bThrd']{\bCmd} 
\end{align*}
\end{definition}
The definition requires that if $\aPS'\in(\aPS^1 \parallel \aPS^2)$ is completed,
then both $\aPS^1$ and $\aPS^2$ are completed, and further, the termination events
\emph{must} coalesce in $\aPS'$.
% The definition ensures $\Event'$ is downclosed w.r.t.~each $\Event^i$.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}


% Conditional execution is defined using parallel composition and \emph{filtering}, which selects the
% subset of pomsets that imply a formula.
%  For an example
% using the first clause in the definition of composition,
% $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% Conditional execution and concurrency are defined using filtering, which
% selects pomsets satisfying a formula, and composition.  Composition is
% roughly union, ensuring that the combined events are compatible.
% % : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% % $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
% For example, consider:
% \begin{align*}
% \begin{gathered}
%   \IF{r<0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Putting these in parallel, we allow events with the same label to coalesce,
% taking the disjunction of their preconditions.  Thus, the semantics includes:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
%   % $\Event' \subseteq \Event^1 \cup \Event^2$,
%   % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
%   % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
%   % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
%   % unsatisfiable.

%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% %$\Event' \subseteq \COMPAT(\aPS^1,\,\aPS^2)$,
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^1 \cup \Event^2 \mid
% \exists\aEv\in\Event'.\; \bEv\le^1\aEv \textor \bEv\le^2\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% %\end{gather*}
% % if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% % $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% % \labelingForm^2(\aEv)$ is unsatisfiable.
% %\begin{gather*}
% \begin{aligned}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
%   \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
%   \\
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

\subsection{Conditional, Register Assignment, and Skip}
Conditional execution is defined using parallel composition and
\emph{filtering}: $(\aForm \guard \aPSS)$ selects the subset of pomsets in
$\aPSS$ that are implied by $\aForm$.  Register assignment is defined using
substitution: $(\aPSS\aSub)$ performs the substitution $\aSub$ on every
formula in $\aPSS$.  The semantics of $\SKIP$ is defined using singleton
pomsets with label $\DSTOP$.
\begin{definition}
  Let $(\aForm \guard \aPSS)$ be the set $\aPSS'\subseteq\aPSS$ such that
  $\aPS'\in\aPSS'$ when $\aForm$ implies $\labelingForm(\aEv')$ %, %for every
  $(\forall\aEv'\in\Event')$. 
  %
  Let $(\aPSS\aSub)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when there is
  $\aPS\in\aPSS$ such that: $\Event' = \Event$, ${\le'} = {\le}$,
  % ${\gtN'} = {\gtN}$,and
  $\labelingAct' = \labelingAct$, and
  $\labelingForm'(\aEv) = \labelingForm(\aEv)\aSub$.
  %
  \ \ Let $\aPS\in\stopPS$ when $\Event$ has one element labelled with action
  $\DSTOP$\!\!.
  We then define:
\begin{align*}
  \sem[\aThrd]{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
  \bigl(\aExp \guard \sem[\aThrd]{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem[\aThrd]{\bCmd}\bigr) 
  &
  \sem[\aThrd]{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
  \sem[\aThrd]{\aCmd}[\aExp/\aReg] 
  &  
  \sem[\aThrd]{\SKIP} & \eqdef
  \stopPS
\end{align*}
\end{definition}
Substitution applies to formulae, not actions.  For example,
$(x{=}1\mid\DW{x}{2})[y/x]=(y{=}1\mid\DW{x}{2})$. % and $(r{=}1\mid\DW{x}{2})[x/r]=(x{=}1\mid\DW{x}{2})$.

As an example of the conditional, consider the following fragments:
\begin{align}
  \label{ex:cond}
  \begin{gathered}
    \IF{s}\THEN x\GETS 1 \SEMI x\GETS 2\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{s \mathbin{\mid}\DW{x}{1}}{}
        \event{b}{s \mathbin{\mid}\DW{x}{2}}{right=of a}
        \wk{a}{b}
        \event{c}{s \mathbin{\mid}\DSTOP}{right=of b}
        \sync{b}{c}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{\lnot s}\THEN x\GETS 1 \SEMI x\GETS 3\FI
    \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\lnot s \mathbin{\mid}\DW{x}{1}}{}
        \event{b}{\lnot s \mathbin{\mid}\DW{x}{3}}{right=of a}
        \wk{a}{b}
        \event{c}{\lnot s \mathbin{\mid}\DSTOP}{right=of b}
        \sync{b}{c}
      \end{tikzinline}}
  \end{gathered}
\end{align}
Putting these together, we can coalesce the $(\DW{x}{1})$ events:
\begin{gather*}
  \aCmd_{\mathsf{cond}} = \IF{s}\THEN x\GETS 1 \SEMI x\GETS 2 \ELSE x\GETS 1 \SEMI x\GETS 3 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DW{x}{1}}{}
        \event{b}{s \mathbin{\mid}\DW{x}{2}}{right=of a}
        \wk{a}{b}
        \event{c}{s \mathbin{\mid}\DSTOP}{right=of b}
        \sync{b}{c}
      \end{tikzinline}}    
    \qquad\qquad\qquad\quad
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\DW{x}{1}}{}
        \event{b}{\lnot s \mathbin{\mid}\DW{x}{3}}{right=of a}
        \wk{a}{b}
        \event{c}{\lnot s \mathbin{\mid}\DSTOP}{right=of b}
        \sync{b}{c}
      \end{tikzinline}}    
\end{gather*}
Let us focus on the left pomset above.  It is derived from the composition:
\begin{gather*}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{s \mathbin{\mid}\DW{x}{1}}{}
        \event{b}{s \mathbin{\mid}\DW{x}{2}}{right=of a}
        \wk{a}{b}
        \event{c}{s \mathbin{\mid}\DSTOP}{right=of b}
        \sync{b}{c}
      \end{tikzinline}}
    \qquad\parallel\qquad
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{a}{\lnot s \mathbin{\mid}\DW{x}{1}}{}
      \end{tikzinline}}    
\end{gather*}
The existence of the singleton $(\lnot s \mathbin{\mid}\DW{x}{1})$ is
guaranteed by downset closure on \eqref{ex:cond}.  Consistency prevents any
pomset in the above $\sem{\aCmd_{\mathsf{cond}}}$ from containing both
$(\DW{x}{2})$ and $(\DW{x}{3})$.

Note that the definitions of consistency, downset, and composition prevent
the coalescing of $(\DW{y}{3})$ in
\begin{math}
  \sem{\IF{s}\THEN y\GETS 1 \SEMI y\GETS 3 \ELSE y\GETS 2 \SEMI y\GETS 3 \FI}.
\end{math}
Any pomset that included $(\DW{y}{3})$ would need to contain both $(s
\mathbin{\mid}\DW{y}{1})$ and $(\lnot s \mathbin{\mid}\DW{y}{2})$, which
violates consistency.
%Register assignment and $\SKIP$ are simple.
% the orders are drawn with
% \citeauthor{DBLP:journals/dc/Lamport86}'s notation.  
% For example:
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{rx1}{a}{}
%   \event{wy0}{b}{below right=of rx1}
%   \event{wy1}{c}{above right=of wy0}
%   \po{rx1}{wy0}
%   \po{rx1}{wy1}
%   \wk{wy0}{wy1}
% \end{tikzdisplay}
% is a visualization of the pomset where:
% \[\begin{array}{c}
%     E = \{ 0,1,2 \}
%     \quad
%     {\labeling} = \{(0,a),\,(1,b),\,(2,c)\}
%     \\
%     {\le} = \{(0,1),\,(0,2)\}\cup\{(0,0),\,(1,1),\,(2,2)\}
%     \quad
%     {\gtN} = {\le}\cup\{(2,3)\}
% \end{array}\]
% for example:


%The semantics of $\SKIP$ and register assignment are simple:
% \begin{definition}
% \begin{align*}
%   \sem{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
%   \sem{\aCmd}[\aExp/\aReg] 
%   &  
%   \sem{\SKIP} & \eqdef
%   \stopPS
% \end{align*}
% \end{definition}

% The semantic rule for condition, echoes the rule in Hoare
% logic:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}
\subsection{Prefixing} % for Trivial Expressions.}
\label{sec:pop}

We present a candidate definition for prefixing.  The full definition follows
in \textsection\ref{sec:refine}.

% \begin{candidate}
%   \label{def:pre-sc}
%   Let $(\aForm \mid \aAct) \prefixsc \aPSS$ be the set
%   $\PRE{\aPSS'}$ %$\aPSS'$ 
%   where
% $\aPS'\in\aPSS'$ when 
% there is $\aPS\in\aPSS$ such that
% \hbox{{\labeltext[1]{(1)}{1}} $\Event' = \Event \cup \{\bEv\}$,}
% {\labeltext[2]{(2)}{2}}  ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
% {\labeltext[3]{(3a)}{3}}  $\labelingAct'(\bEv) = \aAct$,
% (3b) $\labelingAct'(\aEv) = \labelingAct(\aEv)$, 
% {\labeltext[4a]{(4a)}{4a}}{\labeltext[4]{}{4}} $\labelingForm'(\bEv)$ implies $\aForm$, 
% \begin{enumerate}
% % \item[(1)]\label{pre-E} $\Event' = \Event \uplus \{\bEv\}$,
% % \item[(2)]\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
% % \item[(3a)] $\labelingAct'(\bEv) = \aAct$,
% % \item[(3b)] $\labelingForm'(\bEv)$ implies $\aForm$,
% % \item[(4a)] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
% \item[{\labeltext[4b]{(4b)}{4b}}] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
%   $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
% \item[{\labeltext[4c]{(4c)}{4c}}] if $\bEv$ does not \externally read then
%   $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$, and
% \item[{\labeltext[5]{(5)}{5}}] $\bEv \lt' \aEv$, 
% \end{enumerate}
% \end{candidate}


  

% We present several candidate definitions for prefixing before giving the
% final definition.  The candidates are progressively more general and less
% ordered.  We begin by considering programs with trivial expressions,
% including all of program order in pomset order.
% To simplify the definition, we construct the set of pomsets with the new
% action, then downset close.

% For programs with only trivial expressions, the simplest candidate
% definitions of read and write result in top-level executions being
% sequentially consistent.
% \begin{candidate}
%   \label{def:rw:sc1}
%   Let $(\aForm \mid \aAct) \prefixsimp \aPSS$ be the set
%   $\PRE{\aPSS'}$ %$\aPSS'$ 
%   where
%   $\aPS'\in\aPSS'$ when there is $\aPS\in\aPSS$ such that $\aPS'$ adds a
%   new event %with the given label
%   that precedes all of the events in $\aPS$.
%   \begin{align*}
%     % \tag{$\dagger$}\label{sc-read}
%     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
%     \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsimp \sem{\aCmd}}
%     \\
%     % \tag{$\ddagger$}\label{sc-write}
%     \sem{\aLoc^\amode\GETS\aVal\SEMI \aCmd} & =
%     %\textstyle\bigcup_\aVal\; (\bVal=\aVal \mid
%     \smash{\DWmode\aLoc\aVal \prefixsimp \sem{\aCmd}}
%   \end{align*}
% \end{candidate}
%For now, ignore the preconditions and substitutions. We explain them in the subsections below.

% The definition ensures that program order is included in the pomset order.
% Due to the requirements of fulfillment, we also have that $\reco$ is included
% in pomset order.  As a result, all executions are sequentially consistent.
% For example, consider the \emph{store buffering} and \emph{load buffering} litmus \labeltext[SB]{tests}{SB}:
% \begin{gather*}
%   \taglabel{SB/LB}
%   \begin{gathered}
%   x\GETS0\SEMI
%   y\GETS0\SEMI
%   (
%   x\GETS1\SEMI\aReg\GETS y
%   \PAR
%   y\GETS1\SEMI \aReg\GETS x)
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wy0}{\DW{y}{0}}{below=of wx0}
%       \event{wx}{\DW{x}{1}}{right=of wx0}
%       \event{wy}{\DW{y}{1}}{right=of wy0}
%       \event{ry}{\DR{y}{0}}{right=of wx}
%       \event{rx}{\DR{x}{0}}{right=of wy}
%       \wk{wx0}{wx}
%       \wk{wy0}{wy}
%       \rf{wy0}{ry}
%       \rf{wx0}{rx}
%       \wk[out=-150,in=15]{ry}{wy}
%       \wk[out=150,in=-15]{rx}{wx}
%       % \po{rx}{wy}
%       \pox{wy}[below]{rx}
%       \pox{wx}{ry}
%     \end{tikzinline}}
% \end{gathered}
% \qquad
%   \begin{gathered}
%   \aReg\GETS y\SEMI x\GETS1
%   \PAR
%   \aReg\GETS x\SEMI y\GETS1
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em and 2em]
%       \event{ry}{\DR{y}{1}}{}
%       \event{rx}{\DR{x}{1}}{below=of ry}
%       \event{wx}{\DW{x}{1}}{right=of ry}
%       \event{wy}{\DW{y}{1}}{right=of rx}
%       \rf{wy}{ry}
%       \rf{wx}{rx}
%       \pox{rx}[below]{wy}
%       \pox{ry}{wx}
%       % \po{rx}{wy}
%     \end{tikzinline}}
% \end{gathered}
% \end{gather*}
% All of the cross-thread order is required by the definition of fulfillment.
% Candidate \ref{def:rw:sc1} disallows the executions, since it includes all of
% program order in pomset order, resulting in the cycles shown above.
% To allow these executions, we drop the order marked $\rpox$.

% We cannot drop all of program order, however, since some actions within a
% thread are causally related. Preconditions allow us to detect these
% relationships.  We write the definition of the prefixing operator more
% carefully this time, and highlight some of the changes in the candidate
% semantics:

%\subsection{Program Order Prefixing}
\begin{candidate}
  \label{cand:ord}
  \label{def:pre-sc}
  \label{def:prefix}
  Let $\PRE{\aPSS}=\{\aPS'\mid\aPS'$ is a downset of some $\aPS \in \aPSS\}$.
  
  Let $(\aForm \mid \aAct) \prefix \aPSS$ be the set
  $\PRE{\aPSS'}$ %$\aPSS'$ 
  where
$\aPS'\in\aPSS'$ when 
there is $\aPS\in\aPSS$ such that
\hbox{{\labeltextsc[P1]{(P1)}{1}} $\Event' = \Event \cup \{\bEv\}$,}
{\labeltextsc[P2]{(P2)}{2}}  ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
{\labeltextsc[P3]{(P3a)}{3}}  $\labelingAct'(\bEv) = \aAct$,
\labeltextsc[P3b]{(P3b)}{3b} $\labelingAct'(\aEv) = \labelingAct(\aEv)$, 
\begin{enumerate}
% \item[(1)]\label{pre-E} $\Event' = \Event \uplus \{\bEv\}$,
% \item[(2)]\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
% \item[(3a)] $\labelingAct'(\bEv) = \aAct$,
% \item[(3b)] $\labelingForm'(\bEv)$ implies $\aForm$,
% \item[(4a)] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
\item[{\labeltextsc[P4a]{(P4a)}{4a}}]{\labeltextsc[P4]{}{4}} $\labelingForm'(\bEv)$ implies $\aForm$, 
\item[{\labeltextsc[P4b]{(P4b)}{4b}}] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
\item[{\labeltextsc[P4c]{(P4c)}{4c}}] if $\bEv$ does not \externally read then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$, 
\item[{\labeltextsc[P5a]{(P5a)}{5a}}] %$\bEv$ \externally reads and
  \labeltextsc[P5]{}{5} if $\aEv$ writes then either $\bEv\lt'\aEv$ or $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$,
% \item[5a.]  if $\aEv$ writes then either $\labelingForm'(\aEv)$ implies
%   $\labelingForm(\aEv)$, or some $\cEv\lt'\aEv$ reads $\aVal$
%   from $\aLoc$ and $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
% \item[5a.] if %$\bEv$ \externally reads and
%   $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and $\aEv$ writes, then
%   $\bEv\lt'\aEv$,
\item[{\labeltextsc[P5b]{(P5b)}{5b}}] if $\bEv$ and $\aEv$ are \external actions in conflict,
    then $\bEv\lt'\aEv$, %$\bEv \gtN' \aEv$,
\item[{\labeltextsc[P5c]{(P5c)}{5c}}] if $\bEv$ is an acquire or $\aEv$ is a release, then $\bEv \lt' \aEv$, and
\item[{\labeltextsc[P5d]{(P5d)}{5d}}] if $\bEv$ is an SC write and $\aEv$ is an SC read, then $\bEv \lt' \aEv$.
%\item[5e.] if $\aEv$ is a termination, then $\bEv\lt'\aEv$.
% \item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
%   is location independent.
\end{enumerate}
% \end{definition}
% %\vspace{-2ex}
% \begin{candidate}%\ \vspace{-1ex}
  We then define:
  \begin{gather*}
    \begin{aligned}[t]
      % \tag{$\dagger$}\label{sc-read}
      \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & \eqdef \textstyle\bigcup_\aVal\;
      (\DRmode\aLoc\aVal) \prefix \sem{\aCmd} [\aLoc/\aReg]
      \\
      % \tag{$\ddagger$}\label{sc-write}
      \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & \eqdef
      \textstyle\bigcup_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal)
      \prefix \sem{\aCmd}[\aExp/\aLoc]
    \end{aligned}
  \end{gather*}
\end{candidate}

The semantics of read and write introduce a pomset for each possible value.
Note that the value in the actions is fixed.  For writes, the dependence on
$\aExp$ appears in the precondition: $\aExp=\aVal$.

The main work happens in the definition of prefixing ($\prefix$): Item
\ref{1} introduces a new event.  Item \ref{2} ensures that no order is
removed from old events. Item \ref{3} specifies the actions labelling the
events; item \ref{4} specifies the preconditions.  Item \ref{5}
specifies the preserved program order.

Whereas a write action introduces a precondition---that must be satisfied
sequentially---on the value to be written; a read introduces a pomset
requirement---that may be fulfilled concurrently---on the value to be read.

In the next section, we explain the concurrent semantics using standard
litmus tests: Read fulfillment is constrained by the program order that is
preserved by \ref{5}.  Item \ref{5a} captures \emph{read to write
  dependency}\footnote{When $\bEv$ is not a read, \ref{4c} trivially implies
  \ref{5a}.}.  It only requires order from read to write when the
precondition of the write is \emph{weakened} using \ref{4b}.  Item \ref{5b}
captures the extended coherence requirement on actions that touch the same
location.  Item \ref{5c} imposes the order required by acquire and release
actions\footnote{Recall that termination actions are releases.}.  Item
\ref{5d} imposes the additional order required by SC actions\footnote{Recall
  that SC reads are acquires and SC writes are
  releases.}.  %(We explain item 6 in the next subsection.)

% The interaction between preconditions and preserved order is capture in
% \ref{5a}.
% Program order need only be preserved from a read to a dependent
% write (\ref{5a}), between conflicting events (\ref{5b}), and around fences
% and synchronization (\ref{5c}, \ref{5d}).

In this section, we explain the sequential semantics: Preconditions are
satisfied using the substitutions in the semantic rules and in \ref{4b}.  We
also discuss \ref{5a}, which connects the concurrent and sequential
semantics.

Let us revisit the unexpected execution \eqref{unexpected} of \eqref{OOTA?}:% ,
% as explained in \textsection\ref{sec:domain}:
\begin{gather*}
  y\GETS 0 \SEMI x\GETS 0\SEMI (y\GETS x
  \PAR
  r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI)
  \\
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{left=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{z}{1}}{right=of wx1}
  %\event{stop}{\DSTOP}{right=of wa1}
  \rf[out=-165,in=-15]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=12,in=168]{wx0}{wx1}
  \wk[out=15,in=165]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wa1}
  % \sync[out=30,in=150]{wx1}{stop}
  % \sync{wa1}{stop}
\end{tikzinline}}
\end{gather*}
% Note that $\sem{z\GETS r}$ contains $(r{=}0\mid\DW{z}{0})$,
% $(r{=}1\mid\DW{z}{1})$, etc.  Thus 
It is immediate from the definition that $\sem{x\GETS r\SEMI z\GETS r}$
contains pomset candidates such as:
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{r=1\mid\DW{x}{1}}{}
      \event{wz}{r=1\mid\DW{z}{1}}{right=of wx}
    \end{tikzinline}}  
  &&
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{r=1\mid\DW{x}{1}}{}
      \event{wz}{r=2\mid\DW{z}{2}}{right=of wx}
    \end{tikzinline}}  
\end{align*}
Consistency (Definition \ref{def:mmpomset}) rules out the right pomset, since
the conjunction of preconditions is unsatisfiable.
No order is required between the writes.

% Thus,
% $\sem{x\GETS r\SEMI z\GETS r}$ can only contains pomsets such as:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%       \event{wx}{r{=}1\mid\DW{x}{1}}{}
%       \event{wz}{r{=}1\mid\DW{z}{1}}{right=of wx}
%     \end{tikzinline}}  
%   &&
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%       \event{wx}{r=2\mid\DW{x}{2}}{}
%       \event{wz}{r=2\mid\DW{z}{2}}{right=of wx}
%     \end{tikzinline}}  
% \end{align*}
Combining the two sides of the conditional, 
\begin{math}
  \sem{\IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI}
\end{math}
contains:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{r{=}1\lor r{=}0\mid\DW{x}{1}}{}
      \event{wz}{r{=}1\mid\DW{z}{1}}{right=of wx}
    \end{tikzinline}}  
\end{gather*}

When prefixing ``$r\GETS y$,'' we first substitute $[y/r]$, resulting in:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{y{=}1\lor y{=}0\mid\DW{x}{1}}{}
      \event{wz}{y{=}1\mid\DW{z}{1}}{right=of wx}
    \end{tikzinline}}  
\end{gather*}
Adding the read action,
\begin{math}
  \sem{r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI} 
\end{math}
contains:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{y{=}1\lor y{=}0\mid\DW{x}{1}}{}
      \event{wz}{y{=}1\mid\DW{z}{1}}{right=of wx}
      \event{ry}{\DR{y}{1}}{left=of wx}
    \end{tikzinline}}
\end{gather*}
Since $(y{=}1)[2/y]$ is unsatisfiable, \ref{4b} prevents pomsets such as:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{y{=}1\lor y{=}0\mid\DW{x}{1}}{}
      \event{wz}{y{=}1\mid\DW{z}{1}}{right=of wx}
      \event{ry}{\DR{y}{2}}{left=of wx}
    \end{tikzinline}}
\end{gather*}
Thus the read must be consistent with the predicates.

\ref{4b} also allows predicates to weaken, in which case \ref{5a} requires order:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{y{=}1\lor y{=}0\mid\DW{x}{1}}{}
      \event{wz}{\DW{z}{1}}{right=of wx}
      \event{ry}{\DR{y}{1}}{left=of wx}
      \po[out=15,in=165]{ry}{wz}
    \end{tikzinline}}
\end{gather*}
Adding the write,
\begin{math}
  \sem{y\GETS 0\SEMI r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS1 \FI} 
\end{math}
substitutes $[0/y]$, resulting in: 
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{0{=}1\lor 0{=}0\mid\DW{x}{1}}{}
      \event{wz}{\DW{z}{1}}{right=of wx}
      \event{ry}{\DR{y}{2}}{left=of wx}
      \event{wy}{\DW{y}{0}}{left=of ry}
      \po[out=15,in=165]{ry}{wz}
      \wk{wy}{ry}
    \end{tikzinline}}
\end{gather*}
Since $0{=}1\lor 0{=}0$ is a tautology, we have:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{\DW{x}{1}}{}
      \event{wz}{\DW{z}{1}}{right=of wx}
      \event{ry}{\DR{y}{2}}{left=of wx}
      \event{wy}{\DW{y}{0}}{left=of ry}
      \po[out=15,in=165]{ry}{wz}
      \wk{wy}{ry}
    \end{tikzinline}}
\end{gather*}

As discussed at the beginning of this section, an attempt to replicate this execution with \eqref{OOTA!} fails,
introducing a cycle:
\begin{gather*}
  y\GETS 0 \SEMI x\GETS 0\SEMI (  y\GETS x
  \PAR
    r\GETS y\SEMI \IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS2 \FI)
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{left=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{z}{1}}{right=of wx1}
  %\event{stop}{\DSTOP}{right=of wa1}
  \rf[out=-165,in=-15]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=12,in=168]{wx0}{wx1}
  \wk[out=15,in=165]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wa1}
  % \sync[out=30,in=150]{wx1}{stop}
  % \sync{wa1}{stop}
  \po{ry1}{wx1}
\end{tikzinline}}
\end{gather*}
The difference can be seen immediately when looking at the two sides of the
conditional
\begin{math}
  \sem{\IF{r}\THEN x\GETS r\SEMI z\GETS r \ELSE x\GETS2 \FI},
\end{math}
which contains:
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{r{=}1\mid\DW{x}{1}}{}
      \event{wz}{r{=}1\mid\DW{z}{1}}{right=of wx}
    \end{tikzinline}}  
  &&
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wx}{r{=}2\lor r{=}0\mid\DW{x}{2}}{}
      \event{wz}{r{=}2\mid\DW{z}{2}}{right=of wx}
    \end{tikzinline}}  
\end{align*}
In particular, there is no $(r{=}1\lor r{=}0\mid\DW{x}{1})$.
It is only possible to satisfy the precondition of $(r{=}1\mid\DW{x}{1})$
using \ref{4b} when prefixing $(\DR{y}{1})$, which forces a dependency
between the read and write via \ref{5a}.

\endinput

\begin{align*}
  \begin{gathered}
    r\GETS x\SEMI y\GETS r
    \\    
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wy1}{x=1\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wy1}{x<0\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
First consider the else-branch of the conditional: the semantics of
``${\IF{\lnot r}\THEN x\GETS1 \FI}$'' contains $(r{=}0 \mid \DW{x}{1})$,
indicating the control dependency.  The then-branch is more complex: the
semantics of ``${\IF{r}\THEN x\GETS r \FI}$'' contains
$(r{\neq}0 \land r{=}1 \mid \DW{x}{1})$ indicating both a control and a data
dependency.  This can be simplified to $(r{=}1 \mid \DW{x}{1})$.  Combining
the two branches of the conditional, we have
$(r{=}0 \lor r{=}1 \mid \DW{x}{1})$.  Prepending $r\GETS y$ substitutes
$[y/r]$, resulting in $(y{=}0 \lor y{=}1 \mid \DW{x}{1})$.  Prepending the
initializer $y\GETS 0$ substitutes $[0/y]$, resulting in
$(0{=}0 \lor 0{=}1 \mid \DW{x}{1})$.  This is a tautology, which we write as
$(\DW{x}{1})$.   We repeat this calculation in \textsection\ref{sec:pop},
after giving the formal definitions.


For the new event, \ref{4a} requires that the precondition in $\aPS'$ implies
$\aForm$.
For old writes, \ref{4c} requires that the new precondition in
$\aPS'$ must imply the old precondition in $\aPS$.
For reads, \ref{4b} allows some preconditions to weaken and requires
others to strengthen.  Recall the pomsets given previously \eqref{ex-1} for $y\GETS r$ and
$\IF{r<0}\THEN y\GETS1 \FI$. % from the beginning of this section:
% \begin{align*}
%   \begin{gathered}
%     y\GETS r
%     \\
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{wy1}{r=1\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     \IF{r<0}\THEN y\GETS1 \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{wy1}{r<0\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
Prepending $\aReg\GETS\aLoc$ first causes the substitution $[x/r]$:
\begin{align*}
  \begin{gathered}
    r\GETS x\SEMI y\GETS r
    \\    
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wy1}{x=1\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wy1}{x<0\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Item \ref{4b} then the substitutes the chosen value $[1/x]$:
\begin{align}
  \label{ex-2}
  \begin{gathered}
    % r\GETS x\SEMI y\GETS r
    % \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \event{wy1}{1=1\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    % \\
    \hbox{\begin{tikzinline}[node distance=1.5em]
        \nonevent{wy1}{1<0\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        %\po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align}
% We can write these more succinctly as:
% % We often drop preconditions on tautological events and sometimes cross out
% % unsatisfiable ones (which may are ignored):
% \begin{align*}
%   \begin{gathered}
%     % r\GETS x\SEMI y\GETS r
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \event{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1.5em]
%         \nonevent{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
On the right, $(\DW{y}{1})$ has become impossible; this is no longer a pomset
due to \emph{inconsistency}.  On the left, it has become
causally dependent on the read.  By prefixing a read event, the precondition
$x=1$ has moved from the sequential realm of Hoare logic to the concurrent
memory model.  Rather than a precondition that must be \emph{satisfied}, the
resulting pomset has a read event that must be \emph{fulfilled}.

% To ensure that at most one write is enabled, these
% are given disjoint preconditions.

%The use of $\parallel$ is unnecessary  for reads.
% : the read rule does not introduce read preconditions, and item \ref{5a} of
% Definition \ref{def:prefix} ignores them.
Whereas a write action introduces a precondition---satisfied
sequentially---on the value to be written; a read introduces a pomset
requirement---fulfilled concurrently---on the value to be read.  Since reads
of different values do not have disjoint preconditions, it is important that
a read introduce at most one event per pomset.  Thus, we use $\cup_\aVal$ to
combine pomsets for different read values, rather than $\parallel_\aVal$.
% In the concurrent world, writes are capabilities; reads are obligations.
% Thus, a read should introduce at most one event per pomset.


% We can now explain the substitution in the semantics of read in Candidate~\ref{def:rw:sc1}.
% % (The substitution in the semantics of write \eqref{sc-write} is not used here; we explain
% % it after introducing \emph{internal reads}, below.)
% Returning to our example, to compute
% $\sem{r\GETS x\SEMI y\GETS r}$, we first compute
% $(r\EQ1\mid\DW{y}{1})[x/r]$, then perform prefixing on the resulting $(x\EQ1\mid\DW{y}{1})$.  By \ref{4b}, reading $1$
% performs the further substitution of $[1/x]$, allowing the precondition to
% weaken to $(1\EQ1)$.  Likewise, reading $0$ performs $[0/x]$, requiring the precondition
% to strengthen to $(0\EQ1)$.

% Second, the use of $\PAR$ to combine pomsets formed by write prefixing
% ensures that the semantics is ``disjunctive'' in a certain sense.
% The following example uses address calculation, defined formally in
% \textsection\ref{sec:variants}.  It also use the operator ``$\BANG \aExp$,''
% which evaluates to $1$ when $\aExp$ is $0$, and
% $0$ otherwise.  Note that 
% \begin{math}
%   \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
% \end{math}
% includes both of the following pomsets:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
%   \qquad
%   %\\[-1.5ex]\intertext{and:}\\[-5ex]
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
%       \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
% \end{align*}
% By using $\PAR$ rather than $\cup$, it also includes the following (where,
% contrary to convention, we show disjoint events):
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em]
%       \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%       \event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
%     \end{tikzinline}}%\;\;\cdots
% \end{gather*}
% Using $\cup$, the semantics would exclude this pomset, and thus fail to
% validate \emph{case analysis}---for example, refining this program,
% \begin{math}
%   \aCmd = (a[r] \GETS 0\SEMI a[0]\GETS \BANG r),
% \end{math}
% to
% \begin{math}
%   \IF{r\EQ1}\THEN \aCmd\ELSE \aCmd\FI.
% \end{math}

% \subsection{General Prefixing}
% \label{sec:gp}

% We now relax item \ref{5} so that only some program order is {preserved}.
% The final definition has a small delta with respect to
% Candidate \ref{def:pre-sc}.  Program order need only be preserved from
% a read to a dependent write (\ref{5a}), between conflicting events
% (\ref{5b}), and around fences (\ref{5c}, \ref{5d}).
% % %\ref{5a}
% % weakening a dependent precondition,
% % %\ref{5b}
% % conflict (aka, coherence), 
% % %\ref{5c}
% % $\modeRA$-fences, and 
% % %\ref{5d}
% % $\modeSC$-fences.

% % and our last failed candidate semantics.
% \begin{candidate}
%   \label{def:prefix}
% Let $(\aForm \mid \aAct) \prefix \aPSS$ be the set
%   $\PRE{\aPSS'}$ %$\aPSS'$ 
% where
% $\aPS'\in\aPSS'$ when
% there is some $\aPS\in\aPSS$ that satisfies items \ref{1}-\ref{4} of
% Candidate \ref{def:pre-sc} such that:
% \begin{enumerate}
% \item[{\labeltext[5a]{(5a)}{5a}}] %$\bEv$ \externally reads and
%   \labeltext[5]{if}{item:5} $\aEv$ writes then either $\bEv\lt'\aEv$ or $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$,
% % \item[5a.]  if $\aEv$ writes then either $\labelingForm'(\aEv)$ implies
% %   $\labelingForm(\aEv)$, or some $\cEv\lt'\aEv$ reads $\aVal$
% %   from $\aLoc$ and $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
% % \item[5a.] if %$\bEv$ \externally reads and
% %   $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and $\aEv$ writes, then
% %   $\bEv\lt'\aEv$,
% \item[{\labeltext[5b]{(5b)}{5b}}] if $\bEv$ and $\aEv$ are \external actions in conflict,
%     then $\bEv\lt'\aEv$, %$\bEv \gtN' \aEv$,
% \item[{\labeltext[5c]{(5c)}{5c}}] if $\bEv$ is an acquire or $\aEv$ is a release, then $\bEv \lt' \aEv$, and
% \item[{\labeltext[5d]{(5d)}{5d}}] if $\bEv$ is an SC write and $\aEv$ is an SC read, then $\bEv \lt' \aEv$.
% %\item[5e.] if $\aEv$ is a termination, then $\bEv\lt'\aEv$.
% % \item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
% %   is location independent.
% \end{enumerate}
% % \end{definition}
% % %\vspace{-2ex}
% % \begin{candidate}%\ \vspace{-1ex}
%   \label{cand:ord}
%   \begin{gather*}
%     \begin{aligned}[t]
%       % \tag{$\dagger$}\label{sc-read}
%       \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & = \textstyle\bigcup_\aVal\;
%       (\DRmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd} [\aLoc/\aReg]
%       \\
%       % \tag{$\ddagger$}\label{sc-write}
%       \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
%       \textstyle\bigcup_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal)
%       \mathhl{\prefix}\; \sem{\aCmd}\mkern3.5mu\mathhl{[\aExp/\aLoc]}
%     \end{aligned}
%   \end{gather*}
% \end{candidate}

% \end{definition}
% \begin{candidate}
%   Replace $\prefixsc$ in Candidate~\ref{def:rw:sc1} by $\prefix$.
% \end{candidate}
% Item \ref{5a} captures \emph{read to write dependency}\footnote{When $\bEv$
%   is not a read, \ref{4c} trivially implies \ref{5a}.}.  It only requires
% order from read to write when the precondition of the write is
% \emph{weakened} using \ref{4b}.  Item \ref{5b} captures the extended
% coherence requirement on actions that touch the same location.  Item \ref{5c}
% imposes the order required by acquire and release actions\footnote{Recall
%   that termination actions are releases.}.  Item \ref{5d} imposes the
% additional order required by SC actions\footnote{Recall that SC reads are
%   acquires and SC writes are
%   releases.}.  %(We explain item 6 in the next subsection.)


%This example is also disallowed if we use $\modeSC$ rather than $\modeRA$.
% Item \ref{5d} ensures that program order between SC operations is always
% preserved.  Combined with the requirements for fulfillment, this is
% sufficient to establish that programs with only SC access have only SC
% executions; for example, execution candidate \ref{SB} is banned when the
% actions of the two threads are all $\modeSC$ (but allowed with less order
% otherwise, as discussed below).  It is also immediate that SC actions can be
% totally ordered, using any linearization of pomset order.  Just as SC access in
% \armeight{} is simplified by \mca, it is simplified here by the
% global pomset order.
% \begin{gather*}
%   x\GETS0\SEMI x\GETS1\SEMI\aReg\GETS y
%   \PAR
%   y\GETS0\SEMI y\GETS1\SEMI \aReg\GETS x
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wy0}{\DW{y}{0}}{below=of wx0}
%       \event{wx}{\DW{x}{1}}{right=of wx0}
%       \event{wy}{\DW{y}{1}}{right=of wy0}
%       \event{ry}{\DR{y}{0}}{right=of wx}
%       \event{rx}{\DR{x}{0}}{right=of wy}
%       \wk{wx0}{wx}
%       \wk{wy0}{wy}
%       \po{wy}{rx}
%       \po{wx}{ry}
%       \rf{wy0}{ry}
%       \rf{wx0}{rx}
%       \wk{ry}{wy}
%       \wk{rx}{wx}
%       % \po{rx}{wy}
%     \end{tikzinline}}
% \end{gather*}

% We relax program order on non-SC accesses in order to allow outcomes like
% that of execution candidate \ref{SB}.
% Order is relaxed between reads, between writes to different
% locations, and from a read to an independent write:
% \begin{gather*}
%   \aCmd=(\aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI)
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%       \event{wy1}{\DW{y}{1}}{}
%       \event{rx1}{\DR{x}{1}}{left=of wy1}
%     \end{tikzinline}}
% \end{gather*}
% The existence of this pomset is justified
% by the Hoare triple
% $\hoare{\TRUE}{\aCmd}{y=1}$.




% Program order is only imposed from read to write when the precondition of
% the write is weakened.  Thus we have:
% \begin{displaymath}
%   \aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1.5em]
%   \event{wy1}{\DW{y}{1}}{}
%   \event{rx1}{\DR{x}{1}}{left=of wy1}
% \end{tikzdisplay}
% Since no order is imposed, the two actions can be reordered.
% Let $\aCmd$ be the program above.  The existence of this pomset is justified
% by the triple
% $\hoare{\TRUE}{\aCmd}{y=1}$.

Item \ref{5a} imposes order from read to write when weakening the
precondition of the write via \ref{4b}, as on the left hand side of
\eqref{ex-2}.
% \begin{gather*}
%   r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1.5em]
%       \event{wy1}{1\geq0\mid\DW{y}{1}}{}
%       \event{rx1}{\DR{x}{1}}{left=of wy1}
%       \po{rx1}{wy1}
%     \end{tikzinline}}
% \end{gather*}
Item \ref{4b} \emph{allows} a precondition to weaken, but does not \emph{require} it.
Item \ref{5a} only requires order when the precondition weakens.
Thus, no order is required in: % the following execution:
\begin{gather*}
  \aCmd=(r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI)
  %\label{ex555}
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wy1}{x{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
The existence of this pomset is justified
by the Hoare triple $\hoare{x\geq0}{\aCmd}{y=1}$.  It is not justified by the value of the read
action.  

Nonetheless, item \ref{4b} requires that the value of the read action must
be \emph{consistent} with subsequent formulae, via
$\labelingForm(\aEv)[\aVal/\aLoc]$.  In this example, the pomset becomes inconsistent
if ${-}2$ is read for $x$:
\begin{gather*}
  % r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  % \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \nonevent{wy1}{{-2}{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{{-2}}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
This holds for all preceding reads, unless the precondition is discharged by
introducing order.  Thus, $\sem{s\GETS x\SEMI \aCmd}$ contains the
pomset on the left below, but not that inconsistent ``pomset'' on the right:
\begin{align*}
  % s\GETS x\SEMI \aCmd
  % \\[-1ex]
  % \nonumber
  \hbox{\begin{tikzinline}[node distance=.3em]
      \event{wy1}{1{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=1em of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      \po{rx1}{wy1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
  &&
  \hbox{\begin{tikzinline}[node distance=.3em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
\end{align*}

Like item \ref{4b}, which substitutes $[\aVal/\aLoc]$ during a read, Candidate
\ref{cand:ord} substitutes $[\aExp/\aLoc]$ during a write.  Like \ref{4b}, this
affects subsequent preconditions, either allowing them to weaken, or
requiring them to strengthen.  For write prefixing, however, there is no rule
corresponding to item \ref{5a}. Unlike a read event, order is \emph{not} imposed from
a write event to the subsequent events whose precondition it weakens:
\begin{align*}
\begin{gathered}
  x \GETS 0\SEMI \aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{wy1}{0{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{0}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  x \GETS {-}2\SEMI\aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{{-}2}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}





% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
