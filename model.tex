\section{Model}
\label{sec:model}
\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}
Let $\aSub$ range over substitutions of the form $\aForm[\aLoc/\aReg]$ or $\aForm[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions do not include memory locations,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution, 
\item there is a relation $\vDash$ between formulae, 
\item there are partial functions $\rreads$ and $\rwrites: \Act \fun (\Loc
  \times \Val)$, and
\item there are sets $\Rel$ and $\Acq \subseteq\Act$.
\end{itemize}
Since formulae are closed under substitutions of the form
$\aForm[\aLoc/\aReg]$, they must include equalities of the form
$(\aEExp=\bEExp)$, where $\aEExp$ and $\bEExp$ are \emph{extended
  expressions} that include memory locations.  We elide the details.
(By composition of the closure conditions, formulae must also be closed
under that substitutions of the form $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.)

We say that $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes} $\aVal$
\emph{to} $\aLoc$ whenever $\rwrites(\aAct) = (\aLoc,\aVal)$.  In examples,
the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from
$\aLoc$, and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.

We say that $\aAct$ is an \emph{acquire} if $\aAct\in\Acq$, and that $\aAct$
is a \emph{release} if $\aAct\in\Rel$.  We say that $\aAct$ is a \emph{fence}
if it is either a release or an acquire.  In examples, the actions are of the
form $(\DRAcq{\aLoc}{\aVal})$, which is an acquire that reads $\aVal$ from
$\aLoc$, $(\DWRel{\aLoc}{\aVal})$, which is a release that writes $\aVal$ to
$\aLoc$, and $(\DF)$, which is both an acquire and a release and neither
reads nor writes.

We say that $\aForm$ \emph{implies} $\bForm$ whenever $\aForm\vDash\bForm$,
that $\aForm$ is a \emph{tautology} whenever $\TRUE\vDash\aForm$, that
$\aForm$ is \emph{unsatisfiable} whenever $\aForm\vDash\FALSE$, and that
$\aForm$ is \emph{independent of $\aLoc$} whenever
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$.


\subsection{3-valued pomsets}
\label{sec:pomsets}

\begin{definition}
  A \emph{(3-valued) pomset} with alphabet $\Alphabet$ is tuple $(\Event,
  {\le}, {\gtN}, \labelling)$, such that 
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  %\item $\ESub\subseteq\Event$ is a set of \emph{accepting states}, 
  \item $\labelling: \Event \fun \Alphabet$ is a \emph{labelling},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
    % \begin{enumerate}
    % \item $\aEv \le \aEv$,
    % \item if $\bEv \le \aEv$ and $\aEv \le \bEv$ then $\bEv = \aEv$,
    %   \\(this follows from 5a and 5b)
    % \item if $\cEv \le \bEv \le \aEv$ then $\cEv \le \aEv$, and
    % \end{enumerate}
  \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
    \begin{itemize}
    \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$,
    \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then $\bEv = \aEv$,
    \item if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$ then $\cEv \gtN \aEv$.
    \end{itemize}
\end{itemize}
\end{definition}
In the remainder of the paper, we drop the prefix ``3-valued'', referring to
3-valued pomsets simply as \emph{pomsets}.

We fix the alphabet $\Alphabet=(\Formulae\times\Act)$.  We write pairs in
$(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$.  We elide $\aForm$ when
$\aForm$ is a tautology.  Define $\labellingForm$ and $\labellingAct$ so that
$\labellingForm(\aEv)=\aForm$ and $\labellingAct(\aEv)=\aAct$ whenever
$\labellingForm(\aEv)=(\aForm\mid\aAct)$.

We lift terminology from logical formulae and actions to events, for example
if $\labelling(\aEv)=(\aForm\mid\aAct)$ then we say $\aEv$ is unsatisfiable
whenever $\aForm$ is unsatisfiable, $\aEv$ writes $\aVal$ to $\aLoc$ whenever
$\aAct$ writes $\aVal$ to $\aLoc$, and so forth.

We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \nonevent{wy0}{\DW{\bLoc}{0}}{right=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \po{rx1}{wy0}
  \po[out=30,in=150]{rx1}{wy1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[\begin{array}{c}
  E = \{ 0,1,2 \} \quad
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \\
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\end{array}\]
We visualize $(\bEv \gtN \aEv)$ as a dashed
arrow from $\bEv$ to $\aEv$.
We refer to edges introduced by $(\bEv < \aEv)$ as
\emph{strong edges} and by $(\bEv \gtN \aEv)$
as \emph{weak edges}.
For readability, we often highlight the reads-from edges as well.
% for example:
For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=2.5 em of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \wk{rx1}{wx2}
\end{tikzpicture}\]

\subsection{Semantics of programs}
\label{sec:semantics}

\begin{figure*}
\begin{eqnarray*}
  \sem{\SKIP} & = & \{ \emptyset \} \\
  \sem{\FENCE\SEMI \aCmd} & = & (\DF) \prefix \sem{\aCmd} \\
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]\bigr) \\
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]\bigr) \\
  \sem{\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\ACQ\aReg\GETS\aLoc\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; (\DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF (\aExp) \THEN \aCmd \ELSE \bCmd \FI} & = & \bigl((\aExp \neq 0) \guard \sem{\aCmd}\bigr) \parallel \bigl((\aExp=0) \guard \sem{\bCmd}\bigr) \\
  \sem{\aCmd \PAR \bCmd} & = & \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
\caption{Semantics of a concurrent shared-memory language}
\label{fig:programs}
\end{figure*}

In Figure~\ref{fig:programs}, we give the semantics of a simple shared-memory
concurrent language as sets of pomsets.  
Each pomset
$\aPS\in\sem{\aCmd}$ represents a single execution of $\aCmd$.  We do not
expect $\sem{\aCmd}$ to be prefixed closed; thus, one may view each
$\aPS\in\sem{\aCmd}$ as a \emph{completed} execution.  However, the sets of
pomsets given by our semantics \emph{are} closed with respect to
isomorphism and augmentation.

NOTE: because augment closed, any event can go false, and we kill everything
after it, so that means we do get a kind of prefix closure.

In this paper, we are not investigating speculative execution.  So we make
the global assumption formulae can only get stronger in dependent actions:
if $\aEv<\bEv$ then
$\labellingForm(\bEv)$ implies $\labellingForm(\aEv)$.
 
\begin{definition}
  $\aPS'$ is an \emph{isomorphism} of $\aPS$ if there is a bijection
  $f:\Event\fun\Event'$ such that
  % \begin{itemize}
  % \item
  $\labelling(\aEv)=\labelling'(f(\aEv))$,
  % \item
  $\aEv\le\bEv$ iff $f(\aEv)\le'f(\bEv)$, and
  % \item
  $\aEv\gtN\bEv$ iff $f(\aEv)\gtN'f(\bEv)$.
  % \end{itemize}
\end{definition}
Augmentation may create additional order and strengthening
preconditions.
\begin{definition}
  $\aPS'$ is an augmentation of $\aPS$ if $\Event'=\Event$,
  ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
  ${\gtN}\subseteq{\gtN'}$, %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$, 
  $\labellingAct'=\labellingAct$, and %$\labellingAct'(\aEv)=\labellingAct(\aEv)$ and
  $\labellingForm'(\aEv)$ implies $\labellingForm(\aEv)$.
  % if $\labelling(\aEv) = (\bForm \mid \bAct)$ then
  % $\labelling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies
  % $\bForm$.
\end{definition}

We give the semantics using combinators over sets of pomsets, defined below.
Using $\aPSS$ to range over sets of pomsets, these are:
\begin{itemize}
\item \emph{substitution} $\aPSS\aSub$, which applies substitution $\aSub$ to
  every precondition of $\aPSS$,
\item \emph{guarding} $\aForm\guard\aPSS$, which filters $\aPSS$,
  keeping pomsets whose events have preconditions that imply $\aForm$,
\item \emph{restriction} $\nu\aLoc\st\aPSS$, which filters $\aPSS$ to include
  only pomsets where every event $\aEv$ that reads from $\aLoc$ can read from
  some $\bEv$ and where no precondition can depend on $\aLoc$,
\item \emph{composition} $\aPSS_1\parallel\aPSS_2$, which unions pomsets from
  $\aPSS_1$ and $\aPSS_2$, allowing events to be merged, and
\item \emph{prefixing} $\aAct\prefix\aPSS$, which adds an event with action
  $\aAct$ to pomsets in $\aPSS$, ordering $\aAct$ before any $\aEv$ whose predicate
  depends on the value read by $\aAct$.
\end{itemize}
These operations are similar to those from models of concurrency such
as~\cite{Brookes:1984:TCS:828.833}, but adapted here to the setting of
speculative evaluation.

%% A write generates a write event that may be visible
%% to other threads.  A read may see a
%% thread-local value, or it may generate a read event that must be justified by
%% another thread.  In the latter case, occurrences of $\aReg$ are replaced with
%% $\aLoc$ (rather than $\aVal$) to ensure that dependencies are tracked
%% properly.  The subsequent substitution of $\aVal$ for $\aLoc$ occurs in
%% Definition~\ref{def:prefix} of prefixing.

% We have completed the formal definition of our model of speculative
% evaluation, and now turn to examples.

\subsection{Substitution and Guarding} 

Substitution updates the preconditions in a pomset, thus we expect the number
of pomsets to be unchanged; in addition, the number of events in each of the
pomsets is unchanged.
\begin{definition}
  %For a substitution $\aSub$, of the form $[\aLoc/\aReg]$ or $[\bExp/\aLoc]$,
  Let $\aPSS\aSub$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \Event$,
${\le'} = {\le}$, 
${\gtN'} = {\gtN}$,
and
$\labelling'(\aEv) = (\bForm\aSub \mid \aAct)$, where $\labelling(\aEv) = (\bForm \mid \aAct)$.
% \begin{itemize}
% \item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) =
%   (\bForm\aSub \mid \aAct)$, and
% \item if $\labelling(\aEv) = (\bForm \mid \aSub)$ then $\labelling'(\aEv) = (\bForm\bSub \mid \aSub\bSub)$.
%\end{itemize}
\end{definition}

Guarding filters a set of pomsets; we have
$(\aForm\guard\aPSS)\subseteq\aPSS$.
The definition is straightforward:
\begin{definition}
Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aForm$ implies $\labellingForm(\aEv)$.
% \begin{itemize}
% \item if $\labelling(\aEv) = (\bForm \mid \aActSub)$ then $\aForm$ implies $\bForm$.
% \end{itemize}
\end{definition}

\subsection{Restriction}
\label{sec:restriction}

% Restriction also filters a set of pomsets; we have
% $(\nu\aLoc\st\aPSS)\subseteq\aPSS$.
% The definition requires that we define
% when a read is possible.

\begin{definition}\label{def:rf}
  In a pomset, $\aEv$ \emph{can read $\aLoc$ from} $\bEv$ whenever: 
  \begin{itemize}
  \item $\bEv < \aEv$,  
  \item $\aEv$ implies $\bEv$,
  \item $\bEv$ writes $\aVal$ to $\aLoc$,
    and $\aEv$ reads $\aVal$ from $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}
\end{definition}


\begin{definition}
\label{def:x-closed}
A pomset is $\aLoc$-closed if, for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads $\aLoc$, then there is some $\bEv$ such that $\aEv$
    can read $\aLoc$ from $\bEv$,
  \item if $\aEv$ writes $\aLoc$, then either $\aEv$ is a fence or there is
    some $\bEv$ such that $\bEv$ can read $\aLoc$ from $\aEv$.
  \end{itemize}
\end{definition}
% Our model of reads-from is strong, and could be weakened by replacing the
% requirement $\bEv<\aEv$ % in Definition~\ref{def:rf}
% by $\bEv\gtN\aEv$. It remains to be seen how this impacts the model.

% \begin{definition}
%   A 3-valued pomset is $\aLoc$-\emph{coherent}
%   if, when restricted to events which touch $\aLoc$,
%   $\gtN$ forms a total order.
% \end{definition}

We say that $\aPS' = \aPS\restrict{\Event'}$ when 
 $\Event' \subseteq \Event$,
 ${\labelling'} = {\labelling}\restrict{\Event'}$, 
 ${\le'} = {\le}\restrict{\Event'}$, and
 ${\gtN'} = {\gtN}\restrict{\Event'}$.

\begin{definition}
  Let $(\nu\aLoc\st\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$
  whenever there is $\aPS\in\aPSS$ such that $\aPS' = \aPS\restrict{\Event'}$
  and $\aPS'$ is $\aLoc$-closed.
  % Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
  % \begin{itemize}
  % \item $\aEv$ is independent of $\aLoc$, and
  % \item if $\aEv$ reads $\aLoc$, then there is some $\bEv$ such that $\aEv$ can read $\aLoc$ from $\bEv$.
  % \end{itemize}
\end{definition}
This definition throws away useless writes.
I don't think we need coherence any more.

\subsection{Composition}
Composition is used in giving the semantics for conditionals and concurrency.
$\aPSS_1 \parallel \aPSS_2$ contains the union of pomsets from $\aPSS_1$ and
$\aPSS_2$, allowing overlap as long as they agree on actions. For example, if
$\aPSS_1$ and $\aPSS_2$ contain:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \mid \bAct}{right=of a}
  \po{a}{b}
\end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm_2 \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \wk{b}{c}
\end{tikzpicture}\]
then $\aPSS_1 \parallel \aPSS_2$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{a}{b}
  \wk{b}{c}
\end{tikzpicture}\]

\begin{definition}
Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
whenever there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that:
\begin{itemize}
\item $\Event' = \Event^1 \cup \Event^2$,
\item ${\le'}\supseteq{\le^1}\cup{\le^2}$, %if $\aEv \le^1 \bEv$ or $\aEv \le^2 \bEv$ then $\aEv \le' \bEv$,
\item ${\gtN'}\supseteq{\gtN^1}\cup{\gtN^2}$, %if $\aEv \gtN^1 \bEv$ or $\aEv \gtN^2 \bEv$ then $\aEv \gtN' \bEv$,
% \item if $\labelling'(\aEv) = (\aForm' \mid \aAct)$ then either:
%   \begin{itemize}
%   \item $\labelling^1(\aEv) = (\aForm^1 \mid \aAct)$ and $\labelling^2(\aEv) = (\aForm^2 \mid \aAct)$
%     and $\aForm'$ implies $\aForm^1 \lor \aForm^2$,
%   \item $\labelling^1(\aEv) = (\aForm^1 \mid \aAct)$ and $\aEv \not\in \Event^2$
%     and $\aForm'$ implies $\aForm^1$, or
%   \item $\labelling^2(\aEv) = (\aForm^2 \mid \aAct)$ and $\aEv \not\in \Event^1$
%     and $\aForm'$ implies $\aForm^2$.
%   \end{itemize}
\item Either
  % \begin{gather*}
  %   \labellingAct'(\aEv) = \labellingAct^1(\aEv) = \labellingAct^2(\aEv) \textand \labellingForm'(\aEv) \textimplies \labellingForm^1(\aEv) \lor \labellingForm^2(\aEv),\\
  %   \aEv \not\in \Event^2,\; \labellingAct'(\aEv) = \labellingAct^1(\aEv) \textand \labellingForm'(\aEv) \textimplies \labellingForm^1(\aEv),\; \textor\\    
  %   \aEv \not\in \Event^1,\; \labellingAct'(\aEv) = \labellingAct^2(\aEv) \textand \labellingForm'(\aEv) \textimplies \labellingForm^2(\aEv).
  % \end{gather*}
  \begin{itemize}
  \item $\labellingAct'(\aEv) = \labellingAct^1(\aEv) = \labellingAct^2(\aEv)
    \textand \labellingForm'(\aEv) \textimplies \labellingForm^1(\aEv) \lor \labellingForm^2(\aEv)$,
  \item $\labellingAct'(\aEv) = \labellingAct^1(\aEv),\;\; \aEv \not\in \Event^2\,
    \textand \labellingForm'(\aEv) \textimplies \labellingForm^1(\aEv),\; \textor$
  \item $\labellingAct'(\aEv) = \labellingAct^2(\aEv),\;\; \aEv \not\in \Event^1\,
    \textand \labellingForm'(\aEv) \textimplies \labellingForm^2(\aEv)$.
  \end{itemize}
\end{itemize}
\end{definition}
% We use $\aPSS_1 \parallel \aPSS_2$ in defining the semantics of conditionals
% and concurrency.
% It contains the union of pomsets from $\aPSS_1$ and $\aPSS_2$,
% allowing overlap as long as they agree on actions. For example, if
% $\aPSS_1$ and $\aPSS_2$ contain:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \mid \bAct}{right=of a}
%   \po{a}{b}
% \end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
%   \event{b}{\bForm_2 \mid \bAct}{}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \wk{b}{c}
% \end{tikzpicture}\]
% then $\aPSS_1 \parallel \aPSS_2$ contains:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \wk{b}{c}
% \end{tikzpicture}\]


\subsection{Prefixing}
Prefixing is used in giving the semantics of reads and writes.
$\aAct\prefix\aPSS$ adds a new event $\cEv$ with action $\aAct$ to each
pomset in $\aPSS$.  As in the definition of parallel composition, the
definition allows the new event to overlap with events in $\aPSS$ as long as
they agree on the action.

If $\cEv$ writes to a location that is also written by $\aEv$ in $\aPSS$,
then prefixing introduces weak order between them: $\aEv \gtN \cEv$.  This
ensures that these writes cannot be given the reverse order in an augmentation.

If $\cEv$ reads from a location that occurs in the predicate of $\aEv$, then
prefixing introduces order from $\cEv$ to $\aEv$.
whose predicate depends on $\aLoc$. 
For example, if $\aAct$ and $\bAct$ write to the same location, $\aAct$ reads
$\aVal$ from $\aLoc$, $\bForm$ is independent of $\aLoc$, and $\aPSS$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{b}{c}
\end{tikzpicture}\]
then $\aAct\prefix\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm \mid \bAct}{right=of a}
  \event{c}{\cForm[\vec\aVal/\vec\aLoc] \mid \cAct}{right=of b}
  \po[out=25,in=155]{a}{c}
  \wk{a}{b}
  \po{b}{c}
\end{tikzpicture}\]

% We say $\aEv$ \emph{depends on} $\cEv$ if
% $\labelling(\aEv) = (\bForm \mid \dontcare)$,
% $\labelling(\cEv) = (\dontcare \mid \aSub)$,
% and $\bForm$ depends on $\aSub$.

% We say $\aEv$ \emph{conflicts with}  $\bEv$ if
% $\labelling(\aEv) = (\dontcare \mid \aAct)$,
% $\labelling(\cEv) = (\dontcare \mid \bAct)$,
% $\aAct$ and $\bAct$ touch the same location, and either
% $\aAct$ or $\bAct$ is a write.

\begin{definition}
  \label{def:prefix}
Let $\aAct \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{\cEv\}$,
\item ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item ${\gtN'}\supseteq{\gtN}$, %if $\aEv \gtN \bEv$ then $\aEv \gtN' \bEv$,
% \item $\labellingAct'(\cEv) = \aAct$, 
% \item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then $\labelling'(\aEv) =
%   (\bForm' \mid \bAct)$, where:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire then $\bForm'$ is independent of every $\bLoc$,
%   \item if $\aAct$ does not read then $\bForm'$ implies $\bForm$,
%   \item if $\aAct$ reads then $\aVal$ from $\aLoc$ then
%     \begin{itemize}
%     \item $\bForm'$ implies $\bForm[\aVal/\aLoc]$, and
%     \item either $\bForm'$ implies $\bForm$ or $\cEv<'\aEv$, 
%     \end{itemize}
%   \end{itemize}
% \item if $\labellingAct(\aEv) = \bAct$ then:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire or $\bAct$ is a release then $\cEv <' \aEv$, 
%   \item if $\aAct$ and $\bAct$ both touch the same location and one is a write,
%     then $\cEv \gtN' \aEv$, and
%   \end{itemize}
\item $\labellingAct'(\aEv) = \labellingAct'(\aEv)$ unless $\aEv=\cEv$.   $\labellingAct'(\cEv) = \aAct$, 
\item if $\aAct$ does not read then $\labellingForm'(\aEv)$ implies $\labellingForm(\aEv)$,
\item if $\aAct$ reads then $\aVal$ from $\aLoc$ then
  \begin{itemize}
  \item $\labellingForm'(\aEv)$ implies $\labellingForm(\aEv)[\aVal/\aLoc]$, and
  \item either $\labellingForm'(\aEv)$ implies $\labellingForm(\aEv)$ or $\cEv<'\aEv$, 
  \end{itemize}
\item if $\aAct$ is an acquire then $\labellingForm'(\aEv)$ is independent of every $\bLoc$,
\item if $\aAct$ is an acquire or $\labellingAct(\aEv)$ is a release then $\cEv <' \aEv$, 
\item if $\aAct$ and $\labellingAct(\aEv)$ both touch the same location and one is a write,
    then $\cEv \gtN' \aEv$, and
\item if $\aAct$ is a pure read (not acquire or release), then either
  $\labellingForm'(\cEv)$ is unsatisfiable or there is some $\aEv$ such
  that $\labellingForm'(\aEv)$ does not imply $\labellingForm(\aEv)$.
% \item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then $\labelling'(\aEv) =
%   (\bForm' \mid \bAct)$, where:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire or $\bAct$ is a release then $\cEv <' \aEv$, 
%   \item if $\aAct$ is an acquire then $\bForm$ is independent of every $\bLoc$,
%   \item if $\aAct$ and $\bAct$ both touch the same location and one is a write,
%     then $\cEv \gtN' \aEv$, and
%   \item $\bForm'$ implies \(\left\{\begin{array}{l@{~}ll}
%     % \bForm[\aVal/\aLoc]                     & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} & \textsc{[dependent read]} \\
%     % \bForm[\aVal/\aLoc] \text{ and } \bForm & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  & \textsc{[independent read]} \\
%     % \bForm                                  & \mbox{otherwise}                                              & \textsc{[non-read]} \\        
%     \bForm[\aVal/\aLoc]                     \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} \\\qquad \textsc{[dependent read]} \\[\jot]
%     \bForm[\aVal/\aLoc] \text{ and } \bForm \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  \\\qquad \textsc{[independent read]} \\[\jot]
%     \bForm                                  \\\quad \mbox{otherwise}                                              \\\qquad \textsc{[non-read]} \\
%   \end{array}\right.\)
%   \end{itemize}
\end{itemize}
\end{definition}
The last condition ensures that useless reads are not included.
Otherwise, $\labellingForm'(\cEv)$ is unconstrained.

In order to keep augmentation closure, we need to keep the unsatisfiable
elements in the set of pomsets.


\begin{comment}
The first constraint ensures that events are ordered before a release and
after an acquire.  The second constraint ensures that thread-local reads do
not cross acquire fences.
 
The second constraint prevents bad executions like the following:
   x=1; rel; acq; if (x) {y=1};  ||  acq; x=0; rel; 
where the second thread is interleaved between the rel and acq of the first.

Note that you cannot require that $\bForm'$ is independent of every $\bLoc$
because then it's not augment closed.
\end{comment}

\subsection{Sequential stuff}

Definitions of $\fpo$ can be done by just modifying the definition of
prefixing.
\begin{itemize}
\item $\fpo(\aPSS\aSub)=\fpo(\aPSS)$
\item $\fpo(\aForm\guard\aPSS)=\fpo(\aPSS)$
\item $\fpo(\nu\aLoc\st\aPSS)=\fpo(\aPSS)$
\item $\fpo(\aPSS_1\parallel\aPSS_2)=\fpo(\aPSS_1)\cup\fpo(\aPSS_2)$
\item $\fpo(\aAct\prefix\aPSS)$ just adds the new event to $\fpo(\aPSS)$
\end{itemize}
$\fird$ (internal read dependency) is more complicated.
We need to change the rules
\begin{eqnarray*}
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]\bigr) \\
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]\bigr) 
\end{eqnarray*}
to
\begin{eqnarray*}
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DW\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] \\
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] 
\end{eqnarray*}
so that prefixing can talk about occurrences of $\aLoc$ in $\sem{\aCmd}$.
Then you get an $\fird$ from the new event $\cEv$ to an old event $\aEv$ if
$\labellingForm(\aEv)$ is dependent on $\aLoc$ (ie, it is \emph{not} independent).

% To see that we need $[\aExp/\aLoc]$ in the rule for write, rather than $[\aVal/\aLoc]$
% consider example:
% \begin{verbatim}
% r=y; if (r) {x=r} else {x=r}; s=x; if (r==s) {z=1}
% \end{verbatim}
% or simplified:
% \begin{verbatim}
% r=y;x=r;s=x; if(s==r){z=1}
% \end{verbatim}
% If you read 37 for $y$, then the predicate on \texttt{Wz1} before the
% read is either $r=r$ or $v=r$, where $v=37$, for example.  In one case you
% get a dependency and in the other you do not.

\subsection{Example}

An example to show that we need $[\aExp/\aLoc]$ in the rule for write, rather
than $[\aVal/\aLoc]$:

$\sem{\IF(\bReg\EQ\aReg)\THEN \cLoc\GETS 1\FI}$
includes
\[\begin{tikzpicture}[node distance=1em]
  \event{c}{\bReg=\aReg \mid \DW\cLoc1}{}
\end{tikzpicture}\]
therefore
$\sem{\bReg\GETS\aLoc\SEMI\IF(\bReg\EQ\aReg)\THEN \cLoc\GETS 1\FI}$
includes
\[\begin{tikzpicture}[node distance=1em]
  \event{c}{\aLoc=\aReg \mid \DW\cLoc1}{}
\end{tikzpicture}\]
and
$\sem{\aLoc\GETS\aReg\SEMI\bReg\GETS\aLoc\SEMI\IF(\bReg\EQ\aReg)\THEN \cLoc\GETS 1\FI}$
includes
\[\begin{tikzpicture}[node distance=1em]
  \event{c}{\aReg=\aReg \mid \DW\cLoc1}{}
\end{tikzpicture}\]
which is independent of $\aReg$.

If we took the semantics of write to use $[\aVal/\aLoc]$, then we would end
up with pomsets of the form
\[\begin{tikzpicture}[node distance=1em]
  \event{c}{\aVal=\aReg \mid \DW\cLoc1}{}
\end{tikzpicture}\]
which depend on $\aReg$.

To see why we don't mention dependency in sequential composition, consider
$\sem{\IF(\aReg\leq1)\THEN \aLoc\GETS 2\FI}$ which includes
\[\begin{tikzpicture}[node distance=1em]
  \event{c}{\aReg\leq1 \mid \DW\aLoc2}{}
\end{tikzpicture}\]
which depends on $\aReg$.

$\sem{\aReg\GETS\bLoc\SEMI\IF(\aReg\leq1)\THEN \aLoc\GETS 2\FI}$ includes
\[\begin{tikzpicture}[node distance=1em]
    \event{b}{\DR\bLoc1}{}
    \event{c}{\bLoc\leq1 \mid \DW\aLoc2}{right=of b}
\end{tikzpicture}\]
which has no dependency between the read and write.

$\sem{\bLoc\GETS0\SEMI\aReg\GETS\bLoc\SEMI\IF(\aReg\leq1)\THEN \aLoc\GETS
  2\FI}$ discharges the precondition of the write, giving
\[\begin{tikzpicture}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{0\leq1 \mid \DW\aLoc2}{right=of b}
\end{tikzpicture}\]
which is simply:
\[\begin{tikzpicture}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
\end{tikzpicture}\]
The semantics of this program also includes
\[\begin{tikzpicture}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{c}{\DW\aLoc2}{right=of a}
\end{tikzpicture}\]

A variant of this which indicates the branch taken:
$\sem{\bLoc\GETS0\SEMI\aReg\GETS\bLoc\SEMI\IF(\aReg\leq1)\THEN
  \aLoc\GETS2\SEMI\cLoc\GETS\aReg\FI}$
includes
\[\begin{tikzpicture}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
    \event{d}{\DW\cLoc1}{right=of c}
    \po[bend left]{b}{d}
\end{tikzpicture}\]

A program to witness this is
\begin{displaymath}
  \IF(\bLoc\EQ0)\THEN
    \IF(\aLoc\EQ2)\THEN
      \bLoc\GETS1\SEMI
      \IF(\cLoc\EQ1)\THEN\PASS\FI
    \FI
  \FI
\end{displaymath}

Putting these in parallel gives you
\[\begin{tikzpicture}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
    \event{d}{\DW\cLoc1}{right=of c}
    \po[bend left]{b}{d}
    \event{a2}{\DR\bLoc0}{below=of a}
    \event{b2}{\DR\aLoc2}{right=of a2}
    \event{c2}{\DW\bLoc1}{right=of b2}
    \event{d2}{\DR\cLoc1}{right=of c2}
    \po{a2}{b2}
    \po{b2}{c2}
    \po[bend right]{b2}{d2}
    \rf{a}{a2}
    \rf{c}{b2}
    \rf{c2}{b}
    \rf{d}{d2}
\end{tikzpicture}\]


% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
