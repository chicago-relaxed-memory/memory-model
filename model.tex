\section{The Model}
\label{sec:model}

We define the model and give the semantics of a concurrent language.  We
layer the presentation, beginning with a simple language that supports only
read and write operations.  In \textsection\ref{sec:variants}, we define
extensions that incorporate address computation, fences, and
read-modify-write operations.  
\begin{comment}
https://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/

Cannot encode R/A actions with actions+fences...

A release operation prevents preceding memory operations from being delayed
past it (a;Rel =/=> Rel;a)
 
A release fence prevents preceding memory operations from being delayed past
subsequent writes (a;FR;w =/=> w;a;FR)

An acquire operation prevents subsequent memory operations from being advanced
before it (Acq;a =/=> a;Acq)

An acquire fence prevents subsequent memory operations from being advanced
before prior reads (r;FA;a =/=> FA;a;r)

https://www.modernescpp.com/index.php/fences-as-memory-barriers

StoreLoad: Full fence allows a store before to be reordered with respect to a
load after (wx;F;ry) ===> (ry;F;wx)

StoreLoad+LoadLoad: Release fence also allows (rx;FR;ry) ===> (ry;FR;rx)

StoreLoad+StoreStore: Acquire fence also allows (wx;FR;wy) ===> (wy;FR;wx)

LoadStore: No fence allows a prior load to reorder w.r.t. a subsequent store
(rx;FR;wy) =/=> (wy;FR;rx)

https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/
Good news is that a fullFence does it.

Bizarrely, it seems this is not supported in C++... You have to go to assembly.
\end{comment}

The model is based on \emph{partially ordered multisets}~\cite{???},
where events are labelled with reads and writes, and
the partial order tracks control and data dependencies, coherence, concurrent reads and writes using shared memory, and fencing.
Here, we are only using one order, which stands in stark contrast with
other models that use many different relations.

For example the semantics of \ref{OOTA?} (including explicit initialization with zero, and explicit $\DSTOP$ to indicate termination)
contains the expected pomset

\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{below=1ex of wx0}
  \event{rx0}{\DR{x}{0}}{right=3em of wx0}
  \event{wy0a}{\DW{y}{0}}{right=of rx0}
  \event{ry0}{\DR{y}{0}}{right=3em of wy0a}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{stop}{\DSTOP}{right=of wx1}
  \rf{wx0}{rx0}
  \rf{wy0a}{ry0}
  \wk[out=20,in=160]{rx0}{wx1}
  \wk[out=0,in=200]{wy0}{wy0a}
  \po{rx0}{wy0a}
  \sync{wx1}{stop}
  \sync[out=30,in=150]{ry0}{stop}
\end{tikzdisplay}
but also the unexpected one

\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{below=1ex of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{a}{1}}{right=of wx1}
  \event{stop}{\DSTOP}{right=of wa1}
  \rf[out=200,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=20,in=160]{wx0}{wx1}
  \wk[out=0,in=200]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wa1}
  \sync[out=30,in=150]{wx1}{stop}
  \sync{wa1}{stop}
\end{tikzdisplay}

We stress that in these diagrams, color plays no formal role, it is purely to help the reader see where the
order comes from. For instance:
\begin{itemize}

\item $(\DW{x}{0})\xwk(\DW{x}{1})$ is a \emph{coherence} requirement: the write of $1$
  must follow the write of $0$, since these are to the same location.

\item $(\DW{x}{1})\xrf(\DR{x}{1})$ is a \emph{reads-from} requirement: the read of $x$
  is fulfilled by a matching write from another thread.

\item $(\DR{x}{1})\xpo(\DW{y}{1})$ is a \emph{dependency} requirement: the write to $y$
  \emph{depends on} the read of $x$.

\item $(\DWRel{z}{1})\xsync(\DSTOP)$ is a \emph{fencing} requirement (in this case the fence is at the end of the program,
  but concurrency controls introduce fencing).

\end{itemize}

The interesting fact about these pomsets is that there is no control dependency between
reading $y$ and writing $x$, since the $(\DW{x}{1})$ event happens on both sides of the conditional.
Compare this with \ref{OOTA!}, where there is a control dependency:

\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{below=1ex of wx0}
  \event{rx0}{\DR{x}{0}}{right=3em of wx0}
  \event{wy0a}{\DW{y}{0}}{right=of rx0}
  \event{ry0}{\DR{y}{0}}{right=3em of wy0a}
  \event{wx2}{\DW{x}{2}}{right=of ry0}
  \event{stop}{\DSTOP}{right=of wx2}
  \rf{wx0}{rx0}
  \rf{wy0a}{ry0}
  \wk[out=20,in=160]{rx0}{wx2}
  \wk[out=0,in=200]{wy0}{wy0a}
  \po{rx0}{wy0a}
  \po{ry0}{wx2}
  \sync{wx2}{stop}
  \sync[out=30,in=150]{ry0}{stop}
\end{tikzdisplay}
and so an attempt to replicate the unexpected execution from~\ref{OOTA?} fails,
since it introduces a cycle in the order:


\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{below=1ex of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=3em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wa1}{\DW{a}{1}}{right=of wx1}
  \event{stop}{\DSTOP}{right=of wa1}
  \rf[out=200,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=20,in=160]{wx0}{wx1}
  \wk[out=0,in=200]{wy0}{wy1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wa1}
  \po{ry1}{wx1}
  \sync[out=30,in=150]{wx1}{stop}
  \sync{wa1}{stop}
\end{tikzdisplay}

This model is based on that of~\cite{us}, though missing the features designed to capture
speculative execution attacks. We will present the model in this section,
but readers familiar with or earlier work can skip ahead.

\subsection{Data models}
A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\cVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$, and $\cExp$, % and $\dExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by $\aLoc$ and
  $\bLoc$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$, and
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$.
\end{itemize}

Let $\aSub$ range over substitutions of the form
$[\aLoc/\aReg]$ or $[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item values, registers, and memory locations are disjoint,
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
%\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations, % or the operator $\REF{\aExp}$,
\item formulae include at least %$\TRUE$, $\FALSE$, and
  equalities %of the form
  $(\aExp=\aVal)$, % and $(\REF{\aExp}=\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution\footnote{Since formulae are closed under substitutions of the
    form $\aForm[\aLoc/\aReg]$, they must include equalities of the form
    $(\aEExp=\aVal)$ where $\aEExp$ is an \emph{extended expression} that
    includes memory locations.  By composition, formulae must also be closed
    under that substitutions of the form
    $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.}, and
\item there is a relation $\vDash$ between formulae.
\end{itemize}

We use expressions as formulae, coercing $\aExp$ to $\aExp\neq 0$.

For the actions of a data model, we require that
% \begin{itemize}
% \item
  there are partial functions $\rreads$ and
  $\rwrites: \Act \fun (\Loc \times \Val)$, and
%\item
  there are subsets of $\Act$: $\Acq$, $\Rel$, $\SC$, and $\Term$.
  % such that
  % $\SC\cap\fdom(\rreads)\subseteq\Acq$,
  % $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
  % and
  % $\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.
  % , and
% \item there is a function $\finternalize: \Act \fun \Act$ that
%   satisfies the restrictions given below.
%\end{itemize}

% $\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes to}
% $\aLoc$ when $\rwrites(\aAct) = (\aLoc,\aVal)$, for some $\aVal$. % (possibly $\bot$).
%
% Actions that read or write values are \emph{external},
% actions that read or write $\bot$ are \emph{internal}.
% % Actions in
% % $\Ext=\fdom(\rreads)\cup\fdom(\rwrites)$ are \emph{external}, whereas those
% % in $\Int=\Act\setminus\Ext$ are \emph{internal}.
%
  We say that $\aAct$ is a \emph{read} if $\aAct\in\fdom(\rreads)$ and
  $\aAct$ is a \emph{write} if $\aAct\in\fdom(\rwrites)$.  When
  $\rreads(\aAct) = (\aLoc,\aVal)$, we say that $\aAct$ \emph{reads} $\aVal$
  \emph{from} $\aLoc$, and similarly for writes.

  Actions in $\Acq$, $\Rel$ and $\SC$, are \emph{synchronization} and
  \emph{fencing} actions.  We say that $\aAct$ is an \emph{acquire} if
  $\aAct\in\Acq$, $\aAct$ is a \emph{release} if $\aAct\in\Rel$, and $\aAct$
  is \emph{SC} if $\aAct\in\SC$.
  We require that every SC read is an acquire, and every SC write is a release.
  % Note that these are \emph{not}
  % disjoint.
% % We say that $\aAct$ is a
% % \emph{synchronization} if it is either a release or an acquire.

% $\SC\cap\fdom(\rreads)\subseteq\Acq$,
% $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
% and
  Actions in $\Term$ are \emph{termination} actions. We require that
  termination events are releasing.
%$\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.


% The actions listed above are \emph{external}.  Each external action has a
% corresponding \emph{internal} action, denoted by prefixing $\tau$.  Internal
% actions also read and write locations, just as external actions do,
% but are not used to model communication between threads,
% so we do not record their value.
% \footnote{Fences have a limited role in our
% discussion.  We inappropriately refer to them as synchronizations for
% simplicity.}.


Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.  Formulae are \emph{open}, in that
occurrences of register names and memory locations are subject to
substitutions of the form $\aForm[\aLoc/\aReg]$ and $\aForm[\bExp/\aLoc]$.
% where %$\aLoc$ is a memory location, $\aReg$ is a register and
% $\bExp$ is an
% memory-location-free expression.
Actions are not subject to substitution.


% % We require that $\finternalize$ satisfy the following:
% % \begin{itemize}
% % \item $\finternalize(\aAct)$ reads $\bot$ from $\aLoc$ exactly when $\aAct$ reads from $\aLoc$,
% % \item $\finternalize(\aAct)$ writes $\bot$ to $\aLoc$ exactly when $\aAct$ writes to $\aLoc$,
% % %\item the codomain of $\finternalize$ includes only internal actions, %$\fcodom(\finternalize)\subseteq\Int$,
% % \item $\finternalize(\aAct)$ is an acquire exactly when $\aAct$ is an acquire, 
% % \item $\finternalize(\aAct)$ is a release exactly when $\aAct$ is a release, and
% % \item $\finternalize(\aAct)$ is SC exactly when $\aAct$ is SC. 
% % \end{itemize}

% As noted in \textsection\ref{sec:model:intro}, our example language includes
% SC read $(\DRSC{\aLoc}{\aVal})$, acquiring
% read $(\DRAcq{\aLoc}{\aVal})$, relaxed read $(\DR{\aLoc}{\aVal})$, SC write
% $(\DWSC{\aLoc}{\aVal})$, releasing
% write $(\DWRel{\aLoc}{\aVal})$, and relaxed write $(\DW{\aLoc}{\aVal})$.
% For each external action, we also define a corresponding internal action
% %which replaces the letter $\mathsf{R}$ or $\mathsf{W}$ with $\tau$.
% $(\iDRSC{\aLoc}{\aVal})$,
% $(\iDRAcq{\aLoc}{\aVal})$,
% $(\iDR{\aLoc}{\aVal})$,
% $(\iDWSC{\aLoc}{\aVal})$,
% $(\iDWRel{\aLoc}{\aVal})$, and
% $(\iDW{\aLoc}{\aVal})$.
% In pictures, we draw internal actions grayed out,
% rather than using $\bot$.  % For example, the ``read'' action is internal in:
% % \begin{tikzdisplay}[node distance=1em]
% %   \event{wx1}{\DW{x}{1}}{}
% %   \internal{rx1}{\DR{x}{1}}{below right=of rx1}
% %   \event{wy1}{\DW{y}{1}}{above right=of wy0}
% %   \po{wx1}{wy1}
% % \end{tikzdisplay}

%We also include acquire-release fences of the form $(\DF)$.

% In examples, we use fence actions of the form $(\DF{\aF})$, where the annotation
% indicates that the fence is a release ($\FR$), an acquire ($\FA$) or both ($\FF$):
% \begin{displaymath}
%   \aF\BNFDEF\FR\BNFSEP\FA\BNFSEP\FF
% \end{displaymath}

% \subsection{3-valued pomsets with preconditions}

% Fix an alphabet $\Alphabet=(\Formulae\times\Act)$.

For the formulae of the data model,
we say that $\aForm$ is \emph{independent of $\aLoc$} when, for every $\aVal$,
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$. We say that
$\aForm$ is \emph{dependent on $\aLoc$} otherwise.  We say that $\aForm$ is
\emph{location independent} if it is independent of every location.

We say that $\aForm$ \emph{implies} $\bForm$ when $\aForm\vDash\bForm$,
that $\aForm$ is a \emph{tautology} when $\TRUE\vDash\aForm$, and that
$\aForm$ is \emph{unsatisfiable} when $\aForm\vDash\FALSE$.

\subsection{Example Language}
Our example language includes actions of the form
$(\DSTOP)$, which is a \emph{termination},
$(\DR[\amode]{\aLoc}{\aVal})$, which \emph{reads}  $\aVal$ from
$\aLoc$ and $(\DW[\amode]{\aLoc}{\aVal})$, which \emph{writes} $\aVal$ to
$\aLoc$.
% The \emph{mode} $\amode$ is either \emph{relaxed} ($\modeRLX$),
% \emph{release-acquire} ($\modeRA$) or \emph{sequentially-consistent} ($\modeSC$).
The \emph{access mode} $(\amode \!\!\BNFDEF\!\! \modeRLX \!\BNFSEP\! \modeRA \!\BNFSEP\! \modeSC)$ is
either \emph{relaxed}, \emph{release-acquire}, or
\emph{sequentially-consistent}.
$\modeRA$/$\modeSC$ reads are acquires, and $\modeRA$/$\modeSC$ writes are releases.
We elide the $\modeRLX$-mode annotation in examples.
(Note that C-style \emph{plain} access is the same as relaxed access for race-free 
programs; for racy programs, plain access results in undefined behavior.)
% We write $\modeREL$ and $\modeACQ$ as synonyms for $\modeRA$.
\begin{comment}
\footnote{We only consider executions where register state is empty in
  forked threads.  Given item~\ref{pre-acquire} of
  Definition~\ref{def:prefix}, a sufficient condition is that parallel
  composition is always preceded by an acquire fence, as in programs of the
  form:
  \begin{displaymath}
    \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
  \end{displaymath}
  where $\aCmd^1$, \ldots, $\aCmd^n$ do not include $\PAR$.  To avoid clutter
  in drawings, we often drop the explicit fence.}.
\end{comment}
% \begin{align*}
% \aCmd,\,\bCmd
% \BNFDEF& \SKIP \tag{No Operation}
% \\[-1ex]\BNFSEP& \FENCE\SEMI \aCmd \tag{Full fence}
% \\[-1ex]\BNFSEP& \REF{\cExp}\GETS\aExp\SEMI \aCmd \tag{Relaxed write to memory}
% \\[-1ex]\BNFSEP& \REF{\cExp}\REL\GETS\aExp\SEMI \aCmd \tag{Releasing write to memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\SEMI \aCmd \tag{Relaxed read from memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\ACQ\SEMI \aCmd
% \\[-1ex]\BNFSEP& \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
% \\[-1ex]\BNFSEP& \aCmd \PAR \bCmd
% \\[-1ex]\BNFSEP& \VAR\aLoc\SEMI \aCmd
% \end{align*}
%The syntax of statements is as follows.


We define the language by prefixing individual reads and writes.  % In
% \textsection\ref{sec:semicolon} we provide an equivalent semantics that supports
% full sequential composition of the form $(\aCmd\SEMI\bCmd)$.
\begin{align*}
  % \amode \BNFDEF& \modeRLX \BNFSEP \modeRA \BNFSEP \modeSC
  % \\
\aCmd,\,\bCmd
\BNFDEF& \SKIP
\BNFSEP \aReg\GETS\aExp\SEMI \aCmd
\BNFSEP \aReg\GETS\aLoc^{\amode}\SEMI \aCmd 
\BNFSEP \aLoc^{\amode}\GETS\aExp\SEMI \aCmd
\\[-.5ex]
\BNFSEP&\aCmd \PAR \bCmd
\BNFSEP \VAR\aLoc\SEMI \aCmd
\BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\end{align*}




We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.

We write
$\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$ and
$\IF{\aExp} \THEN \aCmd^1 \ELSE \aCmd^2 \FI \SEMI \bCmd$ as shorthand for
$\IF{\aExp} \THEN \aCmd^1 \SEMI \bCmd\ELSE \aCmd^2 \SEMI \bCmd\FI$.
% and
% $\VAR\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for
% $\VAR\aLoc\SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\REL\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\FENCE_{\FR} \SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\ACQ\aReg\GETS\aLoc\SEMI \aCmd$ as shorthand for $\aReg\GETS\aLoc\SEMI \FENCE_{\FA}\SEMI \aCmd$.



\subsection{Semantic domain}
We model \emph{executions} as \emph{completed pomsets with preconditions},
ranged over by $\aPS$.  We call these \emph{pomsets}, for short.  These
extend the well-known model of partially ordered
multisets~\cite{GISCHER1988199} with formulae and a termination event.
We model \emph{programs} (notation $\sem{\aCmd}$) as \emph{sets} of completed pomsets with
preconditions, ranged over by $\aPSS$.

The pomset order relation, $\le$, represents \emph{causality}.  We visualize
pomsets as directed graphs.  For example, the semantics of
\begin{math}
  \VAR\aLoc\SEMI(
  x\GETS 0
  \SEMI
  x\GETS 1
  \PAR
  y\GETS x
  \SEMI
  z^\modeRA\GETS 1
  )
  %\aReg\GETS x\SEMI y\GETS \aReg)
\end{math}
includes:
\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{wz1}{\DWRel{z}{1}}{right=of wy1}
  \event{stop}{\DSTOP}{right=of wz1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \po{rx1}{wy1}
  \sync{wy1}{wz1}
  \sync{wz1}{stop}
\end{tikzdisplay}
We visualize order using arrows that indicate the reason that the order
arises.
$(\DW{x}{0})\xwk(\DW{x}{1})$ is a \emph{coherence} requirement: the write of $1$
must follow the write of $0$, since these are in \emph{conflict} and in program order.
$(\DW{x}{1})\xrf(\DR{x}{1})$ is a \emph{reads-from} requirement: the read of $x$
must be \emph{fulfilled} by a matching write.
$(\DR{x}{1})\xpo(\DW{y}{1})$ is a \emph{dependency} requirement: the write to $y$
\emph{depends on} the read of $x$.
$(\DW{y}{1})\xsync(\DWRel{z}{1})$ and $(\DWRel{z}{1})\xsync(\DSTOP)$ are
\emph{fencing} requirements.


Although we use multiple arrows, we emphasize that they are all part
of the same $\le$ relation.

A pomset is \emph{completed} if it contains a unique termination action,
ordered after all other events.  Henceforth, we will elide this uninteresting
termination event in drawings.


\textcolor{red}{Preconditions are introduced by write actions and
  conditionals.  They are satisfied by substitutions generated by lets and read and write actions.}
The \emph{preconditions} associated with events provide a \emph{sequential
  requirement} for the event to execute.  For example, the following commands
gives rise to the pomset below them.
\begin{align}
  \label{ex-1}
  \begin{gathered}
    y\GETS r
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r=1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r<0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align}
The pomsets on the left says that $y\GETS r$ can produce the action
$\DW{y}{1}$ if $r=1$, capturing the \emph{data dependency} between register
$r$ and location $y$.  The pomsets on the right says that
$\IF{r<0}\THEN y\GETS1 \FI$ can produce the action $\DW{y}{1}$ if $r<0$,
capturing the \emph{control dependency} between $r$ and $y$.

Pomsets are subject to two \emph{top-level} restrictions: Every read must be
\emph{fulfilled}, and every precondition must be \emph{satisfied}.  Reads are
fulfilled by writes, which may be concurrent (Definition \ref{def:rf}).
Preconditions can only be satisfied by substitutions, which can only derive
from prefixing in the same thread (Definition \ref{def:prefix}).  Thus reads
give rise to \emph{inter-thread} dependencies, whereas preconditions give
rise to \emph{intra-thread} dependencies.  

There is a mapping between Hoare triples $\hoare{\aForm}{\aCmd}{\bForm}$ and
the pomsets of $\aCmd$.  The postcondition $\bForm$ represents a set of write
actions, and $\aForm$ represents their preconditions.
% Each write in a pomset corresponds to a Hoare triple, where the formulae
% gives the precondition, and the write action gives the postcondition.  
For example, interpreting the pomset on the left this way yields the valid
Hoare triple $\hoare{\aReg =1}{y\GETS \aReg}{y=1}$.

Each pomset represents a single execution.  Thus we require that all
preconditions are \emph{consistent}.  For example, the semantics of
$\IF{r<0}\THEN y\GETS1 \ELSE z\GETS1\FI$ includes pomsets with either
$(r<0\mid\DW{y}{1})$ or $(r\geq0\mid\DW{z}{1})$, but not with both, since
$(r<0\land r\geq0)$ is unsatisfiable.

Preconditions are linked to pomset order via \emph{causal strengthening},
which requires that formulae do not weaken over time, as measured by $\le$.
For example, the semantics of $\bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg$ includes:
\begin{displaymath}
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\aReg{=}2\mid\DR{\REF{2}}{1}}{}
  \event{a3}{\aReg{=}2\mid\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
    \end{tikzinline}}
\end{displaymath}
The precondition on $\DW{x}{1}$ is required by the data dependency induced by
$\bReg$ (see page \pageref{page:strengthening}).  Note that, by causal
strengthening, the termination event of a completed pomset must imply all
other events.


\begin{definition}
  \label{def:mmpomset}
  A \emph{pomset with preconditions} is a tuple
  $(\Event, {\le}, %{\gtN},
  \labeling)$: %, such that
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, 
  \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
    from which we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$,
    % define $\labelingForm(\aEv)=\aForm$ and $\labelingAct(\aEv)=\aAct$ when
    % $\labelingForm(\aEv)=(\aForm\mid\aAct)$,
  % \item ${\gtN} \subseteq (\Event\times\Event)$ is a partial order,
  % \item ${\le} \subseteq {\gtN}$ is a partial order, and
  \item $\bigwedge_{\aEv}\labelingForm(\aEv)$ is satisfiable
    \emph{(consistency)}, and
  \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
    $\labelingForm(\bEv)$ \emph{(causal strengthening)}.
  \end{itemize}
  % A pomset is \emph{completed} if $\exists\aEv.\;\labelingAct(\aEv)=\DSTOP$. % and $\forall\bEv.\;\bEv\le\aEv$.
\end{definition}
% From $\labeling$, we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$.


We write pairs in $(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$, eliding
$\aForm$ when it is a tautology.

We write $\bEv\lt\aEv$ when $\bEv\le\aEv$ and $\bEv\neq\aEv$.

We lift terminology from logical formulae and actions to events, saying, for example,
that $\aEv$ is \emph{unsatisfiable} if $\labelingForm(\aEv)$ is unsatisfiable,
and that $\aEv$ is a \emph{termination} when $\labelingAct(\aEv)$ is a termination.
We often elide explicit universal quantifiers in phrases such as
``\emph{for all $\aEv$}, $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.''





% The semantics of programs is given as sets of pomsets, with each pomset
% representing a completed execution.
% %
% We expect sets of pomsets given by the semantics to be closed with
% respect to \emph{augmentation}, \emph{implication} and \emph{isomorphism}:
The notion of \emph{downset} for pomsets is similar to the notion of
\emph{prefix} for strings:
\begin{definition}
  \label{def:downset}
  $\aPS'$ is a \emph{downset} of $\aPS$ if
  $\Event \supseteq \Event' \supseteq \{ \bEv \in \Event \mid
  \exists\aEv\in\Event'.\; \bEv\le\aEv\}$, ${\le'}={\le}\restrict{\Event'}$,
  and ${\labeling'}={\labeling}\restrict{\Event'}$.
\end{definition}
% (We identify
% pomsets up to isomorphism on the event set.)

The semantics of programs is given as sets of completed pomsets that are
closed with respect to order \emph{augmentation}, which may add order, and
\emph{implication}, which may have stronger formulae.  In examples, we draw
pomsets that are \emph{augmentation\hyp{}minimal} and
\emph{implication\hyp{}minimal}.
\begin{definition}
  We say that
  $\aPS'$ is an \emph{augment} of $\aPS$ if $\Event'=\Event$,
  ${\labeling'}={\labeling}$, and ${\le'}\supseteq{\le}$. 
  
  We say that
  $\aPS'$ \emph{implies} $\aPS$ if $\Event'=\Event$, ${\le'}={\le}$,
  $\labelingAct'=\labelingAct$, and $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$. 
\end{definition}
The semantics is also closed with respect to \emph{disjunction}, which
weakens pomsets by taking the disjunction of the formulae in their common
downset.  For example, since $\sem{x \GETS 1{+}r{*}r{-}r}$ includes
$(r\EQ0\mid\DW{x}{1})$ and $(r\EQ1\mid\DW{x}{1})$, it must also include
$(r\EQ0\lor r\EQ1\mid\DW{x}{1})$ (see page \pageref{page:disjunction}).
Likewise, $\sem{[r] \GETS 0\SEMI [0]\GETS \BANG r}$ must include
\begin{math}
  (r\EQ0\lor r\EQ1\mid\DW{[0]}{0}) 
\end{math}
despite the fact that
\begin{math}
  (r\EQ0\mid\DW{[0]}{0}) 
\end{math}
is generated by $[r] \GETS 0 $ and
\begin{math}
  (r\EQ1\mid\DW{[0]}{0}) 
\end{math}
is generated by $[0]\GETS \BANG r$
% \begin{math}
%   (r\EQ0\lor r\EQ1\mid\DW{[0]}{0}) (r\EQ0\mathbin\mid\DW{[0]}{1})
% \end{math}
% and
% \begin{math}
%   (r\EQ0\lor r\EQ1\mid\DW{[0]}{0}) (r\EQ1\mathbin\mid\DW{[1]}{0})
% \end{math}
(see page \pageref{page:disjunction2}).
\begin{definition}
  \label{def:dis}
  We say that $\aPS$ is a \emph{disjunct} of $\aPS^i$ ($i\in I$) if there is
  some $k\in I$ and some downset $\aPS^i_{\nabla}$ of each $\aPS^i$ such that
  (1) $\Event = \Event^k$, ${\le}={\le^k}$, and
  $\labelingAct=\labelingAct^k$, (2) for every $i\in I$,
  $\Event^k_{\nabla} = \Event^i_{\nabla}$,
  ${\le^k}_{\nabla}={\le^i}_{\nabla}$, and
  $\labelingAct^k_{\nabla}=\labelingAct^i_{\nabla}$, (3) for each
  $\aEv\in(\Event^k\setminus\Event^k_{\nabla})$:
  $\labelingForm(\aEv)$ implies $\labelingForm^k(\aEv)$, and (4)
  for each $\aEv\in\Event^k_{\nabla}$:
  $\labelingForm(\aEv)$ implies $\bigvee_i \labelingForm^i_{\nabla}(\aEv)$.

  % Let $\aPS''$ be a \emph{disjunct} of $\aPS^i$ for $i\in I$ if there is some
  % $\aPS'\in\PRE{\aPS''}$ such that $\Event' = \Event^i$, ${\le'}={\le^i}$,
  % $\labelingAct'=\labelingAct^i$, and $\labelingForm'(\aEv)$ implies
  % $\bigvee_i \labelingForm^i(\aEv)$.
  %
  % We say that $\aPS'$ is a \emph{disjunct} of $\aPS^i$  $(i\in I)$ if
  % $\Event' = \Event^i$, ${\le'}={\le^i}$, $\labelingAct'=\labelingAct^i$, and
  % $\labelingForm'(\aEv)$ implies $\bigvee_i \labelingForm^i(\aEv)$.
  % 
  % Let $\PRE{\aPSS}=\{\aPS'\mid\aPS'$ is a
  % downset of some $\aPS \in \aPSS\}$.
  %
  % Let $\aPS^{i}_{\nabla}$ denote a downset of ${\aPS^{i}}$, for $i\in\{1,2\}$.  We
  % say that $\aPS^{2}$ is a \emph{downset weakening} of $\aPS^1$ by
  % $\aPS^{2}_{\nabla}$ if there is some $\aPS^{1}_{\nabla}$ that implies $\aPS^{2}_{\nabla}$ and
  % $\aPS^1$ implies $\aPS^{2}$.
  % Let $\aPS^{2}$ be a \emph{downset weakening} of $\aPS^1$ by
  % $\aPS^{2}_{\nabla}\in\PRE{\aPS^{2}}$ if $\aPS^1$ implies $\aPS^{2}$ and there is
  % some $\aPS^{1}_{\nabla}\in\PRE{\aPS^{1}}$ such that $\aPS^{1}_{\nabla}$ implies
  % $\aPS^{2}_{\nabla}$.
  % Let
  % $\aPS'$ be an \emph{isomorphism} of $\aPS$ if there is a bijection
  % $f:\Event\fun\Event'$ such that $\labeling(\aEv)=\labeling'(f(\aEv))$, and
  % $\aEv\le\bEv$ iff $f(\aEv)\le'f(\bEv)$. %, and $\aEv\gtN\bEv$ iff $f(\aEv)\gtN'f(\bEv)$.
\end{definition}
 
% Each pomset $\aPS\in\sem{\aCmd}$ is a \emph{completed} execution of $\aCmd$;
% we sometimes refer to pomsets as \emph{executions}.  Because they are
% completed executions, we do not expect $\sem{\aCmd}$ to be downset closed.
% However, implication closure in a memory-model pomset does give something
% similar: any event $\aEv$ can be given an unsatisfiable precondition, which
% means that every event ordered after $\aEv$ must also be unsatisfiable, as
% per Definition~\ref{def:mmpomset}.  In many applications of the model,
% unsatisfiable events are ignored, thus providing a kind of downset closure.
% % \begin{definition}
% %   $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$, ${\labeling'}={\labeling}$,
% %   ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
% %   and ${\gtN}\subseteq{\gtN'}$. %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$,
% %   % $\labelingAct'=\labelingAct$, and  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.
% %   % if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies $\bForm$.
% % \end{definition}

\subsection{Semantics of the Example Language}
In the remainder of \textsection\ref{sec:model}, we explain the semantics of our example
language.

By far the most complex operators are the prefixing
operators---read and write---which introduce new actions.  We build the
definition of prefixing from first principles, starting in
\textsection\ref{sec:pop}.  The final definition of prefixing appears in
\textsection\ref{sec:rwe}.

Of the other operators, it will not be surprising to students of concurrency
theory that the most interesting are local declarations ($\VAR\aLoc\SEMI\aCmd$)
and parallel composition ($\aCmd \PAR \bCmd$).

At the point that $\aLoc$ is bound, we can require that every read of $\aLoc$
be \emph{fulfilled}.  Fulfillment plays the role that \emph{reads-from} and
\emph{coherence} play in other relaxed memory models, yet it is not the same.

Parallel composition is roughly pomset union, allowing that some events may
\emph{coalesce}, with the resulting precondition being the disjunction of the
precondition taken from the two sides.  Composition is used to define
conditionals (as in \cite{2019-sp}).  We also use it to define write
prefixing (\textsection\ref{sec:pop}).  In both cases, the use of composition
is required to ensure disjunction closure (Definition~\ref{def:dis}).

\begin{definition}
   \label{def:rf}
 Two actions \emph{conflict} if one writes a location and the other
either reads or writes the same location.
We say $\bEv$ \emph{fulfills $\aEv$ (on $\aLoc$)} if 
% \begin{itemize}    
% \item
(1) $\bEv$ \externally writes $\aVal$ to $\aLoc$, 
% \item
(2) $\aEv$ \externally reads $\aVal$ from $\aLoc$,
% \item
(3) $\bEv \lt \aEv$, and
% \item
(4) for every conflicting write $\cEv$, either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
% \end{itemize}
\end{definition}
Item (3) requires that a write $\bEv$ is ordered before any read $\aEv$ it
fulfills; we draw order required by this item (aka \emph{reads-from}) with
bold green arrows.  Item (4) requires that any conflicting write $\cEv$ is
ordered before $\bEv$ or after $\aEv$; we draw order required by this item
with dashed red arrows (aka \emph{extended coherence}).  In our model, these
are not separate orders.  We include the \emph{reason} for the order only to improve
readability. As an example, consider:
\begin{gather*}
  \taglabel{Co1}
  x\GETS 1
  \PAR
  x\GETS2
  \PAR
  x\GETS 3
  \PAR
  x\GETS 4
  \PAR
  x\GETS 5
  \PAR
  r\GETS x\SEMI r\GETS x \SEMI r\GETS x \SEMI r\GETS x \SEMI r\GETS x
  \\
  \hbox{\begin{tikzinline}[node distance=.7em and 2em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1a}{\DR{x}{1}}{above right=of wx1}
  \event{rx1b}{\DR{x}{1}}{above=of rx1a}
  \event{wx2}{\DW{x}{2}}{below right=of rx1a}
  \event{rx2a}{\DR{x}{2}}{above right=of wx2}
  \event{rx2b}{\DR{x}{2}}{above=of rx2a}
  \event{wx3}{\DW{x}{3}}{above right=of rx2a}            
  \event{wx4}{\DW{x}{4}}{right=of rx2a}
  \event{wx5}{\DW{x}{5}}{below right=of wx4}
  \event{rx5}{\DR{x}{5}}{above right=of wx5}
  \rf{wx1}{rx1a}
  \rf{wx1}{rx1b}
  \rf{wx2}{rx2a}
  \rf{wx2}{rx2b}
  \wk{rx1a}{wx2}
  \wk{rx1b}{wx2}
  \wk{rx2a}{wx3}
  \wk{rx2a}{wx4}
  \wk{rx2b}{wx3}
  \wk{rx2b}{wx4}
  \wk{wx3}{wx5}
  \wk{wx4}{wx5}
  \rf{wx5}{rx5}
    \end{tikzinline}}
\end{gather*}
A write is \emph{relevant} if it is read from.  In order to fulfill all of
the reads on $x$ in the example, we pick a total order on the relevant
writes: in this case, $(\DW{x}{1})\le (\DW{x}{2})\le(\DW{x}{5})$.  The reads
slot between these, immediately after their fulfilling write.  Reads are not
necessarily ordered with respect to each other, even if they come from the
same thread, as do the reads here.  Irrelevant writes also float relative to
each other, as do $(\DW{x}{3})$ and $(\DW{x}{4})$.  But irrelevant writes
must be ordered with respect to relevant writes and reads.  The resulting
order is somewhat weaker than traditional extended coherence, which requires
a total order on the writes, regardless of whether they are relevant.  We
discuss coherence further on page \pageref{page:coherence2}.

% The restriction of pomset order to conflicting events is called the
% \emph{extended coherence order} ($\reco$).  This relation can always be
% extended to totally order all conflicting events, as is common in hardware
% memory models.

% When a location is bound, every read of that location must be {fulfilled} by a
% matching write.
\begin{definition}
  A pomset is \emph{$\aLoc$-closed} if every \external read on $\aLoc$ is fulfilled,
  and every formula is independent of $\aLoc$
  ($\forall\aVal.\;\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$).
  Let $(\nu\aLoc\!\DOT\!\aPSS)$ be  $\aPSS'{\subseteq}\aPSS$ such that $\aPS'{\in}\aPSS'$
  when $\aPS'$ is $\aLoc$-closed.
\begin{align*}
  \sem{\VAR\aLoc\SEMI \aCmd} & \eqdef
  \nu \aLoc \DOT \sem{\aCmd}  
\end{align*}
  A pomset is \emph{top-level} if it is $\aLoc$-closed for every location
  $\aLoc$.  
\end{definition}

%\subsection{Fulfillment and Location Binding}

\labeltext{The}{page:extrusion} definition of location binding validates \emph{scope
  extrusion}~\cite{Milner:1999:CMS:329902}: if $\aCmd$ does not
mention~$\aLoc$ then
$\sem{\aCmd\PAR \VAR\aLoc\SEMI\bCmd}\allowbreak=\allowbreak\sem{\VAR\aLoc\SEMI(\aCmd\PAR\bCmd)}$.
However, the definition does not validate renaming of locations: if
$\aLoc\neq\bLoc$ then
$\sem{\VAR\bLoc\SEMI\aCmd}\neq\sem{\VAR\aLoc\SEMI\aCmd[\aLoc/\bLoc]}$,
even if $\aCmd$ does not mention~$\aLoc$.  This is consistent with support
for address calculation, which is required by realistic memory allocators.
%$\nu\aLoc\DOT\aPSS\neq \nu\bLoc\DOT\aPSS[\bLoc/\aLoc]$ when $\bLoc\neq\aLoc$.
% $\nu\aLoc\DOT(\aPSS\parallel\nu\aLoc\DOT\bPSS)$ is generally
% not the same as
% $\nu\aLoc\DOT(\aPSS\parallel(\nu\bLoc\DOT\bPSS[\bLoc/\aLoc]))$.

%\subsection{Composition, Concurrency and Conditional}
% Conditional execution is defined using pomset union and filtering, which
% selects pomsets satisfying a formula.

% \begin{definition}
%   Let $\aPS' = (\aPS^1 \cup \aPS^2)$ when $\Event' = \Event^1 \cup \Event^2$,
%   ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
%   ${\labeling'}\supseteq{\labeling^1}\cup{\labeling^2}$.

%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   Let $\aPS'\in \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}$  when
%   $\aPS\cup\aPS^1\in\sem{\aCmd}$,
%   $\aPS\cup\aPS^2\in\sem{\bCmd}$,
%   and ether\bigl(\aExp
%   \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard
%   \sem{\bCmd}\bigr)
% \end{definition}

% Composition is roughly union:
% $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.  For example, we have the
% following execution, which unions the two sides:
% \begin{gather*}
%   \IF{r<0}\THEN y\GETS1\FI
%   \PAR
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gather*}
% In addition to this execution, we allow that events with the same label to
% coalesce, taking the disjunction of their preconditions.  Thus, the semantics
% of this program also includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' = \Event^1 \cup \Event^2$,
% ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
% either
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% \begin{aligned}
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

%\subsection{Composition, Concurrency and Conditional}

Concurrent composition is roughly union.  Because of consistency
(Definition~\ref{def:mmpomset}), we do not include events with contradictory
preconditions.
% : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
Consider:
\begin{align*}
\begin{gathered}
  \IF{r<0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \IF{r\geq0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}
The parallel composition includes pomsets with either one of the two events, but not
both.  However,  events with the same label may coalesce, taking the
disjunction of their preconditions.  Thus, the semantics of the combined
program also includes
\begin{math}
  % \IF{r<0}\THEN y\GETS1\FI
  % \PAR
  % \IF{r\geq0}\THEN y\GETS1\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{math}.
Coalesced events inherit order from both sides.
\begin{definition}
  \label{def:par}
  % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
  % $\Event' \subseteq \Event^1 \cup \Event^2$,
  % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
  % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
  % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
  % unsatisfiable.
  Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
  when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$
  such that
$\Event' = \Event^1 \cup \Event^2$,
$\Event^1$ is completed exactly when $\Event^2$ is completed,
there is at most one termination in $\Event'$,
${\le'}\supseteq{\le^1}\cup{\le^2}$,
and for all $\aEv\in\Event'$,
either:
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^i \mid \exists\aEv\in\Event'.\; \bEv\le^i\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
\begin{gather*}
  \begin{aligned}
    \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
    &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
    &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
  \end{aligned}
  \\
%\end{gather*}
% if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% \labelingForm^2(\aEv)$ is unsatisfiable.
%\begin{gather*}
\begin{aligned}
  \sem{\aCmd \PAR \bCmd} & \eqdef
  \sem{\aCmd} \parallel \sem{\bCmd} 
\end{aligned}
\end{gather*}
\end{definition}
The definition requires that if $\aPS'\in(\aPS^1 \parallel \aPS^2)$ is completed,
then both $\aPS^1$ and $\aPS^2$ are completed, and further, the termination events
\emph{must} coalesce in $\aPS'$.
% The definition ensures $\Event'$ is downclosed w.r.t.~each $\Event^i$.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}


% Conditional execution is defined using parallel composition and \emph{filtering}, which selects the
% subset of pomsets that imply a formula.
%  For an example
% using the first clause in the definition of composition,
% $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% Conditional execution and concurrency are defined using filtering, which
% selects pomsets satisfying a formula, and composition.  Composition is
% roughly union, ensuring that the combined events are compatible.
% % : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% % $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
% For example, consider:
% \begin{align*}
% \begin{gathered}
%   \IF{r<0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Putting these in parallel, we allow events with the same label to coalesce,
% taking the disjunction of their preconditions.  Thus, the semantics includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
%   % $\Event' \subseteq \Event^1 \cup \Event^2$,
%   % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
%   % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
%   % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
%   % unsatisfiable.

%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% %$\Event' \subseteq \COMPAT(\aPS^1,\,\aPS^2)$,
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^1 \cup \Event^2 \mid
% \exists\aEv\in\Event'.\; \bEv\le^1\aEv \textor \bEv\le^2\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% %\end{gather*}
% % if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% % $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% % \labelingForm^2(\aEv)$ is unsatisfiable.
% %\begin{gather*}
% \begin{aligned}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
%   \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
%   \\
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

Conditional execution is defined using parallel composition and
\emph{filtering}: $(\aForm \guard \aPSS)$ selects the subset of pomsets in
$\aPSS$ that are implied by $\aForm$.  Register assignment is defined using
substitution: $(\aPSS\aSub)$ performs the substitution $\aSub$ on every
pomset in $\aPSS$.  The semantics of $\SKIP$ is defined using singletons:
$\stopPS$ is the set of pomsets that contain a single termination event.
\begin{definition}
  Let $(\aForm \guard \aPSS)$ be the set $\aPSS'\subseteq\aPSS$ such that
  $\aPS'\in\aPSS'$ when $\aForm$ implies $\labelingForm(\aEv')$ %, %for every
  $(\forall\aEv'\in\Event')$. 
  %
  Let $(\aPSS\aSub)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when there is
  $\aPS\in\aPSS$ such that: $\Event' = \Event$, ${\le'} = {\le}$,
  % ${\gtN'} = {\gtN}$,and
  $\labelingAct'(\aEv) = \labelingAct(\aEv)$, and
  $\labelingForm'(\aEv) = \labelingForm(\aEv)\aSub$.
  %
  Let $\aPS\in\stopPS$ when $\Event$ has one element labelled with action
  $\DSTOP$.
\begin{align*}
  \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
  \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
  &
  \sem{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
  \sem{\aCmd}[\aExp/\aReg] 
  &  
  \sem{\SKIP} & \eqdef
  \stopPS
\end{align*}
\end{definition}
%Register assignment and $\SKIP$ are simple.
% the orders are drawn with
% \citeauthor{DBLP:journals/dc/Lamport86}'s notation.  
% For example:
% \begin{tikzdisplay}[node distance=1em]
%   \event{rx1}{a}{}
%   \event{wy0}{b}{below right=of rx1}
%   \event{wy1}{c}{above right=of wy0}
%   \po{rx1}{wy0}
%   \po{rx1}{wy1}
%   \wk{wy0}{wy1}
% \end{tikzdisplay}
% is a visualization of the pomset where:
% \[\begin{array}{c}
%     E = \{ 0,1,2 \}
%     \quad
%     {\labeling} = \{(0,a),\,(1,b),\,(2,c)\}
%     \\
%     {\le} = \{(0,1),\,(0,2)\}\cup\{(0,0),\,(1,1),\,(2,2)\}
%     \quad
%     {\gtN} = {\le}\cup\{(2,3)\}
% \end{array}\]
% for example:


%The semantics of $\SKIP$ and register assignment are simple:
% \begin{definition}
% \begin{align*}
%   \sem{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
%   \sem{\aCmd}[\aExp/\aReg] 
%   &  
%   \sem{\SKIP} & \eqdef
%   \stopPS
% \end{align*}
% \end{definition}

% The semantic rule for condition, echoes the rule in Hoare
% logic:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}
\subsection{Program Order Prefixing} % for Trivial Expressions.}
\label{sec:pop}
We present several candidate definitions for prefixing before giving the
final definition.  The candidates are progressively more general and less
ordered.  We begin by considering programs with trivial expressions,
including all of program order in pomset order.
% To simplify the definition, we construct the set of pomsets with the new
% action, then downset close.

% For programs with only trivial expressions, the simplest candidate
% definitions of read and write result in top-level executions being
% sequentially consistent.
\begin{candidate}
  \label{def:rw:sc1}
  Let $(\aForm \mid \aAct) \prefixsimp \aPSS$ be the set
  $\aPSS'$ %$\PRE{\aPSS'}$
  where
  $\aPS'\in\aPSS'$ when there is $\aPS\in\aPSS$ such that $\aPS'$ adds a
  new event %with the given label
  that precedes all of the events in $\aPS$.
  \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsimp \sem{\aCmd}}
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS\aVal\SEMI \aCmd} & =
    %\textstyle\bigcup_\aVal\; (\bVal=\aVal \mid
    \smash{\DWmode\aLoc\aVal \prefixsimp \sem{\aCmd}}
  \end{align*}
\end{candidate}
%For now, ignore the preconditions and substitutions. We explain them in the subsections below.

The definition ensures that program order is included in the pomset order.
Due to the requirements of fulfillment, we also have that $\reco$ is included
in pomset order.  As a result, all executions are sequentially consistent.
For example, consider the \emph{store buffering} litmus test:
\begin{gather*}
  \taglabel{SB}
  x\GETS0\SEMI
  y\GETS0\SEMI
  (
  x\GETS1\SEMI\aReg\GETS y
  \PAR
  y\GETS1\SEMI \aReg\GETS x)
  \\
  \hbox{\begin{tikzinline}[node distance=1em and 2em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wy0}{\DW{y}{0}}{below=of wx0}
      \event{wx}{\DW{x}{1}}{right=of wx0}
      \event{wy}{\DW{y}{1}}{right=of wy0}
      \event{ry}{\DR{y}{0}}{right=of wx}
      \event{rx}{\DR{x}{0}}{right=of wy}
      \wk{wx0}{wx}
      \wk{wy0}{wy}
      \po{wy}{rx}
      \po{wx}{ry}
      \rf{wy0}{ry}
      \rf{wx0}{rx}
      \wk[out=-150,in=15]{ry}{wy}
      \wk[out=150,in=-15]{rx}{wx}
      % \po{rx}{wy}
    \end{tikzinline}}
\end{gather*}
The read to write order is required by the definition of fulfillment.
This candidate execution is \emph{not} a pomset due to the resulting cycle;
thus it is disallowed by Candidate~\ref{def:rw:sc1}.

For programs with general expressions, we must introduce preconditions.  We
write the definition of the prefixing operator more carefully this time, and highlight
some of the changes in the candidate semantics:

%\subsection{Program Order Prefixing}
\begin{definition}
  \label{def:pre-sc}
  Let $(\aForm \mid \aAct) \prefixsc \aPSS$ be the set
  $\aPSS'$ %$\PRE{\aPSS'}$
  where
$\aPS'\in\aPSS'$ when 
there is $\aPS\in\aPSS$ such that
\hbox{{\labeltext[1]{(1)}{1}} $\Event' = \Event \uplus \{\bEv\}$,}
{\labeltext[2]{(2)}{2}}  ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
{\labeltext[3]{(3a)}{3}}  $\labelingAct'(\bEv) = \aAct$,
(3b) $\labelingForm'(\bEv)$ implies $\aForm$, 
{\labeltext[4]{(4a)}{4}} $\labelingAct'(\aEv) = \labelingAct(\aEv)$, 
\begin{enumerate}
% \item[(1)]\label{pre-E} $\Event' = \Event \uplus \{\bEv\}$,
% \item[(2)]\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
% \item[(3a)] $\labelingAct'(\bEv) = \aAct$,
% \item[(3b)] $\labelingForm'(\bEv)$ implies $\aForm$,
% \item[(4a)] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
\item[{\labeltext[4b]{(4b)}{4b}}] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
\item[{\labeltext[4c]{(4c)}{4c}}] if $\bEv$ does not \externally read then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$, and
\item[{\labeltext[5]{(5)}{5}}] $\bEv \lt' \aEv$, 
\end{enumerate}
\end{definition}

% In the definition of prefixing,
\begin{candidate} %\ \vspace{-1ex}
  \label{cand:sc}
  \begin{math}
    \begin{aligned}[t]
      % \tag{$\dagger$}\label{sc-read}
      \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
      \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsc
        \sem{\aCmd}\mkern4mu\, \mathhl{[\aLoc/\aReg] }}
      \\
      % \tag{$\ddagger$}\label{sc-write}
      \sem{\aLoc^\amode\GETS{\aExp}\SEMI \aCmd} & =
      \;\smash{\mathhl{\textstyle\parallel_\aVal (\aExp=\aVal}\, \mid
        \DWmode\aLoc\aVal) \prefixsc\; \sem{\aCmd}}
    \end{aligned}
  \end{math}
\end{candidate}
Item \ref{1} introduces a new event.  Item \ref{2} ensures that no order is removed from old
events. Item \ref{3} describes the label of the new event, which must imply
$\aForm$. Item \ref{4} describes the labels of old events, as discussed below.
Item \ref{5} ensures that program order is included for the new event.

%We first discuss writes, then reads.

For writes, item \ref{4} is simple: For old events, the new precondition in $\aPS'$
must imply the old precondition in $\aPS$.  (This is very similar to the
treatment of the new event in item \ref{3}.)

The semantics of write introduces a write action for each possible value of
the expression $\aExp$.  To ensure that at most one write is enabled, these
are given disjoint preconditions.

\labeltext{The}{page:disjunction} semantics is again driven by Hoare
logic---for the preconditions of writes, the relevant rule is left
disjunction:
\begin{displaymath}
  \frac{
    \hoare{\aForm^1}{\aCmd}{\bForm}
    \quad
    \hoare{\aForm^2}{\aCmd}{\bForm}
  }{
    \hoare{\aForm^1\lor\aForm^2}{\aCmd}{\bForm}
  }
\end{displaymath}
Note that
\begin{math}
  \sem{x \GETS 1{+}r{*}r{-}r}
\end{math}
includes both % of the pomsets:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ0\mathbin{\mid}\DW{x}{1}}{}
%     \end{tikzinline}}%\;\;\cdots
%   \qquad
%   %\\[-1.5ex]\intertext{and:}\\[-5ex]
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ1\mathbin{\mid}\DW{x}{1}}{}
%     \end{tikzinline}}%\;\;\cdots
% \end{align*}
\begin{math}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{math}
and
% \begin{math}
%   \\[-1.5ex]\intertext{and:}\\[-5ex]
\hbox{\begin{tikzinline}[node distance=.2em]
    \event{a}{r\EQ1\mathbin{\mid}\DW{x}{1}}{}
  \end{tikzinline}}. %\;\;\cdots
% \end{math}
% \end{align*}
By using $\parallel_\aVal$ in the definition of write, it also includes:
% (where,
% contrary to convention, we show disjoint events):
\begin{math}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{math}.
An alternate definition using $\cup_\aVal$ would exclude this pomset.

Given that the conditional is defined using $\parallel$, the use of $\parallel$
in the definition of write is necessary to validate \emph{case analysis}:
\begin{math}
  \sem{\aCmd}
  =
  \sem{\IF{\aExp}\THEN \aCmd\ELSE \aCmd\FI}.
\end{math}


For reads, item \ref{4b} %(Candidate \ref{def:pre-sc})
allows some preconditions to weaken and requires others to strength\-en.
Recall the pomsets given previously \eqref{ex-1} for $y\GETS r$ and
$\IF{r<0}\THEN y\GETS1 \FI$. % from the beginning of this section:
% \begin{align*}
%   \begin{gathered}
%     y\GETS r
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{r=1\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     \IF{r<0}\THEN y\GETS1 \FI
%     \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{r<0\mid\DW{y}{1}}{}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
Prepending $\aReg\GETS\aLoc$ first causes the substitution $[x/r]$:
\begin{align*}
  \begin{gathered}
    r\GETS x\SEMI y\GETS r
    \\    
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x=1\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x<0\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Item \ref{4b} then the substitutes the chosen value $[1/x]$:
\begin{align}
  \label{ex-2}
  \begin{gathered}
    % r\GETS x\SEMI y\GETS r
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{1=1\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \nonevent{wy1}{1<0\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        %\po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align}
% We can write these more succinctly as:
% % We often drop preconditions on tautological events and sometimes cross out
% % unsatisfiable ones (which may are ignored):
% \begin{align*}
%   \begin{gathered}
%     % r\GETS x\SEMI y\GETS r
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \nonevent{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
On the right, $(\DW{y}{1})$ has become impossible; this is no longer a pomset
due to \emph{inconsistency}.  On the left, it has become
causally dependent on the read.  By prefixing a read event, the precondition
$x=1$ has moved from the sequential realm of Hoare logic to the concurrent
memory model.  Rather than a precondition that must be \emph{satisfied}, the
resulting pomset has a read event that must be \emph{fulfilled}.

%The use of $\parallel$ is unnecessary  for reads.
% : the read rule does not introduce read preconditions, and item \ref{5a} of
% Definition \ref{def:prefix} ignores them.
Whereas a write action introduces a precondition---satisfied
sequentially---on the value to be written; a read introduces a pomset
requirement---fulfilled concurrently---on the value to be read.  Since reads
of different values do not have disjoint preconditions, it is important that
a read introduce at most one event per pomset.  Thus, we use $\cup_\aVal$ to
combine pomsets for different read values, rather than $\parallel_\aVal$.
% In the concurrent world, writes are capabilities; reads are obligations.
% Thus, a read should introduce at most one event per pomset.


% We can now explain the substitution in the semantics of read in Candidate~\ref{def:rw:sc1}.
% % (The substitution in the semantics of write \eqref{sc-write} is not used here; we explain
% % it after introducing \emph{internal reads}, below.)
% Returning to our example, to compute
% $\sem{r\GETS x\SEMI y\GETS r}$, we first compute
% $(r\EQ1\mid\DW{y}{1})[x/r]$, then perform prefixing on the resulting $(x\EQ1\mid\DW{y}{1})$.  By \ref{4b}, reading $1$
% performs the further substitution of $[1/x]$, allowing the precondition to
% weaken to $(1\EQ1)$.  Likewise, reading $0$ performs $[0/x]$, requiring the precondition
% to strengthen to $(0\EQ1)$.

% Second, the use of $\PAR$ to combine pomsets formed by write prefixing
% ensures that the semantics is ``disjunctive'' in a certain sense.
% The following example uses address calculation, defined formally in
% \textsection\ref{sec:variants}.  It also use the operator ``$\BANG \aExp$,''
% which evaluates to $1$ when $\aExp$ is $0$, and
% $0$ otherwise.  Note that 
% \begin{math}
%   \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
% \end{math}
% includes both of the following pomsets:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
%   \qquad
%   %\\[-1.5ex]\intertext{and:}\\[-5ex]
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
%       \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
% \end{align*}
% By using $\PAR$ rather than $\cup$, it also includes the following (where,
% contrary to convention, we show disjoint events):
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em]
%       \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%       \event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
%     \end{tikzinline}}%\;\;\cdots
% \end{gather*}
% Using $\cup$, the semantics would exclude this pomset, and thus fail to
% validate \emph{case analysis}---for example, refining this program,
% \begin{math}
%   \aCmd = (a[r] \GETS 0\SEMI a[0]\GETS \BANG r),
% \end{math}
% to
% \begin{math}
%   \IF{r\EQ1}\THEN \aCmd\ELSE \aCmd\FI.
% \end{math}

\subsection{General Prefixing}
\label{sec:gp}

We now relax item \ref{5} so that only some program order is {preserved}.
The final definition has a small delta with respect to
Definition \ref{def:pre-sc}.  Program order need only be preserved from
a read to a dependent write (\ref{5a}), between conflicting events
(\ref{5b}), and around fences (\ref{5c}, \ref{5d}).
% %\ref{5a}
% weakening a dependent precondition,
% %\ref{5b}
% conflict (aka, coherence), 
% %\ref{5c}
% $\modeRA$-fences, and 
% %\ref{5d}
% $\modeSC$-fences.

It is amazing how much this definition ``gets right'' out of the box, including
``internal reads'', which greatly complicate other models
\cite{DBLP:journals/pacmpl/PulteFDFSS18}.  We walk through several litmus
tests.

% and our last failed candidate semantics.
\begin{definition}
  \label{def:prefix}
Let $(\aForm \mid \aAct) \prefix \aPSS$ be the set
  $\aPSS'$ %$\PRE{\aPSS'}$
where
$\aPS'\in\aPSS'$ when
there is some $\aPS\in\aPSS$ that satisfies items \ref{1}-\ref{4} of
Definition \ref{def:pre-sc} such that:
\begin{enumerate}
\item[{\labeltext[5a]{(5a)}{5a}}] %$\bEv$ \externally reads and
  if $\aEv$ writes then either $\bEv\lt'\aEv$ or $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$,
% \item[5a.]  if $\aEv$ writes then either $\labelingForm'(\aEv)$ implies
%   $\labelingForm(\aEv)$, or some $\cEv\lt'\aEv$ reads $\aVal$
%   from $\aLoc$ and $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
% \item[5a.] if %$\bEv$ \externally reads and
%   $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and $\aEv$ writes, then
%   $\bEv\lt'\aEv$,
\item[{\labeltext[5b]{(5b)}{5b}}] if $\bEv$ and $\aEv$ are \external actions in conflict,
    then $\bEv\lt'\aEv$, %$\bEv \gtN' \aEv$,
\item[{\labeltext[5c]{(5c)}{5c}}] if $\bEv$ is an acquire or $\aEv$ is a release, then $\bEv \lt' \aEv$, and
\item[{\labeltext[5d]{(5d)}{5d}}] if $\bEv$ is an SC write and $\aEv$ is an SC read, then $\bEv \lt' \aEv$.
%\item[5e.] if $\aEv$ is a termination, then $\bEv\lt'\aEv$.
% \item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
%   is location independent.
\end{enumerate}
\end{definition}
%\vspace{-2ex}
\begin{candidate}%\ \vspace{-1ex}
  \label{cand:ord}
  \begin{math}
    \begin{aligned}[t]
      % \tag{$\dagger$}\label{sc-read}
      \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & = \textstyle\bigcup_\aVal\;
      (\DRmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd} [\aLoc/\aReg]
      \\
      % \tag{$\ddagger$}\label{sc-write}
      \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
      \;\;\textstyle\parallel_\aVal (\aExp=\aVal \mid \DWmode\aLoc\aVal)
      \mathhl{\prefix}\; \sem{\aCmd}\mkern3.5mu\mathhl{[\aExp/\aLoc]}
    \end{aligned}
  \end{math}
\end{candidate}

% \end{definition}
% \begin{candidate}
%   Replace $\prefixsc$ in Candidate~\ref{def:rw:sc1} by $\prefix$.
% \end{candidate}
Item \ref{5a} captures \emph{read to write dependency}\footnote{When $\bEv$
  is not a read, \ref{4c} trivially implies \ref{5a}.}.  It only requires
order from read to write when the precondition of the write is
\emph{weakened} using \ref{4b}.  Item \ref{5b} captures the extended
coherence requirement on actions that touch the same location.  Item \ref{5c}
imposes the order required by acquire and release actions\footnote{Recall
  that termination actions are releases.}.  Item \ref{5d} imposes the
additional order required by SC actions\footnote{Recall that SC reads are
  acquires and SC writes are
  releases.}.  %(We explain item 6 in the next subsection.)

Items \ref{5b} and \ref{5c} ensure correct publication.  For
example, they disallow the following candidate execution, which sees a stale
value for $x$:
\vspace{-1ex}
\begin{gather}
  \taglabel{Pub1}
  x\GETS0\SEMI %y\GETS0\SEMI
  x\GETS 1\SEMI y \REL\GETS1 \PAR r\GETS y\ACQ\SEMI s\GETS x
  \\[-1ex]
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wx1}{\DW{x}{1}}{right=of wx0}
      \event{wy1}{\DWRel{y}{1}}{right=of wx1}
      \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
      \event{rx0}{\DR{x}{0}}{right=of ry1}
      \sync{wx1}{wy1}
      \sync{ry1}{rx0}
      \rf{wy1}{ry1}
      \rf[out=10,in=170]{wx0}{rx0}
      \wk{wx0}{wx1}
    \end{tikzinline}}
\end{gather}
By Definition \ref{def:rf}, $(\DR x0)$ is \emph{unfulfilled} in this
pomset. It fails the last requirement of the definition, since
$(\DW x0) \gtN (\DW x1) \lt (\DR x0)$.  In order to satisfy this requirement,
$(\DR x0)$ must be ordered before $(\DW x1)$, but this creates a cycle.

%This example is also disallowed if we use $\modeSC$ rather than $\modeRA$.
Item \ref{5d} ensures that program order between SC operations is always
preserved.  Combined with the requirements for fulfillment, this is
sufficient to establish that programs with only SC access have only SC
executions; for example, execution candidate \ref{SB} is banned when the
actions of the two threads are all $\modeSC$ (but allowed with less order
otherwise, as discussed below).  It is also immediate that SC actions can be
totally ordered, using any linearization of pomset order.  Just as SC access in
\armeight{} is simplified by \mca, it is simplified here by the
global pomset order.
% \begin{gather*}
%   x\GETS0\SEMI x\GETS1\SEMI\aReg\GETS y
%   \PAR
%   y\GETS0\SEMI y\GETS1\SEMI \aReg\GETS x
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wy0}{\DW{y}{0}}{below=of wx0}
%       \event{wx}{\DW{x}{1}}{right=of wx0}
%       \event{wy}{\DW{y}{1}}{right=of wy0}
%       \event{ry}{\DR{y}{0}}{right=of wx}
%       \event{rx}{\DR{x}{0}}{right=of wy}
%       \wk{wx0}{wx}
%       \wk{wy0}{wy}
%       \po{wy}{rx}
%       \po{wx}{ry}
%       \rf{wy0}{ry}
%       \rf{wx0}{rx}
%       \wk{ry}{wy}
%       \wk{rx}{wx}
%       % \po{rx}{wy}
%     \end{tikzinline}}
% \end{gather*}

Unlike \citep[\textsection8.2]{Dolan:2018:BDR:3192366.3192421}, our model allows:
\begin{gather*}
  \taglabel{SC1}
  r\GETS y\SEMI x^\modeSC\GETS1\SEMI s\GETS x
  \PAR
  % y\GETS0\SEMI
  x^\modeSC\GETS2 \SEMI y\GETS1
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a}{\DR{y}{1}}{}
      \event{b}{\DW[\modeSC]{x}{1}}{right=of a}
      \sync{a}{b}
      \event{bb}{\DR{x}{2}}{right=of b}
      \wk{b}{bb}
      % \event{c}{\DW{y}{0}}{right=2em of bb}
      % \event{d}{\DW[\modeSC]{x}{2}}{right=of c}
      % \po{c}{d}
      \event{d}{\DW[\modeSC]{x}{2}}{right=2em of bb}
      \event{e}{\DW{y}{1}}{right=of d}
      %\rf[out=170,in=10]{d}{bb}
      \rf{d}{bb}
      \rf[out=-170,in=-10]{e}{a}
      \wk[in=165,out=15]{b}{d}
    \end{tikzinline}}
\end{gather*}
Note that there is no order from $(\DW[\modeSC]{x}{2})$ to $(\DW{y}{1})$.


We relax program order on non-SC accesses in order to allow outcomes like
that of execution candidate \ref{SB}.
Order is relaxed between reads, between writes to different
locations, and from a read to an independent write:
\begin{gather*}
  \aCmd=(\aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI)
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
    \end{tikzinline}}
\end{gather*}
The existence of this pomset is justified
by the Hoare triple
$\hoare{\TRUE}{\aCmd}{y=1}$.

Unordered actions can be scheduled freely.
As a result, our model of coherence is similar to that of
\citet{Dolan:2018:BDR:3192366.3192421}.  Since reads are not ordered by \ref{5b},
we {allow} the following, which C11 forbids:
\begin{gather*}
  \taglabel{Co2}
  x\GETS1\SEMI x\GETS 2
  \PAR
  y\GETS x \SEMI z\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DW{x}{2}}{right=of a}
      \wk{a}{b}
      \event{c}{\DR{x}{2}}{right=2em of b}
      \event{d}{\DW{y}{2}}{right=of c}
      \po{c}{d}
      \event{e}{\DR{x}{1}}{right=of d}
      \event{f}{\DW{z}{1}}{right=of e}
      \po{e}{f}
      \rf{b}{c}
      \rf[out=10,in=170]{a}{e}
    \end{tikzinline}}
\end{gather*}
\labeltext{Conversely}{page:coherence2}, we {forbid} the following, which Java allows:
\begin{gather*}
  \taglabel{Co3}
  \hbox{\small$
  x\GETS1\SEMI y^\modeRA\GETS 1
  \PAR
  x\GETS2\SEMI z^\modeRA\GETS 1
  \PAR
  r\GETS y^\modeRA \SEMI 
  r\GETS z^\modeRA \SEMI 
  r\GETS x \SEMI 
  r\GETS x$}
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a1}{\DW{x}{1}}{}
      \event{a2}{\DW[\modeRA]{y}{1}}{right=of a1}
      \sync{a1}{a2}
      \event{b1}{\DW{x}{2}}{below=of a1}
      \event{b2}{\DW[\modeRA]{\,z}{1}}{right=of b1}
      \sync{b1}{b2}
      \event{c1}{\DR[\modeRA]{y}{1}}{right=2em of a2}
      \event{c2}{\DR[\modeRA]{\,z}{1}}{right=2em of b2}
      \event{c3}{\DR{x}{2}}{right=of c1}
      \event{c4}{\DR{x}{1}}{right=of c2}
      \sync{c1}{c3}
      \sync{c1}{c4}
      \sync{c2}{c3}
      \sync{c2}{c4}
      \rf{a2}{c1}
      \rf{b2}{c2}
      \wk{a1}{b1}
      \wk[out=-165,in=-15]{c4}{b1}
    \end{tikzinline}}
\end{gather*}
% \begin{gather*}
%   x\GETS1\SEMI y^\modeRA\GETS 1
%   \PAR
%   x\GETS 2\SEMI
%   r\GETS y^\modeSC \SEMI 
%   r\GETS x \SEMI 
%   r\GETS x
%   \\[-1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{1}}{}
%       \event{b}{\DW[\modeRA]{y}{1}}{right=of a}
%       \sync{a}{b}
%       \event{c}{\DW{x}{2}}{below=of a}
%       \event{d}{\DR[\modeSC]{y}{1}}{right=of c}
%       \po{c}{d}
%       \event{e}{\DR{x}{2}}{right=of d}
%       \po{d}{e}
%       \event{f}{\DR{x}{1}}{right=of e}
%       \po[out=10,in=170]{d}{f}
%       \rf{b}{d}
%       %\rf[out=-10,in=-170]{c}{e}
%       \wk{a}{c}
%       %\rf[out=15,in=150]{a}{f}
%       \wk[out=-165,in=-15]{f}{c}
%     \end{tikzinline}}
% \end{gather*}
The order from $(\DR{x}{1})$ to $(\DW{x}{2})$ is required to fulfill $(\DR{x}{1})$. %by fulfillment.

% Program order is only imposed from read to write when the precondition of
% the write is weakened.  Thus we have:
% \begin{displaymath}
%   \aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\DW{y}{1}}{}
%   \event{rx1}{\DR{x}{1}}{left=of wy1}
% \end{tikzdisplay}
% Since no order is imposed, the two actions can be reordered.
% Let $\aCmd$ be the program above.  The existence of this pomset is justified
% by the triple
% $\hoare{\TRUE}{\aCmd}{y=1}$.

Item \ref{5a} imposes order from read to write when weakening the
precondition of the write via \ref{4b}, as on the left hand side of
\eqref{ex-2}.
% \begin{gather*}
%   r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wy1}{1\geq0\mid\DW{y}{1}}{}
%       \event{rx1}{\DR{x}{1}}{left=of wy1}
%       \po{rx1}{wy1}
%     \end{tikzinline}}
% \end{gather*}
Item \ref{4b} \emph{allows} a precondition to weaken, but does not \emph{require} it.
Item \ref{5a} only requires order when the precondition weakens.
Thus, no order is required in: % the following execution:
\begin{gather*}
  \aCmd=(r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI)
  %\label{ex555}
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{x{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
The existence of this pomset is justified
by the Hoare triple $\hoare{x\geq0}{\aCmd}{y=1}$.  It is not justified by the value of the read
action.  

Nonetheless, item \ref{4b} requires that the value of the read action must
be \emph{consistent} with subsequent formulae, via
$\labelingForm(\aEv)[\aVal/\aLoc]$.  In this example, the pomset becomes inconsistent
if ${-}2$ is read for $x$:
\begin{gather*}
  % r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  % \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \nonevent{wy1}{{-2}{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{{-2}}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
This holds for all preceding reads, unless the precondition is discharged by
introducing order.  Thus, $\sem{s\GETS x\SEMI \aCmd}$ contains the
pomset on the left below, but not that inconsistent ``pomset'' on the right:
\begin{align*}
  % s\GETS x\SEMI \aCmd
  % \\[-1ex]
  % \nonumber
  \hbox{\begin{tikzinline}[node distance=.3em]
      \event{wy1}{1{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=1em of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      \po{rx1}{wy1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
  &&
  \hbox{\begin{tikzinline}[node distance=.3em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
\end{align*}

Like item \ref{4b}, which substitutes $[\aVal/\aLoc]$ during a read, Candidate
\ref{cand:ord} substitutes $[\aExp/\aLoc]$ during a write.  Like \ref{4b}, this
affects subsequent preconditions, either allowing them to weaken, or
requiring them to strengthen.  For write prefixing, however, there is no rule
corresponding to item \ref{5a}. Unlike a read event, order is \emph{not} imposed from
a write event to the subsequent events whose precondition it weakens:
\begin{align*}
\begin{gathered}
  x \GETS 0\SEMI \aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{0{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{0}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  x \GETS {-}2\SEMI\aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{{-}2}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}
In the JMM causality test cases \citep{PughWebsite}, such executions are justified via
compiler analysis, possibly in collusion with the scheduler: If every 
observed value can be shown to satisfy a precondition, then the precondition
can be dropped.  For
example, \ref{TC1} determines that the following top-level execution should be
allowed, as it is in our model:
\begin{gather*}
  \taglabel{TC1}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y)
  \\
  \hbox{\begin{tikzinline}[node distance=1em and 2em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \po{ry1}{wx1}
  \rf[out=140,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gather*}
In this example, $(\DW{x}{0})$ ``fulfills'' the read of $x$ that is used in
the guard of the conditional.  This is possible when prefixing $(\DR{x}{1})$
performs the substitution $[x/r]$, but does not weaken the resulting
precondition $(x\geq0\mid\DW{y}{1})$.  Subsequently prefixing $(\DW{x}{0})$
substitutes $[0/x]$, resulting in the tautological precondition
$(0\geq0\mid\DW{y}{1})$.  Note that the execution does not have an action
$(\DR{x}{0})$.

This execution is an example of an \emph{internal read}, using \armeight{}
terminology \cite{DBLP:journals/pacmpl/PulteFDFSS18}. Unlike
\citep{DBLP:conf/lics/JeffreyR16}, our semantics is robust with respect to
the introduction of concurrent writes, as in \ref{TC9}:
\begin{gather*}
  \taglabel{TC9}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y
  \PAR
  x\GETS {-2})
  \\
  \hbox{\begin{tikzinline}[node distance=1em and 2em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wx2}{\DW{x}{{-2}}}{below right=-.2em and 2em of wy1}
  \po{ry1}{wx1}
  \rf[out=140,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
  \wk{wx1}{wx2}
    \end{tikzinline}}
\end{gather*}

The reasoning for \ref{TC2} is similar, but in this case no value is necessary to
satisfy the precondition:
\begin{gather*}
  \taglabel{TC2}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
  \\[-1ex]
  \nonumber
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{x{=}x\mid\DW{y}{1}}{right=of a2}
  % \po{a2}{a3}
  % \po[out=15,in=165]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=2em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=162,in=15]{b2}{a2}
  \rf[out=162,in=15]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
Note that in the prefix
\begin{math}
  \sem{s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI},
\end{math}
the precondition on $(\DW{y}{1})$ must imply $r=1 \land r=x$.  The first conjunct is
imposed by \ref{4b}, the second by \ref{5a}.  Thus the two reads must see the same value.

Write substitution only effects subsequent reads, and a read action always
creates an event that must be fulfilled.  In combination, these ensure that an
\emph{internal read} cannot ignore a blocking write.  In the
following execution candidate, there is no order from $(\DR{x}{1})$ to
$(\DW{y}{1})$, potentially allowing the program to write a stale value.
However, $(\DR{x}{1})$ cannot be fulfilled, causing the execution candidate
to be disallowed:
\begin{gather*}
  \taglabel{Internal1}
  x\GETS1 \SEMI
  a\REL\GETS1 \SEMI
  \IF{b\ACQ}\THEN  y\GETS x \FI
  \PAR
  \IF{a\ACQ}\THEN  x\GETS 2\SEMI b\REL\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=.8em and 1em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{a}{1}}{right=of a1}
  \sync{a1}{a2}
  \event{b3}{\DRAcq{a}{1}}{below=of a2}
  \rf{a2}{b3}
  \event{b4}{\DW{x}{2}}{right=of b3}
  \sync{b3}{b4}
  \event{b5}{\DWRel{b}{1}}{right=of b4}
  \sync{b4}{b5}
  \event{a6}{\DRAcq{b}{1}}{above=of b5}
  \rf{b5}{a6}
  \event{a7}{\DR{x}{1}}{right=of a6}
  \sync{a6}{a7}
  \event{a8}{\DW{y}{1}}{right=of a7}
  \graypo{a7}{a8}
  \sync[out=10,in=170]{a6}{a8}
    \end{tikzinline}}
\end{gather*}
The execution becomes inconsistent if we change $(\DR{x}{1})$ to
$(\DR{x}{2})$, resulting in
$(2{=}1\mid\DW{y}{1})$.

Internal reads are notoriously difficult to get right.  Consider Example 3.6
of \citet{DBLP:journals/pacmpl/PodkopaevLV19}: \textcolor{red}{Bad break}
\begin{gather*}
  \taglabel{Internal2}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\SEMI
  \bReg\GETS y\SEMI
  z\GETS \bReg
  %z\GETS y
  \PAR
  x\GETS z
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DWRel{y}{1}}{right=of a1}
  \sync{a1}{a2}
  \event{a3}{\DR{y}{1}}{right=of a2}
  \event{a4}{1{=}1\mid\DW{z}{1}}{right=of a3}
  \rf{a2}{a3}
  %\po{a3}{a4}
  \event{b1}{\DR{z}{1}}{right=2em of a4}
  \event{b2}{\DW{x}{1}}{right=of b1}
  %\po[out=10,in=170]{a2}{a4}
  \po{b1}{b2}
  \rf{a4}{b1}
  \rf[out=170,in=10]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
This behavior is allowed in our model, as it is in \armeight.
%Revisiting \eqref{Internal2}, %the example,
Note that $\sem{z\GETS \bReg}$ includes $(\bReg{=}1\mid \DW{z}{1})$.
Prepending a read,
% of Definition~\ref{def:rw:local},
$\sem{\bReg\GETS y \SEMI z\GETS \bReg}$ may update the precondition to
$(y{=}1\mid \DW{z}{1})$ without introducing order.
%Crucially, there is no explicit read event.
Further prepending
$(\DWRel{y}{1})$ results in $(1{=}1\mid \DW{z}{1})$.

Our model drops order into actions that depend on a read that can be
fulfilled \emph{internally}, by a prefixed write.  This is natural
consequence of substitution.  The \armeight{} model has to jump through
some hoops to ensure that internal reads are handled correctly.  \armeight{}
takes the symmetric approach: rather than dropping order \emph{out of} an
internal read, \armeight{} drops the order \emph{into} it.  This difference
complicates the proof for \armeight{} (\textsection\ref{sec:arm}).

% performs the substitution $(y=1\mid \DW{z}{1})[1/y]$ resulting in a
% tautology.
% By removing the read event, the outcome is
% allowed by our semantics, enabling efficient compilation to \armeight:
% \begin{gather}
%   \label{inlining}
%   % \aReg\GETS x\SEMI
%   % y\REL\GETS 1\SEMI
%   % z\GETS y
%   % \PAR
%   % x\GETS z
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%   \event{a1}{\DR{x}{1}}{}
%   \event{a2}{\DWRel{y}{1}}{right=of a1}
%   \po{a1}{a2}
%   \internal{a3}{\DR{y}{1}}{right=of a2}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   %\rf{a2}{a3}
%   \graypo{a3}{a4}
%   \event{b1}{\DR{z}{1}}{right=of a4}
%   \event{b2}{\DW{x}{1}}{right=of b1}
%   %\po[out=10,in=170]{a2}{a4}
%   \po{b1}{b2}
%   \rf{a4}{b1}
%   \rf[out=170,in=10]{b2}{a1}
%     \end{tikzinline}}
% \end{gather}

\labeltext{As}{page:inlining} a side note, \ref{Internal2} shows that---like most relaxed models---our model
fails to validate \emph{thread inlining}: The execution above is impossible
for
\begin{math}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\PAR
  \bReg\GETS y\SEMI
  z\GETS \bReg
  \PAR
  x\GETS z.
\end{math}
The write in the first thread cannot discharge the precondition in the
second.


\subsection{Relaxed Write Elimination}
\label{sec:rwe}
We discuss compiler optimization in \textsection\ref{sec:opt}.  Irrelevant
reads have no effect in our model, thus we can define correctness with
respect to pomsets that have been saturated with arbitrary irrelevant reads.
The same does not hold for writes.

In our final definition of the semantics, we allow for the possibility of
relaxed write elimination:

% In the semantics thus far, we have supposed that every read must be fulfilled
% by a matching write action, and that the order between them must therefore be
% part of the global pomset order.  This is overly restrictive for reads that
% are fulfilled locally.

% Consider Example 3.6 from
% \citet{DBLP:journals/pacmpl/PodkopaevLV19}:
% \begin{gather*}
%   %\tag{$\dagger$}
%   \label{Internal2}
%   \aReg\GETS x\SEMI
%   y\REL\GETS 1\SEMI
%   \bReg\GETS y\SEMI
%   z\GETS \bReg
%   %z\GETS y
%   \PAR
%   x\GETS z
%   \\
%   \nonumber
%   \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%   \event{a1}{\DR{x}{1}}{}
%   \event{a2}{\DWRel{y}{1}}{right=of a1}
%   \po{a1}{a2}
%   \event{a3}{\DR{y}{1}}{right=of a2}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   \rf{a2}{a3}
%   %\po{a3}{a4}
%   \event{b1}{\DR{z}{1}}{right=2em of a4}
%   \event{b2}{\DW{x}{1}}{right=of b1}
%   %\po[out=10,in=170]{a2}{a4}
%   \po{b1}{b2}
%   \rf{a4}{b1}
%   \rf[out=170,in=10]{b2}{a1}
%     \end{tikzinline}}
% \end{gather*}
% This behavior is allowed by \armeight, but disallowed in the model presented
% thus far, due to the evident cycle.

% To allow this outcome, we remove the requirement for an explicit read action
% when a read is matched by a local write---and, symmetrically, for an explicit
% write action when a write is only used to match local reads.  We treat
% only relaxed local access in this section, extending to $\modeRA$/$\modeSC$
% local access after
% introducing fences in \textsection\ref{sec:variants}.
% % We first give the semantics of read.
% % \begin{definition} \ \vspace{-1ex}
% %   %\label{def:rw:local}
% %   \begin{align*}
% %     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
% %     \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
% %     % \\[-.5ex] &
% %     % % \mkern2mu\cup
% %     % \;\mathhl{\cup\;
% %     %   % (\iDRmode{\aLoc}{}) \prefix
% %     %   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
% %     %   \sem{\aCmd}[\aLoc/\aReg]
% %     %   % \text{ else $\emptyset$}
% %     % }
% %   \end{align*}
% % \end{definition}

% As in \eqref{ex555}, Item \ref{4b} (Definition \ref{def:pre-sc}) ensures that
% intervening writes are respected.  For example, 
% \begin{math}
%   {x\GETS 0\SEMI x\GETS 1\SEMI y\GETS x}
% \end{math}
% cannot write $0$ to $y$.
% %does not $\DW{y}{0}$.
% % NEED TO MAKE THIS POINT:
% % So consider the single threaded program

% % x=4; x=5; y=x;

% % Clearly, this should not be able to give us Wy1.
% % Here is why that is not possible:

% % [[ y=1 ]] contains (Wy1)

% % [[ if(r==4){y=1} ]] contains (r==4|Wy1)

% % [[ r=x; if(r==4){y=1} ]] contains (Rx5)  (x==4|Wy1) // with no order

% % [[ x=5; r=x; if(r==4){y=1} ]] contains (Wx5)-->(Rx5)  (5==4|Wy1) // 5 is forced.


% % Consider the program variant:

% % x=0; r=x; if(r<2){y=1} || x=5

% % [[ y=1 ]] contains (Wy1)

% % [[ if(r<2){y=1} ]] contains (r<2|Wy1)

% % [[ r=x; if(r<2){y=1} ]] contains (Rx5)  (x<2|Wy1)  //with no order

% % [[ x=0; r=x; if(r<2){y=1} ]] contains (Wx0)  (Rx5)  (x<2|Wy1) //does not work, since violates (6a) () implies ()[/].


% % 6. if  externally reads  from  then both 
% % (6a) () implies ()[/], and 
% % (6b) if  is a write then either  <  or () implies ()





\begin{definition}
  \label{def:cover}
  Let $(\relfilt[\modeRLX]{\aLoc} \aPSS)$ be the set $\aPSS'\subseteq\aPSS$ such that
  $\aPS'\in\aPSS'$
  when %$\Event$ contains a write to $\aLoc$ and
  %there is some $\cEv'\in\Event'$ that writes $\aLoc$ and
  for every release $\aEv'\in\Event'$, %that does not write $\aLoc$,
  there is some $\bEv'\in\Event'$ 
  such that $\bEv' \le\aEv'$ and $\bEv'$ \externally  writes $\aLoc$.  % For $\amode\neq\modeRLX$, let
  
  Let $(\relfilt[\modeRA]{\aLoc} \aPSS)=(\relfilt[\modeSC]{\aLoc} \aPSS)=\emptyset$.
  %Let $(\relfilt[\amode]{\aLoc} \aPSS)=\emptyset$ when $\amode\neq\modeRLX$.
  % $(\relfilt {\aLoc} \aPSS)$ be the empty set.
  \begin{align*}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
    % \\[-.5ex] &
    % % \mkern2mu\cup
    % \;\mathhl{\cup\;
    %   % (\iDRmode{\aLoc}{}) \prefix
    %   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
    %   \sem{\aCmd}[\aLoc/\aReg]
    %   % \text{ else $\emptyset$}
    % }
    \\
    \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
    \;\;\textstyle\parallel_\aVal\, (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
    \\[-.5ex] &
    %\mkern2mu\cup
    \;\mathhl{\cup\;
      % (\iDWmode{\aLoc}{}) \prefix
      %\text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
      (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
      % \text{ else $\emptyset$}
    }
  \end{align*}
\end{definition}

The use of $\relfilt{}$ in the definition prevents the eliminated write
rule from applying immediately before a release.  This prevents bad
executions such as:
\begin{gather*}
  \taglabel{Cover}
  x\GETS 1\SEMI
  x\GETS 2\SEMI
  y\REL\GETS 1
  \PAR
  \aReg\GETS y\ACQ \SEMI \bReg\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \internal{a2}{\DW{x}{2}}{right=of a1}
  \graywk{a1}{a2}
  \event{a3}{\DWRel{y}{1}}{right=of a2}
  \graypo{a2}{a3}
  \event{b1}{\DRAcq{y}{1}}{right=2em of a3}
  \rf{a3}{b1}
  \event{b2}{\DR{x}{1}}{right=of b1}
  \sync{b1}{b2}
  \rf[out=10,in=170]{a1}{b2}
  \sync[out=-10,in=-170]{a1}{a3}
    \end{tikzinline}}
\end{gather*}
In this drawing, we have included a ``non-event''---dashed border---to mark
the eliminated write.


\subsection{Litmus Tests}
Our model gives the desired results for the test cases of \citet{PughWebsite},
\citet[\textsection 5.3]{SevcikThesis}, and \citet[\textsection
4]{DBLP:conf/esop/BattyMNPS15}.  It also agrees with the ``surprising and
controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}.
We present two examples that are hallmarks of \mca{} architectures.
The analysis follows from a few simple principles.  
% \begin{gather*}
%   \renewcommand{\arraycolsep}{1pt}
%   \hbox{\small
%     $\begin{array}{ccccc}
%     &x\GETS0\SEMI x\GETS 1
%     &\PAR&
%     r\GETS x \SEMI s\GETS y
%     %\IF{x}\THEN r\GETS y \FI
%     \\
%     \PAR
%     &y\GETS0\SEMI y\GETS 1
%     &\PAR&
%     r\GETS y \SEMI s\GETS x
%     %\IF{y}\THEN s\GETS x \FI
%   \end{array}$}
%   \quad
%   \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \rf{wx1}{rx1}
%   \rf[bend left]{wy0}{ry0}
%   \rf{wy1}{ry1}
%   \rf[bend right]{wx0}{rx0}
%   \wk{rx0}{wx1}
%   \wk{ry0}{wy1}
%     \end{tikzinlinesmall}}
% \end{gather*}
\begin{gather*}
  \taglabel{MCA1}
  \\[-2.5ex]
  \renewcommand{\arraycolsep}{1pt}
  \hbox{\small
    $\begin{array}{ccccc}
    &x\GETS0\SEMI x\GETS 1
    &\PAR&
    r\GETS x\ACQ \SEMI s\GETS y
    %\IF{x}\THEN r\GETS y \FI
    \\
    \PAR
    &y\GETS0\SEMI y\GETS 1
    &\PAR&
    r\GETS y\ACQ \SEMI s\GETS x
    %\IF{y}\THEN s\GETS x \FI
  \end{array}$}
  \quad
  \smash{\hbox{\begin{tikzinlinesmall}[baseline=-10pt,node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DRAcq{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \sync{rx1}{ry0}
  \sync{ry1}{rx0}
    \end{tikzinlinesmall}}}
  \\[-1ex]
\end{gather*}
In this variant of \iriw\ (Independent Reads of Independent Writes), order 
is imposed by \emph{coherence} (between the writes), \emph{fulfillment}
(between read and write), and \emph{fencing} (from acquiring read to relaxed read).
Given the evident cycle, the candidate execution is invalid.
% Note that if you enforce the dependency between the reads, then the execution
% is disallowed, because the is a cycle on weak edges restricted to $x$:
% \begin{math}
%   (\DW{x}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
% then
% \begin{math}
%   (\DW{y}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
It is also impossible for all threads to read $1$ in the following, due to
\emph{control dependencies}, \emph{coherence}, and \emph{fulfillment}.
\begin{gather*}
  \taglabel{MCA2}
  \hbox{\small$\IF{x}\THEN y\GETS0 \FI \SEMI y\GETS1
  {\PAR}
  \IF{y}\THEN z\GETS0 \FI \SEMI z\GETS1
  {\PAR}
  \IF{z}\THEN x\GETS0 \FI \SEMI x\GETS1
  $}
  \\[-.5ex]
  \hbox{\begin{tikzinlinesmall}[node distance=1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DW{y}{0}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \wk{a2}{a3}
  \event{b1}{\DR{y}{1}}{right=of a3}
  \event{b2}{\DW{z}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{z}{1}}{right=of b2}
  \wk{b2}{b3}
  \event{c1}{\DR{z}{1}}{right=of b3}
  \event{c2}{\DW{x}{0}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DW{x}{1}}{right=of c2}
  \wk{c2}{c3}
  \rf{a3}{b1}
  \rf{b3}{c1}
  \rf[out=173,in=7]{c3}{a1}  
    \end{tikzinlinesmall}}
\end{gather*}

In either example, the execution is allowed if the cycle is broken---for
example, by changing $x\ACQ$ to $x\RLX$ in 
\ref{MCA1}.


% \citet{PughWebsite} developed a set of twenty {causality test cases} in the
% process of revising the Java Memory Model (JMM)
% \cite{Manson:2005:JMM:1047659.1040336}.
% %Using hand calculation, we have confirmed that
% Our model gives the desired result for all twenty cases,
% unrolling loops as necessary.
% % confirmed that our model gives the desired result these test cases, with the
% % following caveats: to model TC14 and TC15 we must unroll loops; the behaviors
% % of TC1 and TC8 are only allowed in our model if the inferred range of
% % variables is included as a global assumption in the logic. 
% Our model also gives the desired results for the examples of
% \citet{PughWebsite}, \citet[\textsection 5.3]{SevcikThesis},
% \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15}.  Our model agrees with
% ``surprising and controversial behaviors'' of
% \citet[\textsection 8]{Manson:2005:JMM:1047659.1040336}.  We elide the
% details.
% \textsection\ref{sec:examples} develops some of these examples.





% \subsection{Par-closure and Case Analysis}
% Par closure.
% \begin{definition}
%   \label{def-par-closed}
%   $\aPSS$ is \emph{par-closed} if $\aPS^i\!\in\aPSS$ implies $\aPS^1\!{\PAR}\aPS^2\!\in\aPSS$\!\!.
% \end{definition}

% \begin{definition}
%   Let $\aPS'\in\sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd}$ if
%   \begin{math}
%     \aPS'= %(\iDRmode{\aLoc}{}) \prefix
%     \sem{\aCmd}[\aLoc/\aReg]
%   \end{math}
%   or
%   \begin{math}
%     \aPS'=\parallel_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%   \end{math}
%   where $\aPS\in\sem{\aCmd}[\aLoc/\aReg]$ and $\aForm_k$ are
%   disjoint\footnote{For $i$, $j$ in $K$: if $\aForm_i \land \aForm_j$ is
%     satisfiable then $i=j$.}.
% \begin{align*}
%     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
%     \textstyle\bigcup_K\; \parallel_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDRmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     \sem{\aCmd}[\aLoc/\aReg]
%     %\text{ else $\emptyset$}
%     \\
%     \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & \eqdef
%     \parallel_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDWmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
%     %\text{ else $\emptyset$}
% \end{align*}
% \end{definition}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
