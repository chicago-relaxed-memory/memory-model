\section{The Model}
\label{sec:model}

We define the model and give the semantics of a concurrent language.  We
layer the presentation, beginning with a simple language that supports only
read and write operations.  In \textsection\ref{sec:variants}, we define
extensions that incorporate address computation, fences, and
read-modify-write operations.  As is common for work on relaxed memory, we
treat loops via unrolling: loops introduce complexities---such as liveness
and continuity---that are orthogonal to the main topic of the paper.
\begin{comment}
https://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/

Cannot encode R/A actions with actions+fences...

A release operation prevents preceding memory operations from being delayed
past it (a;Rel =/=> Rel;a)
 
A release fence prevents preceding memory operations from being delayed past
subsequent writes (a;FR;w =/=> w;a;FR)

An acquire operation prevents subsequent memory operations from being advanced
before it (Acq;a =/=> a;Acq)

An acquire fence prevents subsequent memory operations from being advanced
before prior reads (r;FA;a =/=> FA;a;r)

https://www.modernescpp.com/index.php/fences-as-memory-barriers

StoreLoad: Full fence allows a store before to be reordered with respect to a
load after (wx;F;ry) ===> (ry;F;wx)

StoreLoad+LoadLoad: Release fence also allows (rx;FR;ry) ===> (ry;FR;rx)

StoreLoad+StoreStore: Acquire fence also allows (wx;FR;wy) ===> (wy;FR;wx)

LoadStore: No fence allows a prior load to reorder w.r.t. a subsequent store
(rx;FR;wy) =/=> (wy;FR;rx)

https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/
Good news is that a fullFence does it.

Bizarrely, it seems this is not supported in C++... You have to go to assembly.
\end{comment}

\paragraph{Data models.}
A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\cVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$, and $\cExp$, % and $\dExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by $\aLoc$ and
  $\bLoc$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$, and
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$.
\end{itemize}

Let $\aSub$ range over substitutions of the form
$[\aLoc/\aReg]$ or $[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item values, registers, and memory locations are disjoint,
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
%\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations, % or the operator $\REF{\aExp}$,
\item formulae include at least %$\TRUE$, $\FALSE$, and
  equalities %of the form
  $(\aExp=\aVal)$, % and $(\REF{\aExp}=\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution\footnote{Since formulae are closed under substitutions of the
    form $\aForm[\aLoc/\aReg]$, they must include equalities of the form
    $(\aEExp=\aVal)$ where $\aEExp$ is an \emph{extended expression} that
    includes memory locations.  By composition, formulae must also be closed
    under that substitutions of the form
    $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.}, and
\item there is a relation $\vDash$ between formulae.
\end{itemize}

We use expressions as formulae, coercing $\aExp$ to $\aExp\neq 0$.

For the actions of a data model, we require that
% \begin{itemize}
% \item
  there are partial functions $\rreads$ and
  $\rwrites: \Act \fun (\Loc \times \Val)$, and
%\item
  there are subsets of $\Act$: $\Acq$, $\Rel$, $\SC$, and $\Term$.
  % such that
  % $\SC\cap\fdom(\rreads)\subseteq\Acq$,
  % $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
  % and
  % $\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.
  % , and
% \item there is a function $\finternalize: \Act \fun \Act$ that
%   satisfies the restrictions given below.
%\end{itemize}

% $\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes to}
% $\aLoc$ when $\rwrites(\aAct) = (\aLoc,\aVal)$, for some $\aVal$. % (possibly $\bot$).
%
% Actions that read or write values are \emph{external},
% actions that read or write $\bot$ are \emph{internal}.
% % Actions in
% % $\Ext=\fdom(\rreads)\cup\fdom(\rwrites)$ are \emph{external}, whereas those
% % in $\Int=\Act\setminus\Ext$ are \emph{internal}.
%
  We say that $\aAct$ is a \emph{read} if $\aAct\in\fdom(\rreads)$, $\aAct$ is a
  \emph{write} if $\aAct\in\fdom(\rwrites)$, $\aAct$ is an \emph{acquire} if
  $\aAct\in\Acq$, $\aAct$ is a \emph{release} if $\aAct\in\Rel$, $\aAct$ is a \emph{termination} if
  $\aAct\in\Term$,  and $\aAct$ is \emph{SC} if
  $\aAct\in\SC$.  Note that these are \emph{not} disjoint.
% % We say that $\aAct$ is a
% % \emph{synchronization} if it is either a release or an acquire.
When $\rreads(\aAct) = (\aLoc,\aVal)$, we say that $\aAct$ \emph{reads}
$\aVal$ \emph{from} $\aLoc$, and similarly for writes.

We require that every SC read is an acquire, and every SC write is a release.
% $\SC\cap\fdom(\rreads)\subseteq\Acq$,
% $\SC\cap\fdom(\rwrites)\subseteq\Rel$,
% and
We also require that termination events are releasing, but do not read,
write, or acquire.
%$\disjoint{\Term}{(\Acq\cup\Rel\cup\SC\cup\fdom(\rreads)\cup\fdom(\rwrites))}$.


% The actions listed above are \emph{external}.  Each external action has a
% corresponding \emph{internal} action, denoted by prefixing $\tau$.  Internal
% actions also read and write locations, just as external actions do,
% but are not used to model communication between threads,
% so we do not record their value.
% \footnote{Fences have a limited role in our
% discussion.  We inappropriately refer to them as synchronizations for
% simplicity.}.


Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.  Formulae are \emph{open}, in that
occurrences of register names and memory locations are subject to
substitutions of the form $\aForm[\aLoc/\aReg]$ and $\aForm[\bExp/\aLoc]$.
% where %$\aLoc$ is a memory location, $\aReg$ is a register and
% $\bExp$ is an
% memory-location-free expression.
Actions are not subject to substitution.


% % We require that $\finternalize$ satisfy the following:
% % \begin{itemize}
% % \item $\finternalize(\aAct)$ reads $\bot$ from $\aLoc$ exactly when $\aAct$ reads from $\aLoc$,
% % \item $\finternalize(\aAct)$ writes $\bot$ to $\aLoc$ exactly when $\aAct$ writes to $\aLoc$,
% % %\item the codomain of $\finternalize$ includes only internal actions, %$\fcodom(\finternalize)\subseteq\Int$,
% % \item $\finternalize(\aAct)$ is an acquire exactly when $\aAct$ is an acquire, 
% % \item $\finternalize(\aAct)$ is a release exactly when $\aAct$ is a release, and
% % \item $\finternalize(\aAct)$ is SC exactly when $\aAct$ is SC. 
% % \end{itemize}

% As noted in \textsection\ref{sec:model:intro}, our example language includes
% SC read $(\DRSC{\aLoc}{\aVal})$, acquiring
% read $(\DRAcq{\aLoc}{\aVal})$, relaxed read $(\DR{\aLoc}{\aVal})$, SC write
% $(\DWSC{\aLoc}{\aVal})$, releasing
% write $(\DWRel{\aLoc}{\aVal})$, and relaxed write $(\DW{\aLoc}{\aVal})$.
% For each external action, we also define a corresponding internal action
% %which replaces the letter $\mathsf{R}$ or $\mathsf{W}$ with $\tau$.
% $(\iDRSC{\aLoc}{\aVal})$,
% $(\iDRAcq{\aLoc}{\aVal})$,
% $(\iDR{\aLoc}{\aVal})$,
% $(\iDWSC{\aLoc}{\aVal})$,
% $(\iDWRel{\aLoc}{\aVal})$, and
% $(\iDW{\aLoc}{\aVal})$.
% In pictures, we draw internal actions grayed out,
% rather than using $\bot$.  % For example, the ``read'' action is internal in:
% % \begin{tikzdisplay}[node distance=1em]
% %   \event{wx1}{\DW{x}{1}}{}
% %   \internal{rx1}{\DR{x}{1}}{below right=of rx1}
% %   \event{wy1}{\DW{y}{1}}{above right=of wy0}
% %   \po{wx1}{wy1}
% % \end{tikzdisplay}

%We also include acquire-release fences of the form $(\DF)$.

% In examples, we use fence actions of the form $(\DF{\aF})$, where the annotation
% indicates that the fence is a release ($\FR$), an acquire ($\FA$) or both ($\FF$):
% \begin{displaymath}
%   \aF\BNFDEF\FR\BNFSEP\FA\BNFSEP\FF
% \end{displaymath}

% \subsection{3-valued pomsets with preconditions}

% Fix an alphabet $\Alphabet=(\Formulae\times\Act)$.

For the formulae of the data model,
we say that $\aForm$ is \emph{independent of $\aLoc$} when, for every $\aVal$,
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$. We say that
$\aForm$ is \emph{dependent on $\aLoc$} otherwise.  We say that $\aForm$ is
\emph{location independent} if it is independent of every location.

We say that $\aForm$ \emph{implies} $\bForm$ when $\aForm\vDash\bForm$,
that $\aForm$ is a \emph{tautology} when $\TRUE\vDash\aForm$, and that
$\aForm$ is \emph{unsatisfiable} when $\aForm\vDash\FALSE$.

\paragraph{Example Language.}
Our example language includes actions of the form
$(\DSTOP)$, which is a \emph{termination},
$(\DR[\amode]{\aLoc}{\aVal})$, which \emph{reads}  $\aVal$ from
$\aLoc$ and $(\DW[\amode]{\aLoc}{\aVal})$, which \emph{writes} $\aVal$ to
$\aLoc$.
% The \emph{mode} $\amode$ is either \emph{relaxed} ($\modeRLX$),
% \emph{release-acquire} ($\modeRA$) or \emph{sequentially-consistent} ($\modeSC$).
The \emph{access mode} $(\amode \!\!\BNFDEF\!\! \modeRLX \!\BNFSEP\! \modeRA \!\BNFSEP\! \modeSC)$ is
either \emph{relaxed}, \emph{release-acquire}, or
\emph{sequentially-consistent}.
$\modeRA$/$\modeSC$ reads are acquires, and $\modeRA$/$\modeSC$ writes are releases.

We elide the $\modeRLX$-mode annotation in examples.
% We write $\modeREL$ and $\modeACQ$ as synonyms for $\modeRA$.
\begin{comment}
\footnote{We only consider executions where register state is empty in
  forked threads.  Given item~\ref{pre-acquire} of
  Definition~\ref{def:prefix}, a sufficient condition is that parallel
  composition is always preceded by an acquire fence, as in programs of the
  form:
  \begin{displaymath}
    \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
  \end{displaymath}
  where $\aCmd^1$, \ldots, $\aCmd^n$ do not include $\PAR$.  To avoid clutter
  in drawings, we often drop the explicit fence.}.
\end{comment}
% \begin{align*}
% \aCmd,\,\bCmd
% \BNFDEF& \SKIP \tag{No Operation}
% \\[-1ex]\BNFSEP& \FENCE\SEMI \aCmd \tag{Full fence}
% \\[-1ex]\BNFSEP& \REF{\cExp}\GETS\aExp\SEMI \aCmd \tag{Relaxed write to memory}
% \\[-1ex]\BNFSEP& \REF{\cExp}\REL\GETS\aExp\SEMI \aCmd \tag{Releasing write to memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\SEMI \aCmd \tag{Relaxed read from memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\ACQ\SEMI \aCmd
% \\[-1ex]\BNFSEP& \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
% \\[-1ex]\BNFSEP& \aCmd \PAR \bCmd
% \\[-1ex]\BNFSEP& \VAR\aLoc\SEMI \aCmd
% \end{align*}
%The syntax of statements is as follows.


We define the language by prefixing individual reads and writes.  In
\textsection\ref{sec:semicolon} we provide an equivalent semantics that supports
full sequential composition of the form $(\aCmd\SEMI\bCmd)$.
\begin{align*}
  % \amode \BNFDEF& \modeRLX \BNFSEP \modeRA \BNFSEP \modeSC
  % \\
\aCmd,\,\bCmd
\BNFDEF& \SKIP
\BNFSEP \aReg\GETS\aExp\SEMI \aCmd
\BNFSEP \aReg\GETS\aLoc^{\amode}\SEMI \aCmd 
\BNFSEP \aLoc^{\amode}\GETS\aExp\SEMI \aCmd
\\[-.5ex]
\BNFSEP&\aCmd \PAR \bCmd
\BNFSEP \VAR\aLoc\SEMI \aCmd
\BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\end{align*}




We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.

We write
$\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$ and
$\IF{\aExp} \THEN \aCmd^1 \ELSE \aCmd^2 \FI \SEMI \bCmd$ as shorthand for
$\IF{\aExp} \THEN \aCmd^1 \SEMI \bCmd\ELSE \aCmd^2 \SEMI \bCmd\FI$.
% and
% $\VAR\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for
% $\VAR\aLoc\SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\REL\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\FENCE_{\FR} \SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\ACQ\aReg\GETS\aLoc\SEMI \aCmd$ as shorthand for $\aReg\GETS\aLoc\SEMI \FENCE_{\FA}\SEMI \aCmd$.

\paragraph{Semantic domain.}
Our model is based on \emph{partially ordered multisets}
(\emph{pomsets})~\cite{GISCHER1988199}, ranged over by $\aPS$ and $\bPS$:
\begin{definition}
  \label{def:mmpomset}
  A \emph{(memory model) pomset} is a tuple
  $(\Event, {\le}, %{\gtN},
  \labeling)$: %, such that
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, 
  \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
    from which we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$,
    % define $\labelingForm(\aEv)=\aForm$ and $\labelingAct(\aEv)=\aAct$ when
    % $\labelingForm(\aEv)=(\aForm\mid\aAct)$,
  % \item ${\gtN} \subseteq (\Event\times\Event)$ is a partial order,
  % \item ${\le} \subseteq {\gtN}$ is a partial order, and
  \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
    $\labelingForm(\bEv)$, and
  \item $\bigwedge_{\aEv}\labelingForm(\aEv)$ is satisfiable.
  \end{itemize}
  % A pomset is \emph{completed} if $\exists\aEv.\;\labelingAct(\aEv)=\DSTOP$. % and $\forall\bEv.\;\bEv\le\aEv$.
\end{definition}
% From $\labeling$, we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$.

We also refer {pomsets} as \emph{executions}.
We write pairs in $(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$, eliding
$\aForm$ when it is a tautology.
We write $\bEv\lt\aEv$ when $\bEv\le\aEv$ and $\bEv\neq\aEv$.
We identify pomsets up to isomorphism. %We write the empty pomset as $\emptypomset$.

We lift terminology from logical formulae and actions to events, saying, for example,
that $\aEv$ is \emph{unsatisfiable} if $\labelingForm(\aEv)$ is unsatisfiable,
and that $\aEv$ is a \emph{termination} when $\labelingAct(\aEv)$ is a termination.
We often elide explicit universal quantifiers in phrases such as
``\emph{for all $\aEv$}, $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.''

We expect each pomset to have at most one termination event, which is ordered
after all other events.  A pomset is \emph{completed} if it contains a
termination. %$\exists\aEv.\;\labelingAct(\aEv)=\DSTOP$. % and $\forall\bEv.\;\bEv\le\aEv$.

The formula associated with an event is a \emph{precondition}.
The following commands gives rise to the pomset below them, capturing data
and control dependencies. %, respectively.
\begin{align}
  \label{ex-1}
  \begin{gathered}
    y\GETS r
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r=1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r<0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align}
In mapping the Hoare triple $\hoare{\aForm}{\aCmd}{\bForm}$ to our semantics,
$\bForm$ represents a set of write actions, and $\aForm$ represents their
preconditions.  
% Each write in a pomset corresponds to a Hoare triple, where the formulae
% gives the precondition, and the write action gives the postcondition.  
For example, interpreting the pomset on the left above yields
$\hoare{\aReg =1}{y\GETS \aReg}{y=1}$.

The ordering relation, $\le$, represents \emph{causality}.
The fourth requirement of the definition ensures \emph{causal strengthening:} formulae do not
weaken over time, as measured by $\le$.

The last requirement ensures \emph{compatibility:} a pomset represents a
single execution.  For complete programs, we can restrict attention to events
that are tautological.  Richer formulae are needed for intermediate program
fragments.

% The semantics of programs is given as sets of pomsets, with each pomset
% representing a completed execution.
% %
% We expect sets of pomsets given by the semantics to be closed with
% respect to \emph{augmentation}, \emph{implication} and \emph{isomorphism}:
The semantics of programs is given as sets of pomsets.  The sets of pomsets
are closed with respect to \emph{augmentation}, \emph{prefixing},
\emph{implication}, \emph{disjunction} and \emph{prefix weakening}:
\begin{definition}
  \label{def:closure:properties}
  Let
  $\aPS'$ be an \emph{augmentation} of $\aPS$ if $\Event'=\Event$,
  ${\labeling'}={\labeling}$, and ${\le'}\supseteq{\le}$. 
  Let
  $\aPS'$ be a \emph{prefix} of $\aPS$ if 
  $\Event \supseteq \Event' \supseteq \{ \bEv \in \Event \mid \exists\aEv\in\Event'.\; \bEv\le\aEv\}$,
  ${\le'}={\le}\restrict{\Event'}$, and
  ${\labeling'}={\labeling}\restrict{\Event'}$.  

  Let $\aPS'\in\PRE(\aPSS)$ if  $\aPS'$ is a
  prefix of some $\aPS \in \aPSS$.
  
  Let
  $\aPS'$ \emph{imply} $\aPS$ if $\Event'=\Event$, ${\le'}={\le}$,
  $\labelingAct'=\labelingAct$, and $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$. 
  %
  % Let $\aPS''$ be a \emph{disjunct} of $\aPS^i$ for $i\in I$ if there is some
  % $\aPS'\in\PRE(\aPS'')$ such that $\Event' = \Event^i$, ${\le'}={\le^i}$,
  % $\labelingAct'=\labelingAct^i$, and $\labelingForm'(\aEv)$ implies
  % $\bigvee_i \labelingForm^i(\aEv)$.
  For $i\in I$, let $\aPS'$ be a \emph{disjunct} of $\aPS^i$ if
  $\Event' = \Event^i$, ${\le'}={\le^i}$, $\labelingAct'=\labelingAct^i$, and
  $\labelingForm'(\aEv)$ implies $\bigvee_i \labelingForm^i(\aEv)$.
  %
  Let $\aPS^{2}$ be a \emph{prefix weakening} of $\aPS^1$ by
  $\aPS^{2}{}'\in\PRE(\aPS^{2})$ if $\aPS^1$ implies $\aPS^{2}$ and there is
  some $\aPS^{1}{}'\in\PRE(\aPS^{1})$ such that $\aPS^{1}{}'$ implies
  $\aPS^{2}{}'$.
  % Let
  % $\aPS'$ be an \emph{isomorphism} of $\aPS$ if there is a bijection
  % $f:\Event\fun\Event'$ such that $\labeling(\aEv)=\labeling'(f(\aEv))$, and
  % $\aEv\le\bEv$ iff $f(\aEv)\le'f(\bEv)$. %, and $\aEv\gtN\bEv$ iff $f(\aEv)\gtN'f(\bEv)$.
\end{definition}

% Each pomset $\aPS\in\sem{\aCmd}$ is a \emph{completed} execution of $\aCmd$;
% we sometimes refer to pomsets as \emph{executions}.  Because they are
% completed executions, we do not expect $\sem{\aCmd}$ to be prefixed closed.
% However, implication closure in a memory-model pomset does give something
% similar: any event $\aEv$ can be given an unsatisfiable precondition, which
% means that every event ordered after $\aEv$ must also be unsatisfiable, as
% per Definition~\ref{def:mmpomset}.  In many applications of the model,
% unsatisfiable events are ignored, thus providing a kind of prefix closure.
% % \begin{definition}
% %   $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$, ${\labeling'}={\labeling}$,
% %   ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
% %   and ${\gtN}\subseteq{\gtN'}$. %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$,
% %   % $\labelingAct'=\labelingAct$, and  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.
% %   % if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies $\bForm$.
% % \end{definition}

Each pomset in the semantics of a program has at most one termination event,
which is ordered after all other events.  By causal strengthening, its
precondition must therefore imply the precondition of all other events.

We visualize pomsets as directed graphs.
%where the nodes are drawn from $\Event$, each node $\aEv$ is labeled with $\labeling(\aEv)$, and order is drawn as an edge.
% We often elide events with disjoint
% preconditions---$\aForm$ and $\bForm$ are \emph{disjoint} if
% $\aForm \land \bForm$ is unsatisfiable.  For example, we typically drop
% unsatisfiable events.
 In examples, we draw pomsets that are \emph{completed}, \emph{augmentation\hyp{}minimal} and
 \emph{implication\hyp{}minimal}.  We elide the uninteresting termination
 event.  For example, the semantics of
\begin{math}
  \VAR\aLoc\SEMI(
  x\GETS 0
  \SEMI
  x\GETS 1
  \PAR
  y\GETS x
  \SEMI
  z^\modeRA\GETS 1
  )
  %\aReg\GETS x\SEMI y\GETS \aReg)
\end{math}
includes:
\begin{tikzdisplay}[node distance=2em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=3em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{wz1}{\DWRel{z}{1}}{right=of wy1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \po{rx1}{wy1}
  \sync{wy1}{wz1}
\end{tikzdisplay}
We visualize order using arrows that indicate the reason that the order
arises.
$(\DW{x}{0})\xwk(\DW{x}{1})$ is a \emph{coherence} requirement: the write of $1$
must follow the write of $0$, since these are in \emph{conflict} and in program order.
$(\DW{x}{1})\xrf(\DR{x}{1})$ is a \emph{reads-from} requirement: the read of $x$
must be \emph{fulfilled} by a matching write.
$(\DR{x}{1})\xpo(\DW{y}{1})$ is a \emph{dependency} requirement: the write to $y$
\emph{depends on} the read of $x$.
$(\DW{y}{1})\xsync(\DWRel{z}{1})$ is a \emph{fencing} requirement.
Although we use multiple arrows, we emphasize that they are all part
of the same $\le$ relation.

\paragraph{Semantics of the Example Language.}
In the remainder of this section, we explain the semantics of our example
language.  By far the most complex operators are the prefixing
operators---read and write---which introduce new actions.  We discuss
the other operators first.
% the orders are drawn with
% \citeauthor{DBLP:journals/dc/Lamport86}'s notation.  
% For example:
% \begin{tikzdisplay}[node distance=1em]
%   \event{rx1}{a}{}
%   \event{wy0}{b}{below right=of rx1}
%   \event{wy1}{c}{above right=of wy0}
%   \po{rx1}{wy0}
%   \po{rx1}{wy1}
%   \wk{wy0}{wy1}
% \end{tikzdisplay}
% is a visualization of the pomset where:
% \[\begin{array}{c}
%     E = \{ 0,1,2 \}
%     \quad
%     {\labeling} = \{(0,a),\,(1,b),\,(2,c)\}
%     \\
%     {\le} = \{(0,1),\,(0,2)\}\cup\{(0,0),\,(1,1),\,(2,2)\}
%     \quad
%     {\gtN} = {\le}\cup\{(2,3)\}
% \end{array}\]
% for example:


%The semantics of $\SKIP$ and register assignment are simple:
\begin{definition}
Let $(\aPSS\aSub)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when
there is $\aPS\in\aPSS$ such that:
$\Event' = \Event$,
${\le'} = {\le}$, 
%${\gtN'} = {\gtN}$,and
$\labelingAct'(\aEv) = \labelingAct(\aEv)$, and
$\labelingForm'(\aEv) = \labelingForm'(\aEv)\aSub$.

Let $\aPS\in\stopPS$ when
$\Event = \{ \aEv \}$ and
$\labelingAct(\aEv) = \DSTOP$.
\begin{align*}
  \sem{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
  \sem{\aCmd}[\aExp/\aReg] 
  &  
  \sem{\SKIP} & \eqdef
  \stopPS
\end{align*}
\end{definition}


\begin{definition}
  \label{def:rf}
  We say $\bEv$ \emph{fulfills $\aEv$ on $\aLoc$} if 
  \begin{itemize}    
  \item $\bEv$ \externally writes
    $\aVal$ to $\aLoc$, 
  \item $\aEv$ \externally reads $\aVal$ from $\aLoc$,
  \item
    $\bEv \lt \aEv$, and
  \item
    if $\cEv$ \externally writes to $\aLoc$ then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}

  A pomset is \emph{$\aLoc$-closed} if every \external read on $\aLoc$ is fulfilled,
  and every formula is independent of $\aLoc$
  ($\forall\aVal.\;\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$).
  
  A pomset is \emph{top-level} if it is $\aLoc$-closed for every location
  $\aLoc$.
  
  Let $(\nu\aLoc\!\DOT\!\aPSS)$ be  $\aPSS'{\subseteq}\aPSS$ such that $\aPS'{\in}\aPSS'$
  when $\aPS'$ is $\aLoc$-closed.
\begin{align*}
  \sem{\VAR\aLoc\SEMI \aCmd} & \eqdef
  \nu \aLoc \DOT \sem{\aCmd}  
\end{align*}
\end{definition}

%\paragraph{Fulfillment and Location Binding.}
When a location is bound, every read of that location must be \emph{fulfilled} by a
matching write.  At top-level, fulfillment imposes a total order on
conflicting writes that are read; it does not impose order between unread
writes:
\begin{gather*}
  x\GETS 3
  \PAR
  x\GETS 4
  \PAR
  r\GETS x\SEMI r\GETS x 
  \PAR
  x\GETS 1
  \PAR
  x\GETS2
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{below=of wx1}
  \event{rx1a}{\DR{x}{1}}{left=of wx1}
  \event{rx2a}{\DR{x}{2}}{left=of wx2}
  %\po{rx1a}{rx2a}
  \rf{wx1}{rx1a}
  \rf{wx2}{rx2a}
  \wk{rx1a}{wx2}
  \wk{wx1}{wx2}
  %\event{wx3}{\DW{x}{3}}{below left=-.2em and 1em of rx1a}
  \event{wx3}{\DW{x}{3}}{left=of rx1a}
  \event{wx4}{\DW{x}{4}}{left=of rx2a}
  \wk{rx1a}{wx3}
  \wk{rx2a}{wx3}
  %\wk{rx1a}{wx4}
  \wk{rx2a}{wx4}
    \end{tikzinline}}
\end{gather*}
The restriction of pomset order to conflicting events is called the
\emph{extended coherence order} ($\reco$).  This relation can always be
extended to totally order all conflicting events, as is common in hardware
memory models.

The definition of location binding validates \emph{scope
  extrusion}~\cite{Milner:1999:CMS:329902}: if $\aCmd$ does not
mention~$\aLoc$ then
$\sem{\aCmd\PAR \VAR\aLoc\SEMI\bCmd}\allowbreak=\allowbreak\sem{\VAR\aLoc\SEMI(\aCmd\PAR\bCmd)}$.
However, the definition does not validate renaming of locations: if
$\aLoc\neq\bLoc$ then
$\sem{\VAR\bLoc\SEMI\aCmd}\neq\sem{\VAR\aLoc\SEMI\aCmd[\aLoc/\bLoc]}$,
even if $\aCmd$ does not mention~$\aLoc$.  This is consistent with support
for address calculation, which is required by realistic memory allocators.
%$\nu\aLoc\DOT\aPSS\neq \nu\bLoc\DOT\aPSS[\bLoc/\aLoc]$ when $\bLoc\neq\aLoc$.
% $\nu\aLoc\DOT(\aPSS\parallel\nu\aLoc\DOT\bPSS)$ is generally
% not the same as
% $\nu\aLoc\DOT(\aPSS\parallel(\nu\bLoc\DOT\bPSS[\bLoc/\aLoc]))$.

%\paragraph{Composition, Concurrency and Conditional.}
% Conditional execution is defined using pomset union and filtering, which
% selects pomsets satisfying a formula.

% \begin{definition}
%   Let $\aPS' = (\aPS^1 \cup \aPS^2)$ when $\Event' = \Event^1 \cup \Event^2$,
%   ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
%   ${\labeling'}\supseteq{\labeling^1}\cup{\labeling^2}$.

%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   Let $\aPS'\in \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}$  when
%   $\aPS\cup\aPS^1\in\sem{\aCmd}$,
%   $\aPS\cup\aPS^2\in\sem{\bCmd}$,
%   and ether\bigl(\aExp
%   \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard
%   \sem{\bCmd}\bigr)
% \end{definition}

% Composition is roughly union:
% $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.  For example, we have the
% following execution, which unions the two sides:
% \begin{gather*}
%   \IF{r<0}\THEN y\GETS1\FI
%   \PAR
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gather*}
% In addition to this execution, we allow that events with the same label to
% coalesce, taking the disjunction of their preconditions.  Thus, the semantics
% of this program also includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' = \Event^1 \cup \Event^2$,
% ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
% either
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% \begin{aligned}
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

%\paragraph{Composition, Concurrency and Conditional.}
\begin{definition}
  \label{def:par}
  % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
  % $\Event' \subseteq \Event^1 \cup \Event^2$,
  % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
  % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
  % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
  % unsatisfiable.
  Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
  when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$
  such that
$\Event' = \Event^1 \cup \Event^2$,
$\Event^1$ is completed exactly when $\Event^2$ is completed,
there is at most one termination in $\Event'$,
${\le'}\supseteq{\le^1}\cup{\le^2}$,
and for all $\aEv\in\Event'$,
either:
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^i \mid \exists\aEv\in\Event'.\; \bEv\le^i\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
\begin{gather*}
  \begin{aligned}
    \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
    &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
    &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
  \end{aligned}
  \\
%\end{gather*}
% if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% \labelingForm^2(\aEv)$ is unsatisfiable.
%\begin{gather*}
\begin{aligned}
  \sem{\aCmd \PAR \bCmd} & \eqdef
  \sem{\aCmd} \parallel \sem{\bCmd} 
\end{aligned}
\end{gather*}
\end{definition}

Concurrent composition is roughly union.  Because of the compatibility
requirement in Definition~\ref{def:mmpomset}, we do not include events with
contradictory preconditions.
% : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
Consider:
\begin{align*}
\begin{gathered}
  \IF{r<0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \IF{r\geq0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}
The parallel composition includes pomsets with either one of the two events, but not
both.  However,  events with the same label may coalesce, taking the
disjunction of their preconditions.  Thus, the semantics of the combined
program also includes:
\begin{gather*}
  % \IF{r<0}\THEN y\GETS1\FI
  % \PAR
  % \IF{r\geq0}\THEN y\GETS1\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gather*}
Coalesced events inherit order from both sides.

The definition requires that if $\aPS'\in(\aPS^1 \parallel \aPS^2)$ is completed,
then both $\aPS^1$ and $\aPS^2$ are completed, and further, the completed event
\emph{must} coalesce in $\aPS'$.
% The definition ensures $\Event'$ is downclosed w.r.t.~each $\Event^i$.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}


\begin{definition}
  Let $(\aForm \guard \aPSS)$ be the set $\aPSS'\subseteq\aPSS$ such that
  $\aPS'\in\aPSS'$ when $\aForm$ implies $\labelingForm(\aEv')$, for every
  $\aEv'\in\Event'$. 
  \begin{align*}
    \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
  \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
\end{align*}
\end{definition}
Conditional execution is defined using \emph{filtering}, which selects the
subset of pomsets that imply a formula, and composition, which allows
coalescing using disjunction, as discussed above.  This reflects the Hoare
rule for conditionals:
\begin{displaymath}
  \frac{
    \hoare{\aExp}{\aCmd}{\bForm}
    \quad
    \hoare{\lnot\aExp}{\bCmd}{\bForm}
  }{
    \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
  }
\end{displaymath}
%  For an example
% using the first clause in the definition of composition,
% $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% Conditional execution and concurrency are defined using filtering, which
% selects pomsets satisfying a formula, and composition.  Composition is
% roughly union, ensuring that the combined events are compatible.
% % : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% % $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
% For example, consider:
% \begin{align*}
% \begin{gathered}
%   \IF{r<0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Putting these in parallel, we allow events with the same label to coalesce,
% taking the disjunction of their preconditions.  Thus, the semantics includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
%   % $\Event' \subseteq \Event^1 \cup \Event^2$,
%   % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
%   % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
%   % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
%   % unsatisfiable.

%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% %$\Event' \subseteq \COMPAT(\aPS^1,\,\aPS^2)$,
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^1 \cup \Event^2 \mid
% \exists\aEv\in\Event'.\; \bEv\le^1\aEv \textor \bEv\le^2\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% %\end{gather*}
% % if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% % $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% % \labelingForm^2(\aEv)$ is unsatisfiable.
% %\begin{gather*}
% \begin{aligned}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
%   \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
%   \\
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}


\paragraph{Program Order Prefixing.} % for Trivial Expressions.}
We present several candidate definitions for prefixing before giving the
final definition.  The candidates are progressively more general and less
ordered.  We begin by considering programs with trivial expressions,
including all of program order in pomset order.
To simplify the definition, we construct the set of pomsets with the new
action, then prefix close.

% For programs with only trivial expressions, the simplest candidate
% definitions of read and write result in top-level executions being
% sequentially consistent.
\begin{candidate}
  \label{def:rw:sc1}
  Let $(\aForm \mid \aAct) \prefixsimp \aPSS$ be the set $\PRE(\aPSS')$ where
  $\aPS'\in\aPSS'$ when there is $\aPS\in\aPSS$ such that $\aPS'$ adds a
  new event %with the given label
  that precedes all of the events in $\aPS$.
  \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsimp \sem{\aCmd}}
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS\aVal\SEMI \aCmd} & =
    %\textstyle\bigcup_\aVal\; (\bVal=\aVal \mid
    \smash{\DWmode\aLoc\aVal \prefixsimp \sem{\aCmd}}
  \end{align*}
\end{candidate}
%For now, ignore the preconditions and substitutions. We explain them in the subsections below.

The definition ensures that program order is included in the pomset order.
Due to the requirements of fulfillment, we also have that $\reco$ is included
in pomset order.  As a result, all executions are sequentially consistent.
For example, consider the \emph{store buffering} litmus test:
\begin{gather*}
  x\GETS0\SEMI
  y\GETS0\SEMI
  (
  x\GETS1\SEMI\aReg\GETS y
  \PAR
  y\GETS1\SEMI \aReg\GETS x)
  \\
  \tag{\textsc{sb}}\label{SB}
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wy0}{\DW{y}{0}}{below=of wx0}
      \event{wx}{\DW{x}{1}}{right=of wx0}
      \event{wy}{\DW{y}{1}}{right=of wy0}
      \event{ry}{\DR{y}{0}}{right=of wx}
      \event{rx}{\DR{x}{0}}{right=of wy}
      \wk{wx0}{wx}
      \wk{wy0}{wy}
      \po{wy}{rx}
      \po{wx}{ry}
      \rf{wy0}{ry}
      \rf{wx0}{rx}
      \wk{ry}{wy}
      \wk{rx}{wx}
      % \po{rx}{wy}
    \end{tikzinline}}
\end{gather*}
The read to write order is required by the definition of fulfillment.
This candidate execution is \emph{not} a pomset due to the resulting cycle;
thus it is disallowed by Candidate~\ref{def:rw:sc1}.

For programs with general expressions, we must introduce preconditions.  We
write the definition of the prefixing operator more carefully this time, and highlight
some of the changes in the candidate semantics:

%\paragraph{Program Order Prefixing.}
\begin{definition}
  \label{def:pre-sc}
Let $(\aForm \mid \aAct) \prefixsc \aPSS$ be the set $\PRE(\aPSS')$ where
$\aPS'\in\aPSS'$ when 
there is $\aPS\in\aPSS$ such that:
\begin{enumerate}
\item\label{pre-E} $\Event' = \Event \uplus \{\bEv\}$,
\item\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item[3a.] $\labelingAct'(\bEv) = \aAct$,
\item[3b.] $\labelingForm'(\bEv)$ implies $\aForm$,
\item[4a.] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
\item[4b.] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
\item[4c.] if $\bEv$ does not \externally read then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$, and
\item[5.] $\bEv \lt' \aEv$, 
\end{enumerate}
\end{definition}

% In the definition of prefixing,
%\vspace{-2ex}
\begin{candidate} %\ \vspace{-1ex}
  \label{cand2.9}
    \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsc \sem{\aCmd}\mkern4mu\, \mathhl{[\aLoc/\aReg] }}
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS{\aExp}\SEMI \aCmd} & =
    \;\smash{\mathhl{\textstyle\parallel_\aVal (\aExp=\aVal}\, \mid \DWmode\aLoc\aVal) \prefixsc\; \sem{\aCmd}}
  \end{align*}
\end{candidate}
Item 1 introduces a new event.  Item 2 ensures that no order is removed from old
events. Item 3 describes the label of the new event, which must imply
$\aForm$. Item 4 describes the labels of old events, as discussed below.
Item 5 ensures that program order is included for the new event.

%We first discuss writes, then reads.

For writes, item 4 is simple: For old events, the new precondition in $\aPS'$
must imply old the precondition in $\aPS$.  (This is very similar to the
treatment of the new event in item 3.)

The semantics of write introduces a write action for each possible value of
the expression $\aExp$.  To ensure that at most one write is enabled, these
are given disjoint preconditions.

The semantics is again driven by Hoare logic---for the preconditions of
writes, the relevant rule is left disjunction:
\begin{displaymath}
  \frac{
    \hoare{\aForm^1}{\aCmd}{\bForm}
    \quad
    \hoare{\aForm^2}{\aCmd}{\bForm}
  }{
    \hoare{\aForm^1\lor\aForm^2}{\aCmd}{\bForm}
  }
\end{displaymath}
Note that
\begin{math}
  \sem{x \GETS 1{+}r{*}r{-}r}
\end{math}
includes both of the pomsets:
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  %\\[-1.5ex]\intertext{and:}\\[-5ex]
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ1\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{align*}
By using $\parallel_\aVal$ in the definition of write, it also includes:
% (where,
% contrary to convention, we show disjoint events):
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{gather*}
An alternate definition using $\cup_\aVal$ would exclude this pomset.

Given that the conditional is defined using $\parallel$, the use of $\parallel$
in the definition of write is necessary to validate \emph{case analysis}:
\begin{math}
  \sem{\aCmd}
  =
  \sem{\IF{\aExp}\THEN \aCmd\ELSE \aCmd\FI}.
\end{math}


For reads, item 4b %(Candidate \ref{def:pre-sc})
allows some preconditions to weaken and requires others to strength\-en.
Recall \eqref{ex-1}: % from the beginning of this section:
\begin{align*}
  \begin{gathered}
    y\GETS r
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r=1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r<0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Prepending $\aReg\GETS\aLoc$ first causes the substitution $[x/r]$:
\begin{align*}
  \begin{gathered}
    r\GETS x\SEMI y\GETS r
    \\    
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x=1\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x<0\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Item 4b then the substitutes the chosen value $[1/x]$:
\begin{align}
  \label{ex-2}
  \begin{gathered}
    % r\GETS x\SEMI y\GETS r
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{1=1\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \nonevent{wy1}{1<0\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        %\po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align}
% We can write these more succinctly as:
% % We often drop preconditions on tautological events and sometimes cross out
% % unsatisfiable ones (which may are ignored):
% \begin{align*}
%   \begin{gathered}
%     % r\GETS x\SEMI y\GETS r
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \event{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
%   &&
%   \begin{gathered}
%     % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
%     % \\
%     \hbox{\begin{tikzinline}[node distance=1em]
%         \nonevent{wy1}{\DW{y}{1}}{}
%         \event{rx1}{\DR{x}{1}}{left=of wy1}
%         \po{rx1}{wy1}
%       \end{tikzinline}}
%   \end{gathered}
% \end{align*}
On the right, $(\DW{y}{1})$ has become impossible.  On the left, it has become
causally dependent on the read.  By prefixing a read event, the precondition
$x=1$ has moved from the sequential realm of Hoare logic to the concurrent
memory model.  Rather than a precondition that must be \emph{satisfied}, the
resulting pomset has a read event that must be \emph{fulfilled}.

%The use of $\parallel$ is unnecessary  for reads.
% : the read rule does not introduce read preconditions, and item 5a of
% Definition \ref{def:prefix} ignores them.
Whereas a write action introduces a precondition---satisfied
sequentially---on the value to be written; a read introduces a pomset
requirement---fulfilled concurrently---on the value to be read.  Since reads
of different values do not have disjoint preconditions, it is important that
a read introduce at most one event per pomset.  Thus, we use $\cup_\aVal$ to
combine pomsets for different read values, rather than $\parallel_\aVal$.
% In the concurrent world, writes are capabilities; reads are obligations.
% Thus, a read should introduce at most one event per pomset.


% We can now explain the substitution in the semantics of read in Candidate~\ref{def:rw:sc1}.
% % (The substitution in the semantics of write \eqref{sc-write} is not used here; we explain
% % it after introducing \emph{internal reads}, below.)
% Returning to our example, to compute
% $\sem{r\GETS x\SEMI y\GETS r}$, we first compute
% $(r\EQ1\mid\DW{y}{1})[x/r]$, then perform prefixing on the resulting $(x\EQ1\mid\DW{y}{1})$.  By 4b, reading $1$
% performs the further substitution of $[1/x]$, allowing the precondition to
% weaken to $(1\EQ1)$.  Likewise, reading $0$ performs $[0/x]$, requiring the precondition
% to strengthen to $(0\EQ1)$.

% Second, the use of $\PAR$ to combine pomsets formed by write prefixing
% ensures that the semantics is ``disjunctive'' in a certain sense.
% The following example uses address calculation, defined formally in
% \textsection\ref{sec:variants}.  It also use the operator ``$\BANG \aExp$,''
% which evaluates to $1$ when $\aExp$ is $0$, and
% $0$ otherwise.  Note that 
% \begin{math}
%   \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
% \end{math}
% includes both of the following pomsets:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
%   \qquad
%   %\\[-1.5ex]\intertext{and:}\\[-5ex]
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
%       \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
% \end{align*}
% By using $\PAR$ rather than $\cup$, it also includes the following (where,
% contrary to convention, we show disjoint events):
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em]
%       \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%       \event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
%     \end{tikzinline}}%\;\;\cdots
% \end{gather*}
% Using $\cup$, the semantics would exclude this pomset, and thus fail to
% validate \emph{case analysis}---for example, refining this program,
% \begin{math}
%   \aCmd = (a[r] \GETS 0\SEMI a[0]\GETS \BANG r),
% \end{math}
% to
% \begin{math}
%   \IF{r\EQ1}\THEN \aCmd\ELSE \aCmd\FI.
% \end{math}

\paragraph{General Prefixing.}

We now relax item 5 of Definition \ref{def:pre-sc} so that only some program
order is {preserved} in the pomset, arriving at the final definition of
the prefix operator: % and our last failed candidate semantics.
\begin{definition}
  \label{def:prefix}
Two actions \emph{conflict} if one writes a location and the other
either reads or writes the same location.

Let $(\aForm \mid \aAct) \prefix \aPSS$ be the set $\PRE(\aPSS')$ where
$\aPS'\in\aPSS'$ when
there is some $\aPS\in\aPSS$ that satisfies items 1-4 of
Definition \ref{def:pre-sc} such that:
\begin{enumerate}
\item[5a.] %$\bEv$ \externally reads and
  if $\aEv$ writes then either $\bEv\lt'\aEv$ or $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$,
% \item[5a.] if %$\bEv$ \externally reads and
%   $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and $\aEv$ writes, then
%   $\bEv\lt'\aEv$,
\item[5b.] if $\bEv$ and $\aEv$ are \external actions in conflict,
    then $\bEv\lt'\aEv$, %$\bEv \gtN' \aEv$,
\item[5c.] if $\bEv$ is an acquire or $\aEv$ is a release, then $\bEv \lt' \aEv$, and
\item[5d.] if $\bEv$ is an SC write and $\aEv$ is an SC read, then $\bEv \lt' \aEv$.
%\item[5e.] if $\aEv$ is a termination, then $\bEv\lt'\aEv$.
% \item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
%   is location independent.
\end{enumerate}
\end{definition}
%\vspace{-2ex}
\begin{candidate}%\ \vspace{-1ex}
  \label{cand:sc}
    \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd} [\aLoc/\aReg] 
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
    \;\;\textstyle\parallel_\aVal (\aExp=\aVal \mid \DWmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd}\mkern3.5mu\mathhl{[\aExp/\aLoc]}
  \end{align*}
\end{candidate}
% \end{definition}
% \begin{candidate}
%   Replace $\prefixsc$ in Candidate~\ref{def:rw:sc1} by $\prefix$.
% \end{candidate}
Item 5a captures \emph{read to write dependency}\footnote{When $\bEv$ is not a read,
  4c trivially implies 5a.}.  It only requires order from read to write when the precondition of
the write is \emph{weakened} using 4b.  Item 5b captures the coherence
requirement on actions that touch the same location.  Item 5c imposes the
order required by acquire and release actions\footnote{Recall that
  termination actions are releases.}.  Item 5d imposes the
additional order required by SC actions\footnote{Recall that SC reads are
  acquires and SC writes are releases.}.  %(We explain item 6 in the next subsection.)

Items 5b and 5c ensure correct publication.  For
example, they disallow the following candidate execution, which sees a stale
value for $x$:
\vspace{-1ex}
\begin{gather}
  \label{aqc-rel}
  x\GETS0\SEMI %y\GETS0\SEMI
  x\GETS 1\SEMI y \REL\GETS1 \PAR r\GETS y\ACQ\SEMI s\GETS x
  \\[-1ex]
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wx1}{\DW{x}{1}}{right=of wx0}
      \event{wy1}{\DWRel{y}{1}}{right=of wx1}
      \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
      \event{rx0}{\DR{x}{0}}{right=of ry1}
      \sync{wx1}{wy1}
      \sync{ry1}{rx0}
      \rf{wy1}{ry1}
      \rf[out=10,in=170]{wx0}{rx0}
      \wk{wx0}{wx1}
    \end{tikzinline}}
\end{gather}
By Definition \ref{def:rf}, $(\DR x0)$ is \emph{unfulfilled} in this
pomset. It fails the last requirement of the definition, since
$(\DW x0) \gtN (\DW x1) \lt (\DR x0)$.  In order to satisfy this requirement,
$(\DR x0)$ must be ordered before $(\DW x1)$, but this creates a cycle.

%This example is also disallowed if we use $\modeSC$ rather than $\modeRA$.
Items 5d ensures that program order between SC operations is always
preserved.  Combined with the requirements for fulfillment, this is
sufficient to establish that programs with only SC access have only SC
executions; for example, execution candidate \eqref{SB} is banned when the
actions of the two threads are all $\modeSC$ (but allowed with less order
otherwise, as discussed below).  It is also immediate that SC actions can be
totally ordered, using any linearization of pomset order.  Just as SC access in
\armeight{} is simplified by \mca, it is simplified here by the
global pomset order.
% \begin{gather*}
%   x\GETS0\SEMI x\GETS1\SEMI\aReg\GETS y
%   \PAR
%   y\GETS0\SEMI y\GETS1\SEMI \aReg\GETS x
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wy0}{\DW{y}{0}}{below=of wx0}
%       \event{wx}{\DW{x}{1}}{right=of wx0}
%       \event{wy}{\DW{y}{1}}{right=of wy0}
%       \event{ry}{\DR{y}{0}}{right=of wx}
%       \event{rx}{\DR{x}{0}}{right=of wy}
%       \wk{wx0}{wx}
%       \wk{wy0}{wy}
%       \po{wy}{rx}
%       \po{wx}{ry}
%       \rf{wy0}{ry}
%       \rf{wx0}{rx}
%       \wk{ry}{wy}
%       \wk{rx}{wx}
%       % \po{rx}{wy}
%     \end{tikzinline}}
% \end{gather*}

Unlike \citep[\textsection8.2]{Dolan:2018:BDR:3192366.3192421}, our model allows:
\begin{gather*}
  r\GETS y\SEMI x^\modeSC\GETS1\SEMI s\GETS x
  \PAR
  % y\GETS0\SEMI
  x^\modeSC\GETS2 \SEMI y\GETS1
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a}{\DR{y}{1}}{}
      \event{b}{\DW[\modeSC]{x}{1}}{right=of a}
      \sync{a}{b}
      \event{bb}{\DR{x}{2}}{right=of b}
      \wk{b}{bb}
      % \event{c}{\DW{y}{0}}{right=2em of bb}
      % \event{d}{\DW[\modeSC]{x}{2}}{right=of c}
      % \po{c}{d}
      \event{d}{\DW[\modeSC]{x}{2}}{right=2em of bb}
      \event{e}{\DW{y}{1}}{right=of d}
      %\rf[out=170,in=10]{d}{bb}
      \rf{d}{bb}
      \rf[out=-170,in=-10]{e}{a}
      \wk[in=165,out=15]{b}{d}
    \end{tikzinline}}
\end{gather*}
Note that there is no order from $(\DW[\modeSC]{x}{2})$ to $(\DW{y}{1})$.


We relax program order on non-SC accesses in order to allow outcomes like
that of execution candidate \eqref{SB}.
Order is relaxed between reads, between writes to different
locations, and from a read to an independent write:
\begin{gather*}
  \aCmd=\aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
    \end{tikzinline}}
\end{gather*}
Let $\aCmd$ be the program above.  The existence of this pomset is justified
by the triple
$\hoare{\TRUE}{\aCmd}{y=1}$.

Unordered actions can be scheduled freely.
As a result, our model of coherence is similar to that of
\citet{Dolan:2018:BDR:3192366.3192421}.  Since reads are not ordered by 5b,
we {allow} the following, which C11 forbids:
\begin{gather*}
  x\GETS1\SEMI x\GETS 2
  \PAR
  y\GETS x \SEMI z\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a}{\DW{x}{1}}{}
      \event{b}{\DW{x}{2}}{right=of a}
      \wk{a}{b}
      \event{c}{\DR{x}{2}}{right=2em of b}
      \event{d}{\DW{y}{2}}{right=of c}
      \po{c}{d}
      \event{e}{\DR{x}{1}}{right=of d}
      \event{f}{\DW{z}{1}}{right=of e}
      \po{e}{f}
      \rf{b}{c}
      \rf[out=10,in=170]{a}{e}
    \end{tikzinline}}
\end{gather*}
Conversely, we {forbid} the following, which Java allows:
\begin{gather*}
  \hbox{\small$
  x\GETS1\SEMI y^\modeRA\GETS 1
  \PAR
  x\GETS2\SEMI z^\modeRA\GETS 1
  \PAR
  r\GETS y^\modeSC \SEMI 
  r\GETS z^\modeSC \SEMI 
  r\GETS x \SEMI 
  r\GETS x$}
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a1}{\DW{x}{1}}{}
      \event{a2}{\DW[\modeRA]{y}{1}}{right=of a1}
      \sync{a1}{a2}
      \event{b1}{\DW{x}{2}}{below=of a1}
      \event{b2}{\DW[\modeRA]{\,z}{1}}{right=of b1}
      \sync{b1}{b2}
      \event{c1}{\DR[\modeRA]{y}{1}}{right=2em of a2}
      \event{c2}{\DR[\modeRA]{\,z}{1}}{right=2em of b2}
      \event{c3}{\DR{x}{2}}{right=of c1}
      \event{c4}{\DR{x}{1}}{right=of c2}
      \sync{c1}{c3}
      \sync{c1}{c4}
      \sync{c2}{c3}
      \sync{c2}{c4}
      \rf{a2}{c1}
      \rf{b2}{c2}
      \wk{a1}{b1}
      \wk[out=-165,in=-15]{c4}{b1}
    \end{tikzinline}}
\end{gather*}
% \begin{gather*}
%   x\GETS1\SEMI y^\modeRA\GETS 1
%   \PAR
%   x\GETS 2\SEMI
%   r\GETS y^\modeSC \SEMI 
%   r\GETS x \SEMI 
%   r\GETS x
%   \\[-1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a}{\DW{x}{1}}{}
%       \event{b}{\DW[\modeRA]{y}{1}}{right=of a}
%       \sync{a}{b}
%       \event{c}{\DW{x}{2}}{below=of a}
%       \event{d}{\DR[\modeSC]{y}{1}}{right=of c}
%       \po{c}{d}
%       \event{e}{\DR{x}{2}}{right=of d}
%       \po{d}{e}
%       \event{f}{\DR{x}{1}}{right=of e}
%       \po[out=10,in=170]{d}{f}
%       \rf{b}{d}
%       %\rf[out=-10,in=-170]{c}{e}
%       \wk{a}{c}
%       %\rf[out=15,in=150]{a}{f}
%       \wk[out=-165,in=-15]{f}{c}
%     \end{tikzinline}}
% \end{gather*}
The order from $(\DR{x}{1})$ to $(\DW{x}{2})$ is required to fulfill $(\DR{x}{1})$. %by fulfillment.

% Program order is only imposed from read to write when the precondition of
% the write is weakened.  Thus we have:
% \begin{displaymath}
%   \aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\DW{y}{1}}{}
%   \event{rx1}{\DR{x}{1}}{left=of wy1}
% \end{tikzdisplay}
% Since no order is imposed, the two actions can be reordered.
% Let $\aCmd$ be the program above.  The existence of this pomset is justified
% by the triple
% $\hoare{\TRUE}{\aCmd}{y=1}$.

Item 5a imposes order from read to write when weakening the
precondition of the write via 4b, as on the left hand side of
\eqref{ex-2}.
% \begin{gather*}
%   r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wy1}{1\geq0\mid\DW{y}{1}}{}
%       \event{rx1}{\DR{x}{1}}{left=of wy1}
%       \po{rx1}{wy1}
%     \end{tikzinline}}
% \end{gather*}
Item 4b \emph{allows} a precondition to weaken, but does not \emph{require} it.
Item 5a only requires order when the precondition weakens.
Thus, no order is required in: % the following execution:
\begin{gather*}
  \aCmd=r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  %\label{ex555}
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{x{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
Let $\aCmd$ be the program above.  The existence of this pomset is justified
by the triple $\hoare{x\geq0}{\aCmd}{y=1}$.  It is not justified by the value of the read
action.

Nonetheless, item 4b requires that the value of the read action must
be \emph{compatible} with subsequent formulae.  In this example, the write
precondition must become unsatisfiable when ${-}2$ is read from $x$:
\begin{gather*}
  % r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  % \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \nonevent{wy1}{{-2}{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{{-2}}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
This holds for all preceding reads, unless the precondition is discharged by
introducing order.  Thus, $\sem{s\GETS x\SEMI \aCmd}$ contains both of the
following pomsets:
\begin{gather*}
  % s\GETS x\SEMI \aCmd
  % \\[-1ex]
  % \nonumber
  \hbox{\begin{tikzinline}[node distance=.3em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
  \quad\;\;
  \hbox{\begin{tikzinline}[node distance=.3em]
      \event{wy1}{1{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=1em of wy1}
      \event{rx2}{\DR{x}{{-}2}}{left= of rx1}
      \po{rx1}{wy1}
      %\event{wx0}{\DW{x}{0}}{left=of rx2}
      %\wk[out=20,in=160]{wx0}{rx1}
      %\wk{wx0}{rx2}
    \end{tikzinline}}
\end{gather*}

Like item 4b, which substitutes $[\aVal/\aLoc]$ during a read, Candidate
\ref{cand:sc} substitutes $[\aExp/\aLoc]$ during a write.  Like 4b, this
affects subsequent preconditions, either allowing them to weaken, or
requiring them to strengthen.  For write prefixing, however, there is no rule
corresponding to item 5a. Unlike a read event, order is \emph{not} imposed from
a write event to the subsequent events whose precondition it weakens:
\begin{gather*}
\begin{gathered}
  x \GETS 0\SEMI \aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{0{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{0}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
\qquad
\begin{gathered}
  x \GETS {-}2\SEMI\aCmd
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \nonevent{wy1}{{-}2{\geq}0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=.3em of wy1}
      \event{wx0}{\DW{x}{{-}2}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gathered}
\end{gather*}
In the JMM causality test cases \citep{PughWebsite}, such executions are justified via
compiler analysis, possibly in collusion with the scheduler: If every 
observed value can be shown to satisfy a precondition, then the precondition
can be dropped.  For
example, TC1 determines that the following top-level execution should be
allowed, as it is in our model:
\begin{gather*}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y)
  \\
  \hbox{\begin{tikzinline}[node distance=1em and 2em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \po{ry1}{wx1}
  \rf[out=140,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gather*}
Unlike \citep{DBLP:conf/lics/JeffreyR16}, our semantics is robust
with respect to the introduction of concurrent writes, as in TC9:
\begin{gather*}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y
  \PAR
  x\GETS {-2})
  \\
  \hbox{\begin{tikzinline}[node distance=1em and 2em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 2em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wx2}{\DW{x}{{-2}}}{below right=-.2em and 2em of wy1}
  \po{ry1}{wx1}
  \rf[out=140,in=-20]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
  \wk{wx1}{wx2}
    \end{tikzinline}}
\end{gather*}

The reasoning for TC2 is similar, but in this case no value is necessary to
satisfy the precondition:
\begin{gather*}
  r\GETS x\SEMI
  s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI
  \PAR
  x\GETS y
  \\[-1ex]
  \nonumber
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DR{x}{1}}{right=of a1}
  \event{a3}{x{=}x\mid\DW{y}{1}}{right=of a2}
  % \po{a2}{a3}
  % \po[out=15,in=165]{a1}{a3}
  \event{b1}{\DR{y}{1}}{right=2em of a3}
  \event{b2}{\DW{x}{1}}{right=of b1}
  \rf{a3}{b1}
  \po{b1}{b2}
  \rf[out=162,in=15]{b2}{a2}
  \rf[out=162,in=15]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
Note that in the prefix
\begin{math}
  \sem{s\GETS x\SEMI
  \IF{r{=}s}\THEN y\GETS 1\FI},
\end{math}
the precondition on $(\DW{y}{1})$ must imply $r=1 \land r=x$.  The first conjunct is
imposed by 4b, the second by 5a.  Thus the two reads must see the same value.

Write substitution only effects subsequent reads, and a read action always
creates an event that must be fulfilled.  In combination, these ensure that a
write substitution cannot be used to ignore a blocking write.  In the
following execution candidate, there is no order from $(\DR{x}{1})$ to
$(\DW{y}{1})$, potentially allowing the program to write a stale value.
However, $(\DR{x}{1})$ cannot be fulfilled, causing the execution candidate
to be disallowed:
\begin{gather*}
  x\GETS1 \SEMI
  a\REL\GETS1 \SEMI
  \IF{b\ACQ}\THEN  y\GETS x \FI
  \PAR
  \IF{a\ACQ}\THEN  x\GETS 2\SEMI b\REL\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=.8em and 1em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{a}{1}}{right=of a1}
  \sync{a1}{a2}
  \event{b3}{\DRAcq{a}{1}}{below=of a2}
  \rf{a2}{b3}
  \event{b4}{\DW{x}{2}}{right=of b3}
  \sync{b3}{b4}
  \event{b5}{\DWRel{b}{1}}{right=of b4}
  \sync{b4}{b5}
  \event{a6}{\DRAcq{b}{1}}{above=of b5}
  \rf{b5}{a6}
  \event{a7}{\DR{x}{1}}{right=of a6}
  \sync{a6}{a7}
  \event{a8}{\DW{y}{1}}{right=of a7}
  \graypo{a7}{a8}
  \sync[out=10,in=170]{a6}{a8}
    \end{tikzinline}}
\end{gather*}
Note that we change $(\DR{x}{1})$ to $(\DR{x}{2})$ then the precondition of
$(\DW{y}{1})$ must imply $2{=}1$.

As a final example in this vein, consider Example 3.6
of \citet{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  %\tag{$\dagger$}
  \label{exlocal3.6}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\SEMI
  \bReg\GETS y\SEMI
  z\GETS \bReg
  %z\GETS y
  \PAR
  x\GETS z
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DWRel{y}{1}}{right=of a1}
  \sync{a1}{a2}
  \event{a3}{\DR{y}{1}}{right=of a2}
  \event{a4}{1{=}1\mid\DW{z}{1}}{right=of a3}
  \rf{a2}{a3}
  %\po{a3}{a4}
  \event{b1}{\DR{z}{1}}{right=2em of a4}
  \event{b2}{\DW{x}{1}}{right=of b1}
  %\po[out=10,in=170]{a2}{a4}
  \po{b1}{b2}
  \rf{a4}{b1}
  \rf[out=170,in=10]{b2}{a1}
    \end{tikzinline}}
\end{gather*}
This behavior is allowed in our model, as it is in \armeight.
%Revisiting \eqref{exlocal3.6}, %the example,
Note that $\sem{z\GETS \bReg}$ includes $(\bReg{=}1\mid \DW{z}{1})$.
Prepending a read,
% of Definition~\ref{def:rw:local},
$\sem{\bReg\GETS y \SEMI z\GETS \bReg}$ may update the precondition to
$(y{=}1\mid \DW{z}{1})$ without introducing order.
%Crucially, there is no explicit read event.
Further prepending
$(\DWRel{y}{1})$ results in $(1{=}1\mid \DW{z}{1})$.
% performs the substitution $(y=1\mid \DW{z}{1})[1/y]$ resulting in a
% tautology.
% By removing the read event, the outcome is
% allowed by our semantics, enabling efficient compilation to \armeight:
% \begin{gather}
%   \label{inlining}
%   % \aReg\GETS x\SEMI
%   % y\REL\GETS 1\SEMI
%   % z\GETS y
%   % \PAR
%   % x\GETS z
%   % \\
%   \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%   \event{a1}{\DR{x}{1}}{}
%   \event{a2}{\DWRel{y}{1}}{right=of a1}
%   \po{a1}{a2}
%   \internal{a3}{\DR{y}{1}}{right=of a2}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   %\rf{a2}{a3}
%   \graypo{a3}{a4}
%   \event{b1}{\DR{z}{1}}{right=of a4}
%   \event{b2}{\DW{x}{1}}{right=of b1}
%   %\po[out=10,in=170]{a2}{a4}
%   \po{b1}{b2}
%   \rf{a4}{b1}
%   \rf[out=170,in=10]{b2}{a1}
%     \end{tikzinline}}
% \end{gather}

As side note, this example shows that---like most relaxed models---our model
fails to validate \emph{thread inlining}: The execution above is impossible
for
\begin{math}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\PAR
  \bReg\GETS y\SEMI
  z\GETS \bReg
  \PAR
  x\GETS z.
\end{math}
The write in the first thread cannot discharge the precondition in the
second.


\paragraph{Relaxed Write Elimination.}
We discuss compiler optimization in \textsection\ref{sec:opt}.  Irrelevant
reads have no effect in our model, thus we can define correctness with
respect to pomsets that have been saturated with arbitrary irrelevant reads.
The same does not hold for writes.

In our final definition of the semantics, we allow for the possibility of
relaxed write elimination:

% In the semantics thus far, we have supposed that every read must be fulfilled
% by a matching write action, and that the order between them must therefore be
% part of the global pomset order.  This is overly restrictive for reads that
% are fulfilled locally.

% Consider Example 3.6 from
% \citet{DBLP:journals/pacmpl/PodkopaevLV19}:
% \begin{gather*}
%   %\tag{$\dagger$}
%   \label{exlocal3.6}
%   \aReg\GETS x\SEMI
%   y\REL\GETS 1\SEMI
%   \bReg\GETS y\SEMI
%   z\GETS \bReg
%   %z\GETS y
%   \PAR
%   x\GETS z
%   \\
%   \nonumber
%   \hbox{\begin{tikzinline}[node distance=.5em and 1em]
%   \event{a1}{\DR{x}{1}}{}
%   \event{a2}{\DWRel{y}{1}}{right=of a1}
%   \po{a1}{a2}
%   \event{a3}{\DR{y}{1}}{right=of a2}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   \rf{a2}{a3}
%   %\po{a3}{a4}
%   \event{b1}{\DR{z}{1}}{right=2em of a4}
%   \event{b2}{\DW{x}{1}}{right=of b1}
%   %\po[out=10,in=170]{a2}{a4}
%   \po{b1}{b2}
%   \rf{a4}{b1}
%   \rf[out=170,in=10]{b2}{a1}
%     \end{tikzinline}}
% \end{gather*}
% This behavior is allowed by \armeight, but disallowed in the model presented
% thus far, due to the evident cycle.

% To allow this outcome, we remove the requirement for an explicit read action
% when a read is matched by a local write---and, symmetrically, for an explicit
% write action when a write is only used to match local reads.  We treat
% only relaxed local access in this section, extending to $\modeRA$/$\modeSC$
% local access after
% introducing fences in \textsection\ref{sec:variants}.
% % We first give the semantics of read.
% % \begin{definition} \ \vspace{-1ex}
% %   %\label{def:rw:local}
% %   \begin{align*}
% %     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
% %     \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
% %     % \\[-.5ex] &
% %     % % \mkern2mu\cup
% %     % \;\mathhl{\cup\;
% %     %   % (\iDRmode{\aLoc}{}) \prefix
% %     %   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
% %     %   \sem{\aCmd}[\aLoc/\aReg]
% %     %   % \text{ else $\emptyset$}
% %     % }
% %   \end{align*}
% % \end{definition}

% As in \eqref{ex555}, Item 4b (Definition \ref{def:pre-sc}) ensures that
% intervening writes are respected.  For example, 
% \begin{math}
%   {x\GETS 0\SEMI x\GETS 1\SEMI y\GETS x}
% \end{math}
% cannot write $0$ to $y$.
% %does not $\DW{y}{0}$.
% % NEED TO MAKE THIS POINT:
% % So consider the single threaded program

% % x=4; x=5; y=x;

% % Clearly, this should not be able to give us Wy1.
% % Here is why that is not possible:

% % [[ y=1 ]] contains (Wy1)

% % [[ if(r==4){y=1} ]] contains (r==4|Wy1)

% % [[ r=x; if(r==4){y=1} ]] contains (Rx5)  (x==4|Wy1) // with no order

% % [[ x=5; r=x; if(r==4){y=1} ]] contains (Wx5)-->(Rx5)  (5==4|Wy1) // 5 is forced.


% % Consider the program variant:

% % x=0; r=x; if(r<2){y=1} || x=5

% % [[ y=1 ]] contains (Wy1)

% % [[ if(r<2){y=1} ]] contains (r<2|Wy1)

% % [[ r=x; if(r<2){y=1} ]] contains (Rx5)  (x<2|Wy1)  //with no order

% % [[ x=0; r=x; if(r<2){y=1} ]] contains (Wx0)  (Rx5)  (x<2|Wy1) //does not work, since violates (6a) () implies ()[/].


% % 6. if  externally reads  from  then both 
% % (6a) () implies ()[/], and 
% % (6b) if  is a write then either  <  or () implies ()





\begin{definition}
  \label{def:cover}
  Let $(\relfilt[\modeRLX]{\aLoc} \aPSS)$ be the set $\aPSS'\subseteq\aPSS$ such that
  $\aPS'\in\aPSS'$
  when %$\Event$ contains a write to $\aLoc$ and
  %there is some $\cEv'\in\Event'$ that writes $\aLoc$ and
  for every release $\aEv'\in\Event'$, %that does not write $\aLoc$,
  there is some $\bEv'\in\Event'$ 
  such that $\bEv' \le\aEv'$ and $\bEv'$ \externally  writes $\aLoc$.  % For $\amode\neq\modeRLX$, let
  
  Let $(\relfilt[\modeRA]{\aLoc} \aPSS)=(\relfilt[\modeSC]{\aLoc} \aPSS)=\emptyset$.
  %Let $(\relfilt[\amode]{\aLoc} \aPSS)=\emptyset$ when $\amode\neq\modeRLX$.
  % $(\relfilt {\aLoc} \aPSS)$ be the empty set.
  \begin{align*}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
    % \\[-.5ex] &
    % % \mkern2mu\cup
    % \;\mathhl{\cup\;
    %   % (\iDRmode{\aLoc}{}) \prefix
    %   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
    %   \sem{\aCmd}[\aLoc/\aReg]
    %   % \text{ else $\emptyset$}
    % }
    \\
    \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
    \;\;\textstyle\parallel_\aVal\, (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
    \\[-.5ex] &
    %\mkern2mu\cup
    \;\mathhl{\cup\;
      % (\iDWmode{\aLoc}{}) \prefix
      %\text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
      (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
      % \text{ else $\emptyset$}
    }
  \end{align*}
\end{definition}

The use of $\relfilt{}$ in the definition prevents the eliminated write
rule from applying immediately before a release.  This prevents bad
executions such as:
\begin{gather*}
  x\GETS 1\SEMI
  x\GETS 2\SEMI
  y\REL\GETS 1
  \PAR
  \aReg\GETS y\ACQ \SEMI \bReg\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \internal{a2}{\DW{x}{2}}{right=of a1}
  \graywk{a1}{a2}
  \event{a3}{\DWRel{y}{1}}{right=of a2}
  \graypo{a2}{a3}
  \event{b1}{\DRAcq{y}{1}}{right=2em of a3}
  \rf{a3}{b1}
  \event{b2}{\DR{x}{1}}{right=of b1}
  \sync{b1}{b2}
  \rf[out=10,in=170]{a1}{b2}
  \sync[out=-10,in=-170]{a1}{a3}
    \end{tikzinline}}
\end{gather*}
In this drawing, we have included a ``non-event''---dashed border---to mark
the eliminated write.


\paragraph{Litmus Tests.}
Our model gives the desired results for the test cases of \citet{PughWebsite},
\citet[\textsection 5.3]{SevcikThesis}, and \citet[\textsection
4]{DBLP:conf/esop/BattyMNPS15}.  It also agrees with the ``surprising and
controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}.

We present two examples that are hallmarks of \mca{} architectures.
The analysis follows from a few simple principles.  
% \begin{gather*}
%   \renewcommand{\arraycolsep}{1pt}
%   \hbox{\small
%     $\begin{array}{ccccc}
%     &x\GETS0\SEMI x\GETS 1
%     &\PAR&
%     r\GETS x \SEMI s\GETS y
%     %\IF{x}\THEN r\GETS y \FI
%     \\
%     \PAR
%     &y\GETS0\SEMI y\GETS 1
%     &\PAR&
%     r\GETS y \SEMI s\GETS x
%     %\IF{y}\THEN s\GETS x \FI
%   \end{array}$}
%   \quad
%   \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \rf{wx1}{rx1}
%   \rf[bend left]{wy0}{ry0}
%   \rf{wy1}{ry1}
%   \rf[bend right]{wx0}{rx0}
%   \wk{rx0}{wx1}
%   \wk{ry0}{wy1}
%     \end{tikzinlinesmall}}
% \end{gather*}
\begin{gather*}
  \\[-2.5ex]
  \renewcommand{\arraycolsep}{1pt}
  \hbox{\small
    $\begin{array}{ccccc}
    &x\GETS0\SEMI x\GETS 1
    &\PAR&
    r\GETS x\ACQ \SEMI s\GETS y
    %\IF{x}\THEN r\GETS y \FI
    \\
    \PAR
    &y\GETS0\SEMI y\GETS 1
    &\PAR&
    r\GETS y\ACQ \SEMI s\GETS x
    %\IF{y}\THEN s\GETS x \FI
  \end{array}$}
  \quad
  \smash{\hbox{\begin{tikzinlinesmall}[baseline=-10pt,node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DRAcq{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \sync{rx1}{ry0}
  \sync{ry1}{rx0}
    \end{tikzinlinesmall}}}
  \\[-1ex]
\end{gather*}
In this variant of \iriw\ (Independent Reads of Independent Writes), order 
is imposed by \emph{coherence} (between the writes), \emph{fulfillment}
(between read and write), and \emph{fencing} (from acquiring read to relaxed read).
Given the evident cycle, the candidate execution is invalid.
% Note that if you enforce the dependency between the reads, then the execution
% is disallowed, because the is a cycle on weak edges restricted to $x$:
% \begin{math}
%   (\DW{x}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
% then
% \begin{math}
%   (\DW{y}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}

It is also impossible for all threads to read $1$ in the following, due to
\emph{control dependencies}, \emph{coherence}, and \emph{fulfillment}.
\begin{gather*}
  \hbox{\small$\IF{x}\THEN y\GETS0 \FI \SEMI y\GETS1
  {\PAR}
  \IF{y}\THEN z\GETS0 \FI \SEMI z\GETS1
  {\PAR}
  \IF{z}\THEN x\GETS0 \FI \SEMI x\GETS1
  $}
  \\[-.5ex]
  \hbox{\begin{tikzinlinesmall}[node distance=1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DW{y}{0}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \wk{a2}{a3}
  \event{b1}{\DR{y}{1}}{right=of a3}
  \event{b2}{\DW{z}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{z}{1}}{right=of b2}
  \wk{b2}{b3}
  \event{c1}{\DR{z}{1}}{right=of b3}
  \event{c2}{\DW{x}{0}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DW{x}{1}}{right=of c2}
  \wk{c2}{c3}
  \rf{a3}{b1}
  \rf{b3}{c1}
  \rf[out=173,in=7]{c3}{a1}  
    \end{tikzinlinesmall}}
\end{gather*}

In either example, the execution is allowed if the cycle is broken---for
example, by changing $x\ACQ$ to $x\RLX$ in \iriw.


% \citet{PughWebsite} developed a set of twenty {causality test cases} in the
% process of revising the Java Memory Model (JMM)
% \cite{Manson:2005:JMM:1047659.1040336}.
% %Using hand calculation, we have confirmed that
% Our model gives the desired result for all twenty cases,
% unrolling loops as necessary.
% % confirmed that our model gives the desired result these test cases, with the
% % following caveats: to model TC14 and TC15 we must unroll loops; the behaviors
% % of TC1 and TC8 are only allowed in our model if the inferred range of
% % variables is included as a global assumption in the logic. 
% Our model also gives the desired results for the examples of
% \citet{PughWebsite}, \citet[\textsection 5.3]{SevcikThesis},
% \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15}.  Our model agrees with
% ``surprising and controversial behaviors'' of
% \citet[\textsection 8]{Manson:2005:JMM:1047659.1040336}.  We elide the
% details.
% \textsection\ref{sec:examples} develops some of these examples.





% \paragraph{Par-closure and Case Analysis.}
% Par closure.
% \begin{definition}
%   \label{def-par-closed}
%   $\aPSS$ is \emph{par-closed} if $\aPS^i\!\in\aPSS$ implies $\aPS^1\!{\PAR}\aPS^2\!\in\aPSS$\!\!.
% \end{definition}

% \begin{definition}
%   Let $\aPS'\in\sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd}$ if
%   \begin{math}
%     \aPS'= %(\iDRmode{\aLoc}{}) \prefix
%     \sem{\aCmd}[\aLoc/\aReg]
%   \end{math}
%   or
%   \begin{math}
%     \aPS'=\parallel_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%   \end{math}
%   where $\aPS\in\sem{\aCmd}[\aLoc/\aReg]$ and $\aForm_k$ are
%   disjoint\footnote{For $i$, $j$ in $K$: if $\aForm_i \land \aForm_j$ is
%     satisfiable then $i=j$.}.
% \begin{align*}
%     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
%     \textstyle\bigcup_K\; \parallel_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDRmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     \sem{\aCmd}[\aLoc/\aReg]
%     %\text{ else $\emptyset$}
%     \\
%     \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & \eqdef
%     \parallel_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDWmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
%     %\text{ else $\emptyset$}
% \end{align*}
% \end{definition}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
