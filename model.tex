\section{Model}
\label{sec:model}
\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}

Let $\LR=\Loc\cup\Reg$, be the set of \emph{locations}, ranged over by
$\aLR$.
Let $\Sub=\LR\partialfun\Exp$ be the set of \emph{substitutions}, ranged over
by $\aSub$ and $\bSub$.
We write substitutions
$[\bExp_1/\aLR_1,\ldots, \bExp_n/\aLR_n]$.
Let $\aActSub$ and $\bActSub$ range over $(\Act\cup\Sub)$.
% The empty substitution is written
% as $[\,]$.

We require that data models satisfy the following:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions are closed under substitution,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$ and $(\aLoc=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction, and substitution,
\item there is a relation $\vDash$ between formulae, 
\item there are partial functions $\rreads$ and $\rwrites: \Act \fun (\Loc
  \times \Val)$, and
\item there are sets $\Rel$ and $\Acq \subseteq\Act$.
\end{itemize}

We say that $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes} $\aVal$
\emph{to} $\aLoc$ whenever $\rwrites(\aAct) = (\aLoc,\aVal)$.  In examples,
the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from
$\aLoc$, and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.

We say that $\aAct$ is a \emph{acquire} if $\aAct\in\Acq$, and that $\aAct$
is an \emph{release} if $\aAct\in\Rel$.  In examples, the actions are of the
form $(\DRAcq{\aLoc}{\aVal})$, which is an acquire that reads $\aVal$ from
$\aLoc$, and $(\DWRel{\aLoc}{\aVal})$, which is a release that writes $\aVal$
to $\aLoc$.

We say that $\aForm$ \emph{implies} $\bForm$ whenever $\aForm\vDash\bForm$,
that $\aForm$ is a \emph{tautology} whenever $\TRUE\vDash\aForm$, that
$\aForm$ is \emph{unsatisfiable} whenever $\aForm\vDash\FALSE$, and that
$\aForm$ is \emph{independent of $\aLoc$} whenever
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$.


\subsection{3-valued pomsets}
\label{sec:pomsets}

\begin{definition}
  A \emph{(3-valued) pomset} with alphabet $\Alphabet$ is tuple $(\Event,
  {\le}, {\gtN}, \labelling)$, such that 
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  %\item $\ESub\subseteq\Event$ is a set of \emph{accepting states}, 
  \item $\labelling: \Event \fun \Alphabet$ is a \emph{labelling},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
    % \begin{enumerate}
    % \item $\aEv \le \aEv$,
    % \item if $\bEv \le \aEv$ and $\aEv \le \bEv$ then $\bEv = \aEv$,
    %   \\(this follows from 5a and 5b)
    % \item if $\cEv \le \bEv \le \aEv$ then $\cEv \le \aEv$, and
    % \end{enumerate}
  \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
    \begin{itemize}
    \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \eEv$,
    \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then $\bEv = \aEv$,
    \item if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$ then $\cEv \gtN \aEv$.
    \end{itemize}
\end{itemize}
\end{definition}
In the remainder of the paper, we drop the prefix ``3-valued'', referring to
3-valued pomsets simply as \emph{pomsets}.

We fix the alphabet $\Alphabet=(\Formulae\times(\Act\cup\Sub))$.  With this
alphabet, the labelling of a pomset determines two disjoint sets of events.
We refer to those that map to actions $\Sub$ as \emph{final}, and those that
map to substitutions $\Act$ as \emph{nonfinal}.
When we need to distinguish these, we let the set of events
$\Event=\EAct\uplus\ESub$, where $\EAct$ denotes the nonfinal events 
and $\ESub$ denotes the final events.

We lift terminology from logical formulae and actions to events, for example
if $\labelling(\aEv)=(\aForm\mid\aAct)$ then we say $\aEv$ is unsatisfiable
whenever $\aForm$ is unsatisfiable, $\aEv$ writes $\aVal$ to $\aLoc$ whenever
$\aAct$ writes $\aVal$ to $\aLoc$, and so forth.

We write pairs in $(\Formulae\times(\Act\cup\Sub))$ as $(\aForm \mid \aActSub)$.
We elide $\aForm$ when $\aForm$ is a tautology, and write $\aActSub$ crossed-out %($\NEVER\aAct$)
when $\aForm$ is unsatisfiable.
We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \nonevent{wy0}{\DW{\bLoc}{0}}{right=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \po{rx1}{wy0}
  \po[out=30,in=150]{rx1}{wy1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[\begin{array}{c}
  E = \{ 0,1,2 \} \quad
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \\
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\end{array}\]
We visualize $(\bEv \gtN \aEv)$ as a dashed
arrow from $\bEv$ to $\aEv$.
We refer to edges introduced by $(\bEv < \aEv)$ as
\emph{strong edges} and by $(\bEv \gtN \aEv)$
as \emph{weak edges}.
For readability, we often highlight the reads-from edges as well.
% for example:
For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=2.5 em of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \wk{rx1}{wx2}
\end{tikzpicture}\]

\subsection{Semantics of programs}
\label{sec:semantics}

\begin{figure*}
\begin{eqnarray*}
  \sem{\SKIP}
  & = & \TIKZ{\final{f}{}{}} 
  \\
  \sem{\aLoc\GETS\aExp}
  & = & \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\aExp=\aVal\mid\DW\aLoc\aVal)}{}\final{f}{\aExp/\aLoc}{right=of a}}
  \\
  \sem{\aLoc\GETS\aExp}
  & = & \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\aExp=\aVal\mid\DW\aLoc\aVal)}{}\final{f}{\aVal/\aLoc}{right=of a}}
  \\
  \sem{\aReg\GETS\aLoc}
  & = &
  \TIKZ{\final{f}{\aLoc/\aReg}{}}
  \cup
  \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\DR\aLoc\aVal)}{}\final{f}{\aLoc/\aReg}{right=of a}\po{a}{f}}
  \\
  \sem{\IF (\aExp) \THEN \aCmd \ELSE \bCmd \FI}
  & = & \bigl((\aExp \neq 0) \guard \sem{\aCmd}\bigr) \parallel \bigl((\aExp=0) \guard \sem{\bCmd}\bigr)
  \\
  \sem{\aCmd \SEQ \bCmd}
  & = & \sem{\aCmd} \sequence \sem{\bCmd}
  \\
  \sem{\aCmd \PAR \bCmd}
  & = & \sem{\aCmd}\fork \parallel \sem{\bCmd}
  \\
  \sem{\VAR\aLoc\SEMI \aCmd}
  & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
\caption{Semantics of a concurrent shared-memory language}
\label{fig:programs}
\end{figure*}

In Figure~\ref{fig:programs}, we give the semantics of a simple shared-memory
concurrent language as sets of pomsets.  
Each pomset
$\aPS\in\sem{\aCmd}$ represents a single execution of $\aCmd$.  We do not
expect $\sem{\aCmd}$ to be prefixed closed; thus, one may view each
$\aPS\in\sem{\aCmd}$ as a \emph{completed} execution.  However, the sets of
pomsets given by our semantics \emph{are} closed with respect to
augmentation, which may create additional order and strengthening
preconditions:
\begin{definition}
  $\aPS'$ is an augmentation of $\aPS$ if $\Event'=\Event$, $\aEv\le\bEv$
  implies $\aEv\le'\bEv$, $\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$, and
  % $\labelling'(\aEv)=\labelling(\aEv)$
  if $\labelling(\aEv) = (\bForm \mid \bAct)$ then
  $\labelling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies
  $\bForm$.
\end{definition}

We give the semantics using combinators over sets of pomsets, defined below.
Using $\aPSS$ to range over sets of pomsets, these are:
\begin{itemize}
\item \emph{forking} $\aPSS\fork$, which removes final states from
  $\aPSS$, 
% \item \emph{substitution} $\aPSS[\aExp/\aLoc]$, which replaces $\aLoc$ with
%   $\aExp$ in every precondition of $\aPSS$,
\item \emph{guarding} $\aForm\guard\aPSS$, which filters $\aPSS$,
  keeping pomsets whose events have preconditions that imply $\aForm$,
\item \emph{restriction} $\nu\aLoc\st\aPSS$, which filters $\aPSS$ to include
  only pomsets where every event $\aEv$ that reads from $\aLoc$ \emph{can read} from some
  $\bEv$, following Definition~\ref{def:rf},
  and where no precondition can depend on $\aLoc$,
\item \emph{composition} $\aPSS_1\parallel\aPSS_2$, which unions pomsets from
  $\aPSS_1$ and $\aPSS_2$, allowing events to be merged, and
\item \emph{sequencing} $\aPSS_1\sequence\aPSS_2$, which prepends
  $\aPSS_1$ to $\aPSS_2$, calculating dependencies between the two.
\end{itemize}
These operations are similar to those from models of concurrency such
as~\cite{Brookes:1984:TCS:828.833}, but adapted here to the setting of
speculative evaluation.



%% A write generates a write event that may be visible
%% to other threads.  A read may see a
%% thread-local value, or it may generate a read event that must be justified by
%% another thread.  In the latter case, occurrences of $\aReg$ are replaced with
%% $\aLoc$ (rather than $\aVal$) to ensure that dependencies are tracked
%% properly.  The subsequent substitution of $\aVal$ for $\aLoc$ occurs in
%% Definition~\ref{def:prefix} of prefixing.



% We have completed the formal definition of our model of speculative
% evaluation, and now turn to examples.

\subsection{Forking and Guarding} % and Substitution}

Forking is %and substitution each perform
a simple transformation on each pomset
in a set of pomsets.

\begin{definition}
Let $\aPSS\fork$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \EAct$,
${\le'} = {\le}$, 
${\gtN'} = {\gtN}$, and
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) =
  (\bForm\bSub \mid \aAct)$.
\end{itemize}
\end{definition}

Guarding filters a set of pomsets; we have
$(\aForm\guard\aPSS)\subseteq\aPSS$.
The definition is straightforward:
\begin{definition}
Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aActSub)$ then $\aForm$ implies $\bForm$.
\end{itemize}
\end{definition}

% Substitution updates the preconditions in a pomset, thus we expect the number
% of pomsets to be unchanged; in addition, the number of events in each of the
% pomsets is unchanged.

% \begin{definition}
% Let $\aPSS\bSub$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
% there is $\aPS\in\aPSS$ such that:
% $\Event' = \Event$,
% ${\le'} = {\le}$, 
% ${\gtN'} = {\gtN}$, 
% \begin{itemize}
% \item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) =
%   (\bForm\bSub \mid \aAct)$, and
% \item if $\labelling(\aEv) = (\bForm \mid \aSub)$ then $\labelling'(\aEv) = (\bForm\bSub \mid \aSub\bSub)$.
% \end{itemize}
% \end{definition}


\subsection{Restriction}
\label{sec:restriction}

Restriction also filters a set of pomsets; we have
$(\nu\aLoc\st\aPSS)\subseteq\aPSS$.  The definition requires that we define
when a read is possible.

\begin{definition}\label{def:rf}
  In a pomset, $\aEv$ \emph{can read $\aLoc$ from} $\bEv$ whenever: 
  \begin{itemize}
  \item $\bEv < \aEv$,
  \item $\aEv$ implies $\bEv$,
  \item $\bEv$ writes $\aVal$ to $\aLoc$,
    and $\aEv$ reads $\aVal$ from $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}
\end{definition}

\begin{definition}
\label{def:x-closed}
  A 3-valued pomset is $\aLoc$-closed if,
  for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads from $\aLoc$, then there is a $\bEv$ such that $\aEv$ can read $\aLoc$ from $\bEv$.
  \end{itemize}
\end{definition}

\begin{definition}
  A 3-valued pomset is \emph{partially} (resp.~\emph{totally}) $\aLoc$-\emph{coherent}
  if, when restricted to events which touch $\aLoc$,
  $\gtN$ forms a partial (resp.~total) order.
\end{definition}

\begin{definition}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed and partially $\aLoc$-coherent.
\end{definition}


\subsection{Composition}
Composition is used in giving the semantics for conditionals and concurrency.
$\aPSS_1 \parallel \aPSS_2$ contains the union of pomsets from $\aPSS_1$ and
$\aPSS_2$, allowing overlap as long as they agree on actions. For example, if
$\aPSS_1$ and $\aPSS_2$ contain:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \mid \bAct}{right=of a}
  \po{a}{b}
\end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm_2 \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \wk{b}{c}
\end{tikzpicture}\]
then $\aPSS_1 \parallel \aPSS_2$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{a}{b}
  \wk{b}{c}
\end{tikzpicture}\]

\begin{definition}
Let $\aPS' \in (\aPSS_1 \parallel \aPSS_2)$
whenever there are $\aPS_1 \in \aPSS_1$ and $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event' = \Event_1 \cup \Event_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le' \bEv$,
\item if $\aEv \gtN_1 \bEv$ or $\aEv \gtN_2 \bEv$ then $\aEv \gtN' \bEv$,
\item if $\labelling'(\aEv) = (\aForm' \mid \aActSub)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aActSub)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aActSub)$
    and $\aForm'$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aActSub)$ and $\aEv \not\in \Event_2$
    and $\aForm'$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aActSub)$ and $\aEv \not\in \Event_1$
    and $\aForm'$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
\end{definition}
% We use $\aPSS_1 \parallel \aPSS_2$ in defining the semantics of conditionals
% and concurrency.
% It contains the union of pomsets from $\aPSS_1$ and $\aPSS_2$,
% allowing overlap as long as they agree on actions. For example, if
% $\aPSS_1$ and $\aPSS_2$ contain:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \mid \bAct}{right=of a}
%   \po{a}{b}
% \end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
%   \event{b}{\bForm_2 \mid \bAct}{}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \wk{b}{c}
% \end{tikzpicture}\]
% then $\aPSS_1 \parallel \aPSS_2$ contains:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \wk{b}{c}
% \end{tikzpicture}\]


\subsection{Sequencing}
Prefixing is used in giving the semantics of reads and writes.
$\aAct\prefix\aPSS$ adds a new event $\cEv$ with action $\aAct$ to each
pomset in $\aPSS$.  As in the definition of parallel composition, the
definition allows the new event to overlap with events in $\aPSS$ as long as
they agree on the action.

If $\cEv$ writes to a location that is also written by $\aEv$ in $\aPSS$,
then prefixing introduces weak order between them: $\cEv \ltN \aEv$.  This
ensures that these writes cannot be given the reverse order in an augmentation.

If $\cEv$ reads from a location that occurs in the predicate of $\aEv$, then
prefixing introduces order from $\cEv$ to $\aEv$.
whose predicate depends on $\aLoc$. 
For example, if $\aAct$ and $\bAct$ write to the same location, $\aAct$ reads
$\aVal$ from $\aLoc$, $\bForm$ is independent of $\aLoc$, and $\aPSS$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{b}{c}
\end{tikzpicture}\]
then $\aAct\prefix\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm \mid \bAct}{right=of a}
  \event{c}{\cForm[\vec\aVal/\vec\aLoc] \mid \cAct}{right=of b}
  \po[out=25,in=155]{a}{c}
  \wk{a}{b}
  \po{b}{c}
\end{tikzpicture}\]

% We say $\aEv$ \emph{depends on} $\cEv$ if
% $\labelling(\aEv) = (\bForm \mid \dontcare)$,
% $\labelling(\cEv) = (\dontcare \mid \aSub)$,
% and $\bForm$ depends on $\aSub$.

% We say $\aEv$ \emph{conflicts with}  $\bEv$ if
% $\labelling(\aEv) = (\dontcare \mid \aAct)$,
% $\labelling(\cEv) = (\dontcare \mid \bAct)$,
% $\aAct$ and $\bAct$ touch the same location, and either
% $\aAct$ or $\bAct$ is a write.

We say that $\aPS'$ is an \emph{isomorphism} of $\aPS$ if there is a bijection
$f:\Event\fun\Event'$
such that
% \begin{itemize}
% \item
  $\labelling(\aEv)=\labelling'(f(\aEv))$,
%\item
  $\aEv\le\bEct$ iff $f(\aEv)\le'f(\bEv)$, and
%\item
  $\aEv\gtN\bEct$ iff $f(\aEv)\gtN'f(\bEv)$.
%\end{itemize}

\begin{definition}
  \label{def:seq}
  Let $\aPS' \in (\aPSS_1 \sequence \aPSS_2)$ whenever there are
  $\aPS_1 \in \aPSS_1$, $\aPS_2 \in \aPSS_2$, and for every $\cEv\in\ESub_1$
  there are isomorphisms $\aPS_{\cEv}$ of $\aPS_2$ such that:
\begin{itemize}
\item $\Event' = \EAct_1 \cup \bigcup_{\cEv}\Event_{\cEv}$,
\item if $\bEv \le_1 \aEv$ or $\bEv\le_{\cEv} \aEv$ then $\bEv \le' \aEv$,
\item if $\bEv \gtN_1 \aEv$ or $\bEv\gtN_{\cEv} \aEv$ then $\bEv \gtN' \aEv$,
\item if $\bEv\in\EAct_1$ then $\labelling'(\bEv) = \labelling_1(\bEv)$
\item if
  $\labelling_1(\bEv) = (\dontcare {\mid} \aActSub)$,
  $\labelling_1(\cEv) = (\aForm {\mid} \aSub)$, and
  $\labelling_{\cEv}(\aEv) = (\bForm {\mid} \bActSub)$ then
  $\labelling'(\aEv) = (\bForm' \mid \bActSub\aSub)$ where:
  \begin{itemize}
  \item $\bForm'$ implies $\aForm$ and $\bForm\aSub$,
  \item if $\aActSub$ is an acquire or $\bActSub$ is a release then $\bEv <' \aEv$,
  \item if $\aActSub$ is an acquire then $\bForm$ is independent of every $\bLoc$,
  \item if $\bEv \le_1 \cEv$ and $\bForm$ depends on $\aSub$ then $\bEv \le'
    \aEv$, and
  \item if $\aActSub$ and $\bActSub$ touch the same location and one is a write,
    then $\bEv \gtN' \aEv$.
  \end{itemize}
\end{itemize}
\end{definition}

\newpage

\begin{definition}
  \label{def:prefix}
Let $\aAct \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{\cEv\}$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item if $\bEv \ltN \aEv$ then $\bEv \ltN' \aEv$,
\item $\labelling'(\cEv) = (\aForm, \aAct)$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then $\labelling'(\aEv) =
  (\bForm' \mid \bAct)$, where:
  \begin{itemize}
  \item if $\aAct$ is an acquire or $\bAct$ is a release then $\cEv <' \aEv$, 
  \item if $\aAct$ is an acquire then $\bForm$ is independent of every $\bLoc$,
  \item if $\aAct$ and $\bAct$ both touch the same location and one is a write,
    then $\cEv \gtN' \aEv$, and
  \item $\bForm'$ implies \(\left\{\begin{array}{l@{~}ll}
    % \bForm[\aVal/\aLoc]                     & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} & \textsc{[dependent read]} \\
    % \bForm[\aVal/\aLoc] \text{ and } \bForm & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  & \textsc{[independent read]} \\
    % \bForm                                  & \mbox{otherwise}                                              & \textsc{[non-read]} \\        
    \bForm[\aVal/\aLoc]                     \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} \\\qquad \textsc{[dependent read]} \\[\jot]
    \bForm[\aVal/\aLoc] \text{ and } \bForm \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  \\\qquad \textsc{[independent read]} \\[\jot]
    \bForm                                  \\\quad \mbox{otherwise}                                              \\\qquad \textsc{[non-read]} \\
  \end{array}\right.\)
  \end{itemize}
\end{itemize}
\end{definition}

\begin{comment}
The first constraint ensures that events are ordered before a release and
after an acquire.  The second constraint ensures that thread-local reads do
not cross acquire fences.
 
The second constraint prevents bad executions like the following:
   x=1; rel; acq; if (x) {y=1};  ||  acq; x=0; rel; 
where the second thread is interleaved between the rel and acq of the first.

Note that you cannot require that $\bForm'$ is independent of every $\bLoc$
because then it's not augment closed.
\end{comment}



% Local Variables:
% mode: latex
% TeX-master: "paper"
% End: