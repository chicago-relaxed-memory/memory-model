\section{The Model}
\label{sec:model:intro}

We define the model and give the semantics of a concurrent language.  We
layer the presentation, beginning with a simple language that supports only
read and write operations.  Later, we define extensions that incorporate
address computation, fences, and read-modify-write operations.  As is common
for work on relaxed memory, we treat loops via unrolling: loops introduce
complexities---such as liveness and continuity---that are orthogonal to the
main topic of the paper.
\begin{comment}
https://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/

Cannot encode R/A actions with actions+fences...

A release operation prevents preceding memory operations from being delayed
past it (a;Rel =/=> Rel;a)
 
A release fence prevents preceding memory operations from being delayed past
subsequent writes (a;FR;w =/=> w;a;FR)

An acquire operation prevents subsequent memory operations from being advanced
before it (Acq;a =/=> a;Acq)

An acquire fence prevents subsequent memory operations from being advanced
before prior reads (r;FA;a =/=> FA;a;r)

https://www.modernescpp.com/index.php/fences-as-memory-barriers

StoreLoad: Full fence allows a store before to be reordered with respect to a
load after (wx;F;ry) ===> (ry;F;wx)

StoreLoad+LoadLoad: Release fence also allows (rx;FR;ry) ===> (ry;FR;rx)

StoreLoad+StoreStore: Acquire fence also allows (wx;FR;wy) ===> (wy;FR;wx)

LoadStore: No fence allows a prior load to reorder w.r.t. a subsequent store
(rx;FR;wy) =/=> (wy;FR;rx)

https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/
Good news is that a fullFence does it.

Bizarrely, it seems this is not supported in C++... You have to go to assembly.
\end{comment}

\paragraph{Data models.}
A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\dVal$ and $\cVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$, $\cExp$ and $\dExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by $\aLoc$ and
  $\bLoc$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$, and
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$.
\end{itemize}

Let $\aSub$ range over substitutions of the form
$[\aLoc/\aReg]$ or $[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item values, registers, and memory locations are disjoint,
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
%\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations, % or the operator $\REF{\aExp}$,
\item formulae include at least %$\TRUE$, $\FALSE$, and
  equalities %of the form
  $(\aExp=\aVal)$, % and $(\REF{\aExp}=\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution\footnote{Since formulae are closed under substitutions of the
    form $\aForm[\aLoc/\aReg]$, they must include equalities of the form
    $(\aEExp=\aVal)$ and $(\REF{\aEExp}=\aLoc)$, where $\aEExp$ is an
    \emph{extended expression} that includes memory locations.  We elide the
    details.  By composition of the closure conditions, formulae must also be
    closed under that substitutions of the form
    $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.}, and
\item there is a relation $\vDash$ between formulae.
\end{itemize}

We use expressions as formulas, coercing $\aExp$ to $\aExp\neq 0$.

For the actions of a data model, we require that
% \begin{itemize}
% \item
  there are partial functions $\rreads$ and
  $\rwrites: \Act \fun (\Loc \times \Val)$, and
%\item
  there are sets $\Acq$ and $\Rel$ and $\SC \subseteq\Act$ such that
  $\SC\cap\rreads\subseteq\Acq$ and
  $\SC\cap\rwrites\subseteq\Rel$. %, and
% \item there is a function $\finternalize: \Act \fun \Act$ that
%   satisfies the restrictions given below.
%\end{itemize}

% $\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes to}
% $\aLoc$ when $\rwrites(\aAct) = (\aLoc,\aVal)$, for some $\aVal$. % (possibly $\bot$).
%
% Actions that read or write values are \emph{external},
% actions that read or write $\bot$ are \emph{internal}.
% % Actions in
% % $\Ext=\fdom(\rreads)\cup\fdom(\rwrites)$ are \emph{external}, whereas those
% % in $\Int=\Act\setminus\Ext$ are \emph{internal}.
%
  We say that $\aAct$ is a \emph{read} if $\aAct\in\fdom(\rreads)$, a
  \emph{write} if $\aAct\in\fdom(\rwrites)$, an \emph{acquire} if
  $\aAct\in\Acq$, is a \emph{release} if $\aAct\in\Rel$, and \emph{SC} if
  $\aAct\in\SC$.  Note that these are \emph{not} disjoint.
% % We say that $\aAct$ is a
% % \emph{synchronization} if it is either a release or an acquire.
When $\rreads(\aAct) = (\aLoc,\aVal)$, we say that $\aAct$ \emph{reads}
$\aVal$ \emph{from} $\aLoc$, and similarly for writes.

% The actions listed above are \emph{external}.  Each external action has a
% corresponding \emph{internal} action, denoted by prefixing $\tau$.  Internal
% actions also read and write locations, just as external actions do,
% but are not used to model communication between threads,
% so we do not record their value.
% \footnote{Fences have a limited role in our
% discussion.  We inappropriately refer to them as synchronizations for
% simplicity.}.


Logical formulae include equations over locations and registers, such
$(\aLoc{=}1)$ and $(\aReg{=}\bReg{+}1)$.  Formulae are \emph{open}, in that
occurrences of register names and memory locations are subject to
substitutions of the form $\aForm[\aLoc/\aReg]$ and $\aForm[\bExp/\aLoc]$.
% where %$\aLoc$ is a memory location, $\aReg$ is a register and
% $\bExp$ is an
% memory-location-free expression.
Actions are not subject to substitution.


% % We require that $\finternalize$ satisfy the following:
% % \begin{itemize}
% % \item $\finternalize(\aAct)$ reads $\bot$ from $\aLoc$ exactly when $\aAct$ reads from $\aLoc$,
% % \item $\finternalize(\aAct)$ writes $\bot$ to $\aLoc$ exactly when $\aAct$ writes to $\aLoc$,
% % %\item the codomain of $\finternalize$ includes only internal actions, %$\fcodom(\finternalize)\subseteq\Int$,
% % \item $\finternalize(\aAct)$ is an acquire exactly when $\aAct$ is an acquire, 
% % \item $\finternalize(\aAct)$ is a release exactly when $\aAct$ is a release, and
% % \item $\finternalize(\aAct)$ is SC exactly when $\aAct$ is SC. 
% % \end{itemize}

% As noted in \textsection\ref{sec:model:intro}, our example language includes
% SC read $(\DRSC{\aLoc}{\aVal})$, acquiring
% read $(\DRAcq{\aLoc}{\aVal})$, relaxed read $(\DR{\aLoc}{\aVal})$, SC write
% $(\DWSC{\aLoc}{\aVal})$, releasing
% write $(\DWRel{\aLoc}{\aVal})$, and relaxed write $(\DW{\aLoc}{\aVal})$.
% For each external action, we also define a corresponding internal action
% %which replaces the letter $\mathsf{R}$ or $\mathsf{W}$ with $\tau$.
% $(\iDRSC{\aLoc}{\aVal})$,
% $(\iDRAcq{\aLoc}{\aVal})$,
% $(\iDR{\aLoc}{\aVal})$,
% $(\iDWSC{\aLoc}{\aVal})$,
% $(\iDWRel{\aLoc}{\aVal})$, and
% $(\iDW{\aLoc}{\aVal})$.
% In pictures, we draw internal actions grayed out,
% rather than using $\bot$.  % For example, the ``read'' action is internal in:
% % \begin{tikzdisplay}[node distance=1em]
% %   \event{wx1}{\DW{x}{1}}{}
% %   \internal{rx1}{\DR{x}{1}}{below right=of rx1}
% %   \event{wy1}{\DW{y}{1}}{above right=of wy0}
% %   \po{wx1}{wy1}
% % \end{tikzdisplay}

%We also include acquire-release fences of the form $(\DF)$.

% In examples, we use fence actions of the form $(\DF{\aF})$, where the annotation
% indicates that the fence is a release ($\FR$), an acquire ($\FA$) or both ($\FF$):
% \begin{displaymath}
%   \aF\BNFDEF\FR\BNFSEP\FA\BNFSEP\FF
% \end{displaymath}

% \subsection{3-valued pomsets with preconditions}

% Fix an alphabet $\Alphabet=(\Formulae\times\Act)$.

For the formulae of the data model,
we say that $\aForm$ is \emph{independent of $\aLoc$} when
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$, and that
$\aForm$ is \emph{dependent on $\aLoc$} otherwise.  We say that $\aForm$ is
\emph{location independent} if it is independent of every location.
%
We say that $\aForm$ \emph{implies} $\bForm$ when $\aForm\vDash\bForm$,
that $\aForm$ is a \emph{tautology} when $\TRUE\vDash\aForm$, and that
$\aForm$ is \emph{unsatisfiable} when $\aForm\vDash\FALSE$.

\paragraph{Example Language.}
Our example language include actions of the form
$(\DR[\amode]{\aLoc}{\aVal})$, which \emph{reads} value $\aVal$ from location
$\aLoc$ and $(\DW[\amode]{\aLoc}{\aVal})$, which \emph{writes} $\aVal$ to
$\aLoc$.
% The \emph{mode} $\amode$ is either \emph{relaxed} ($\modeRLX$),
% \emph{release-acquire} ($\modeRA$) or \emph{sequentially-consistent} ($\modeSC$).
The \emph{access mode} $(\amode \!\!\BNFDEF\!\! \modeRLX \!\BNFSEP\! \modeRA \!\BNFSEP\! \modeSC)$ is
either \emph{relaxed}, \emph{release-acquire}, or
\emph{sequentially-consistent}.
$\modeRA$/$\modeSC$ reads are acquires, and $\modeRA$/$\modeSC$ writes are releases.

We elide the $\modeRLX$-mode annotation in examples.
% We write $\modeREL$ and $\modeACQ$ as synonyms for $\modeRA$.
\begin{comment}
\footnote{We only consider executions where register state is empty in
  forked threads.  Given item~\ref{pre-acquire} of
  Definition~\ref{def:prefix}, a sufficient condition is that parallel
  composition is always preceded by an acquire fence, as in programs of the
  form:
  \begin{displaymath}
    \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
  \end{displaymath}
  where $\aCmd^1$, \ldots, $\aCmd^n$ do not include $\PAR$.  To avoid clutter
  in drawings, we often drop the explicit fence.}.
\end{comment}
% \begin{align*}
% \aCmd,\,\bCmd
% \BNFDEF& \SKIP \tag{No Operation}
% \\[-1ex]\BNFSEP& \FENCE\SEMI \aCmd \tag{Full fence}
% \\[-1ex]\BNFSEP& \REF{\cExp}\GETS\aExp\SEMI \aCmd \tag{Relaxed write to memory}
% \\[-1ex]\BNFSEP& \REF{\cExp}\REL\GETS\aExp\SEMI \aCmd \tag{Releasing write to memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\SEMI \aCmd \tag{Relaxed read from memory}
% \\[-1ex]\BNFSEP& \aReg\GETS\REF{\cExp}\ACQ\SEMI \aCmd
% \\[-1ex]\BNFSEP& \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
% \\[-1ex]\BNFSEP& \aCmd \PAR \bCmd
% \\[-1ex]\BNFSEP& \VAR\aLoc\SEMI \aCmd
% \end{align*}
%The syntax of statements is as follows.
\begin{align*}
  % \amode \BNFDEF& \modeRLX \BNFSEP \modeRA \BNFSEP \modeSC
  % \\
\aCmd,\,\bCmd
\BNFDEF& \SKIP
\BNFSEP \aReg\GETS\aExp\SEMI \aCmd
\BNFSEP \VAR\aLoc\SEMI \aCmd
\\[-.5ex]
\BNFSEP&\aCmd \PAR \bCmd
\BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\\[-.5ex]
\BNFSEP& \aReg\GETS\aLoc^{\amode}\SEMI \aCmd 
\BNFSEP \aLoc^{\amode}\GETS\aExp\SEMI \aCmd
\end{align*}




We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.

We write
$\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$ and
$\IF{\aExp} \THEN \aCmd^1 \ELSE \aCmd^2 \FI \SEMI \bCmd$ as shorthand for
$\IF{\aExp} \THEN \aCmd^1 \SEMI \bCmd\ELSE \aCmd^2 \SEMI \bCmd\FI$.
% and
% $\VAR\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for
% $\VAR\aLoc\SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\REL\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\FENCE_{\FR} \SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\ACQ\aReg\GETS\aLoc\SEMI \aCmd$ as shorthand for $\aReg\GETS\aLoc\SEMI \FENCE_{\FA}\SEMI \aCmd$.

\paragraph{The semantic domain.}
Our model is based on \emph{partially ordered multisets} (\emph{pomsets})~\cite{GISCHER1988199}.
\begin{definition}
  \label{def:mmpomset}
  A \emph{(memory model) pomset} is a tuple
  $(\Event, {\le}, %{\gtN},
  \labeling)$: %, such that
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, 
  \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
    % define $\labelingForm(\aEv)=\aForm$ and $\labelingAct(\aEv)=\aAct$ when
    % $\labelingForm(\aEv)=(\aForm\mid\aAct)$,
  % \item ${\gtN} \subseteq (\Event\times\Event)$ is a partial order,
  % \item ${\le} \subseteq {\gtN}$ is a partial order, and
  \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
    $\labelingForm(\bEv)$, and
  \item $\bigwedge_{\aEv}\labelingForm(\aEv)$ is satisfiable.
  \end{itemize}
\end{definition}
From $\labeling$, we derive functions $\labelingForm:\Event\fun\Formulae$ and $\labelingAct:\Event\fun\Act$.

We refer to ``memory model pomsets'' as \emph{pomsets} or \emph{executions}.
We write pairs in $(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$, eliding
$\aForm$ when it is a tautology.
We write $\bEv\lt\aEv$ when $\bEv\le\aEv$ and $\bEv\neq\aEv$.

We lift terminology from logical formulae and actions to events, saying, for example,
that $\aEv$ is unsatisfiable if $\labelingForm(\aEv)$ is unsatisfiable. % ,
% and that $\aEv$ is an acquire when $\labelingAct(\aEv)$ is an acquire.
We often elide explicit universal quantifiers in phrases such as
``\emph{for all $\aEv$}, $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.''

The ordering relation, $\le$, represents \emph{causality}.

The formula associated with an event is a \emph{precondition}.
The following commands gives rise to the pomset below them, capturing data
and control dependencies. %, respectively.
\begin{align}
  \label{ex-1}
  \begin{gathered}
    y\GETS r
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r=1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r<0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align}
In mapping the Hoare triple $\hoare{\aForm}{\aCmd}{\bForm}$ to our semantics,
$\bForm$ represents a set of write actions, and $\aForm$ represents their
preconditions.  
% Each write in a pomset corresponds to a Hoare triple, where the formulae
% gives the precondition, and the write action gives the postcondition.  
For example, interpreting the pomset on the left above yields
$\hoare{\aReg =1}{y\GETS \aReg}{y=1}$.

The fourth requirement ensures \emph{causal strengthening:} formulae do not
weaken over time, as measured by $\le$.  

The last requirement ensures \emph{compatibility:} formulae are not mutually
contradictory.  For complete programs, we can restrict attention to events
that are tautological.  Richer formulae are needed for intermediate program
fragments.

The semantics of programs is given as sets of pomsets, with each pomset
representing a completed execution.
%
We expect sets of pomsets given by the semantics to be closed with
respect to \emph{augmentation}, \emph{implication} and \emph{isomorphism}:
\begin{definition}
  Let
  $\aPS'$ be an \emph{augmentation} of $\aPS$ if $\Event'=\Event$,
  ${\labeling'}={\labeling}$, and ${\le'}\supseteq{\le}$. %, and ${\gtN'}\supseteq{\gtN}$.
  %
  Let
  $\aPS'$ \emph{imply} $\aPS$ if $\Event'=\Event$, ${\le'}={\le}$,
  %${\gtN'}={\gtN}$,
  $\labelingAct'=\labelingAct$, and $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$. % for all $\aEv$. %\in\Event$.
  %
  Let
  $\aPS'$ be an \emph{isomorphism} of $\aPS$ if there is a bijection
  $f:\Event\fun\Event'$ such that $\labeling(\aEv)=\labeling'(f(\aEv))$, and
  $\aEv\le\bEv$ iff $f(\aEv)\le'f(\bEv)$. %, and $\aEv\gtN\bEv$ iff $f(\aEv)\gtN'f(\bEv)$.
\end{definition}


% Each pomset $\aPS\in\sem{\aCmd}$ is a \emph{completed} execution of $\aCmd$;
% we sometimes refer to pomsets as \emph{executions}.  Because they are
% completed executions, we do not expect $\sem{\aCmd}$ to be prefixed closed.
% However, implication closure in a memory-model pomset does give something
% similar: any event $\aEv$ can be given an unsatisfiable precondition, which
% means that every event ordered after $\aEv$ must also be unsatisfiable, as
% per Definition~\ref{def:mmpomset}.  In many applications of the model,
% unsatisfiable events are ignored, thus providing a kind of prefix closure.
% % \begin{definition}
% %   $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$, ${\labeling'}={\labeling}$,
% %   ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
% %   and ${\gtN}\subseteq{\gtN'}$. %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$,
% %   % $\labelingAct'=\labelingAct$, and  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.
% %   % if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies $\bForm$.
% % \end{definition}
 We visualize pomsets as directed graphs.
%where the nodes are drawn from $\Event$, each node $\aEv$ is labeled with $\labeling(\aEv)$, and order is drawn as an edge.
% We often elide events with disjoint
% preconditions---$\aForm$ and $\bForm$ are \emph{disjoint} if
% $\aForm \land \bForm$ is unsatisfiable.  For example, we typically drop
% unsatisfiable events.
 In examples, we draw pomsets that are augmentation-minimal and
 implication\hyp{}minimal.  For example, the semantics of
\begin{math}
  \VAR\aLoc\SEMI(
  x\GETS 0\SEMI
  x\GETS 1
  \PAR
  y\GETS x)
  %\aReg\GETS x\SEMI y\GETS \aReg)
\end{math}
includes:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \po{rx1}{wy1}
\end{tikzdisplay}
We visualize order using arrows that indicate the reason that the order
arises.
$\DW{x}{1}\xrf\DR{x}{1}$ is a \emph{reads-from} requirement: the read of $x$
must be fulfilled by a matching write.
$\DW{x}{0}\xwk\DW{x}{1}$ is a \emph{coherence} requirement: the write of $1$
must follow the write to $0$, since these are in program order.
$\DR{x}{1}\xpo\DW{y}{1}$ is a \emph{dependency} requirement: the write to $y$
depends on the read of $x$.
Although we use multiple arrows, we emphasize that they are all part
of the same $\le$ relation.



\paragraph{Semantics of the Example Language.}
In the remainder of this section, we explain the semantics of our example
language.  By far the most complex operators are the prefixing
operators---read and write---which introduce new actions.  We first discuss
the other operators.
% the orders are drawn with
% \citeauthor{DBLP:journals/dc/Lamport86}'s notation.  
% For example:
% \begin{tikzdisplay}[node distance=1em]
%   \event{rx1}{a}{}
%   \event{wy0}{b}{below right=of rx1}
%   \event{wy1}{c}{above right=of wy0}
%   \po{rx1}{wy0}
%   \po{rx1}{wy1}
%   \wk{wy0}{wy1}
% \end{tikzdisplay}
% is a visualization of the pomset where:
% \[\begin{array}{c}
%     E = \{ 0,1,2 \}
%     \quad
%     {\labeling} = \{(0,a),\,(1,b),\,(2,c)\}
%     \\
%     {\le} = \{(0,1),\,(0,2)\}\cup\{(0,0),\,(1,1),\,(2,2)\}
%     \quad
%     {\gtN} = {\le}\cup\{(2,3)\}
% \end{array}\]
% for example:


%The semantics of $\SKIP$ and register assignment are simple:
\begin{definition}
Let $(\aPSS\aSub)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when
there is $\aPS\in\aPSS$ such that:
$\Event' = \Event$,
${\le'} = {\le}$, 
%${\gtN'} = {\gtN}$,
and
$\labeling'(\aEv) = (\bForm\aSub \mid \aAct)$ when $\labeling(\aEv) = (\bForm \mid \aAct)$.
\begin{align*}
  \sem{\SKIP} & \eqdef
  \{ \emptyset \}
  \\  
  \sem{\aReg\GETS\aExp\SEMI \aCmd} & \eqdef
  \sem{\aCmd}[\aExp/\aReg] 
\end{align*}
\end{definition}


\begin{definition}
  \label{def:rf}
  We say $\bEv$ \emph{fulfills $\aEv$ on $\aLoc$} if $\bEv$ \externally writes
  $\aVal$ to $\aLoc$, $\aEv$ \externally reads $\aVal$ from $\aLoc$,
  \begin{itemize}
  \item
    $\bEv \lt \aEv$, and
  \item
    if $\cEv$ \externally writes to $\aLoc$ then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}

  A pomset is \emph{$\aLoc$-closed} if every \external read on $\aLoc$ is fulfilled,
  and every event is independent of $\aLoc$.
  A pomset is \emph{top-level} if it is $\aLoc$-closed for every location $\aLoc$.
  Let $(\nu\aLoc\DOT\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$
  when $\aPS$ is $\aLoc$-closed.
\begin{align*}
  \sem{\VAR\aLoc\SEMI \aCmd} & \eqdef
  \nu \aLoc \DOT \sem{\aCmd}  
\end{align*}
\end{definition}

%\paragraph{Fulfillment and Location Binding.}
At the point a location is bound, every read must be \emph{fulfilled} by a
matching write.  At top-level, fulfillment imposes a total order on
conflicting writes that are read, but need not order unread writes:
\begin{gather*}
  x\GETS 3
  \PAR
  x\GETS 4
  \PAR
  r\GETS x\SEMI r\GETS x 
  \PAR
  x\GETS 1
  \PAR
  x\GETS2
  \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{below=of wx1}
  \event{rx1a}{\DR{x}{1}}{left=of wx1}
  \event{rx2a}{\DR{x}{2}}{left=of wx2}
  %\po{rx1a}{rx2a}
  \rf{wx1}{rx1a}
  \rf{wx2}{rx2a}
  \wk{rx1a}{wx2}
  \wk{wx1}{wx2}
  %\event{wx3}{\DW{x}{3}}{below left=-.2em and 1em of rx1a}
  \event{wx3}{\DW{x}{3}}{left=of rx1a}
  \event{wx4}{\DW{x}{4}}{left=of rx2a}
  \wk{rx1a}{wx3}
  \wk{rx2a}{wx3}
  %\wk{rx1a}{wx4}
  \wk{rx2a}{wx4}
    \end{tikzinline}}
\end{gather*}
The restriction of pomset order to conflicting events is called the
\emph{extended coherence order}, $\reco$.  This relation can always be
extended to totally order all conflicting events, as is common in hardware
memory models.

The definition of location binding validates \emph{scope q
  extrusion}~\cite{Milner:1999:CMS:329902}: if $\aCmd$ does not
mention~$\aLoc$ then
$\sem{\aCmd\PAR \VAR\aLoc\SEMI\bCmd}=\sem{\VAR\aLoc\SEMI(\aCmd\PAR\bCmd)}$.
However, the definition does not validate renaming of locations: if
$\aLoc\neq\bLoc$ then
$\sem{\VAR\bLoc\SEMI\aCmd}\neq\sem{\VAR\aLoc\SEMI\aCmd[\aLoc/\bLoc]}$,
even if $\aCmd$ does not mention~$\aLoc$.  This is consistent with support
for address calculation, which is required by realistic memory allocators.
%$\nu\aLoc\DOT\aPSS\neq \nu\bLoc\DOT\aPSS[\bLoc/\aLoc]$ when $\bLoc\neq\aLoc$.
% $\nu\aLoc\DOT(\aPSS\parallel\nu\aLoc\DOT\bPSS)$ is generally
% not the same as
% $\nu\aLoc\DOT(\aPSS\parallel(\nu\bLoc\DOT\bPSS[\bLoc/\aLoc]))$.

%\paragraph{Composition, Concurrency and Conditional.}
% Conditional execution is defined using pomset union and filtering, which
% selects pomsets satisfying a formula.

% \begin{definition}
%   Let $\aPS' = (\aPS^1 \cup \aPS^2)$ when $\Event' = \Event^1 \cup \Event^2$,
%   ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
%   ${\labeling'}\supseteq{\labeling^1}\cup{\labeling^2}$.

%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   Let $\aPS'\in \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}$  when
%   $\aPS\cup\aPS^1\in\sem{\aCmd}$,
%   $\aPS\cup\aPS^2\in\sem{\bCmd}$,
%   and ether\bigl(\aExp
%   \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard
%   \sem{\bCmd}\bigr)
% \end{definition}

% Composition is roughly union:
% $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.  For example, we have the
% following execution, which unions the two sides:
% \begin{gather*}
%   \IF{r<0}\THEN y\GETS1\FI
%   \PAR
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gather*}
% In addition to this execution, we allow that events with the same label to
% coalesce, taking the disjunction of their preconditions.  Thus, the semantics
% of this program also includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% $\Event' = \Event^1 \cup \Event^2$,
% ${\le'}\supseteq{\le^1}\cup{\le^2}$, and
% either
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% \begin{aligned}
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}

%\paragraph{Composition, Concurrency and Conditional.}
\begin{definition}
  % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
  % $\Event' \subseteq \Event^1 \cup \Event^2$,
  % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
  % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
  % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
  % unsatisfiable.
  Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
%$\Event' \subseteq \COMPAT(\aPS^1,\,\aPS^2)$,
$\Event' \subseteq \Event^1 \cup \Event^2$,
%$\Event' \supseteq \{ \bEv \in \Event^1 \cup \Event^2 \mid \exists\aEv\in\Event'.\; \bEv\le^1\aEv \textor \bEv\le^2\aEv\}$,
$\Event' \supseteq \{ \bEv \in \Event^i \mid \exists\aEv\in\Event'.\; \bEv\le^i\aEv\}$,
${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
either:
\begin{gather*}
  \begin{aligned}
    \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
    &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
    &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
  \end{aligned}
  \\
%\end{gather*}
% if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% \labelingForm^2(\aEv)$ is unsatisfiable.
%\begin{gather*}
\begin{aligned}
  \sem{\aCmd \PAR \bCmd} & \eqdef
  \sem{\aCmd} \parallel \sem{\bCmd} 
\end{aligned}
\end{gather*}
\end{definition}

Concurrent composition is roughly union.  Because of the compatibility
requirement in Definition~\ref{def:mmpomset}, we must not include events with
contradictory preconditions.
% : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
Consider:
\begin{align*}
\begin{gathered}
  \IF{r<0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gathered}
&&
\begin{gathered}
  \IF{r\geq0}\THEN y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
    \end{tikzinline}}
\end{gathered}
\end{align*}
Putting these in parallel, we may include one of the two events, but not
both.  We also allow events with the same label to coalesce, taking the
disjunction of their preconditions.  Thus, the semantics of the combined
program also includes:
\begin{gather*}
  % \IF{r<0}\THEN y\GETS1\FI
  % \PAR
  % \IF{r\geq0}\THEN y\GETS1\FI
  % \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
    \end{tikzinline}}
\end{gather*}
Coalesced events inherit order from both sides.

The definition ensures $\Event'$ is downclosed w.r.t.~each $\Event^i$.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}


\begin{definition}
  Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
  $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
  $\aEv\in\Event$. 
  \begin{align*}
    \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
  \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
\end{align*}
\end{definition}
Conditional execution is defined using \emph{filtering}, which selects the
subset of pomsets that imply a formula, and composition, which allows
coalescing using disjunction, as discussed above.  This reflects the Hoare
rule for conditionals:
\begin{displaymath}
  \frac{
    \hoare{\aExp}{\aCmd}{\bForm}
    \quad
    \hoare{\lnot\aExp}{\bCmd}{\bForm}
  }{
    \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
  }
\end{displaymath}
%  For an example
% using the first clause in the definition of composition,
% $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% Conditional execution and concurrency are defined using filtering, which
% selects pomsets satisfying a formula, and composition.  Composition is
% roughly union, ensuring that the combined events are compatible.
% % : $(\aPS^1\cup\aPS^2) \in (\aPSS^1 \parallel \aPSS^2)$ when
% % $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$.
% For example, consider:
% \begin{align*}
% \begin{gathered}
%   \IF{r<0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx1}{r<0\mid\DW{y}{1}}{}
%     \end{tikzinline}}
% \end{gathered}
% &&
% \begin{gathered}
%   \IF{r\geq0}\THEN y\GETS1\FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{wx2}{r\geq0\mid\DW{y}{1}}{right=of wx1}
%     \end{tikzinline}}
% \end{gathered}
% \end{align*}
% Putting these in parallel, we allow events with the same label to coalesce,
% taking the disjunction of their preconditions.  Thus, the semantics includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wx1}{r<0\lor r\geq0\mid\DW{y}{1}}{}
% \end{tikzdisplay}
% Coalesced events inherit order from both sides of the composition.
% Thus, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
%   \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
%   \event{c2}{\cForm \mid \cAct}{right=of b2}
%   \po{b2}{c2}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% \begin{definition}
%   Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that
%   $\aPS\in\aPSS$ when $\aForm$ implies $\labelingForm(\aEv)$, for every
%   $\aEv\in\Event$. 

%   % Let $\Event'\in\COMPAT(\aPS^1,\,\aPS^2)$ when
%   % $\Event' \subseteq \Event^1 \cup \Event^2$,
%   % $\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is satisfiable, and for
%   % every $\bEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, we have that 
%   % $\labelingForm(\bEv)\land\bigwedge_{\aEv\in\Event'}\labelingForm(\aEv)$ is
%   % unsatisfiable.

%   Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
% when there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that
% %$\Event' \subseteq \COMPAT(\aPS^1,\,\aPS^2)$,
% $\Event' \subseteq \Event^1 \cup \Event^2$,
% $\Event' \supseteq \{ \bEv \in \Event^1 \cup \Event^2 \mid
% \exists\aEv\in\Event'.\; \bEv\le^1\aEv \textor \bEv\le^2\aEv\}$,
% ${\le'}\supseteq({\le^1}\cup{\le^2})\restrict{\Event'}$, and for all $\aEv\in\Event'$,
% either:
% \begin{gather*}
%   \begin{aligned}
%     \;\;&\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\[-1ex]
%     &\;\;\aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\[-1ex]
%     &\;\;\aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
%   \end{aligned}
%   \\
% %\end{gather*}
% % if $\aEv\in (\Event^1 \cup \Event^2)\setminus\Event'$, then there is some
% % $\bEv\in \Event'$ such that $\labelingForm^1(\aEv)\land
% % \labelingForm^2(\aEv)$ is unsatisfiable.
% %\begin{gather*}
% \begin{aligned}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & \eqdef
%   \bigl(\aExp \guard \sem{\aCmd}\bigr) \parallel \bigl(\lnot\aExp \guard \sem{\bCmd}\bigr) 
%   \\
%   \sem{\aCmd \PAR \bCmd} & \eqdef
%   \sem{\aCmd} \parallel \sem{\bCmd} 
% \end{aligned}
% \end{gather*}
% \end{definition}

% For an example using the first clause in the definition of composition,
%  $\sem{\IF{\aExp}\THEN y\GETS1 \ELSE y\GETS1\FI}$ includes:
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\aExp\lor\lnot\aExp\mid \DW{y}{1}}{}
% \end{tikzdisplay}

% The design of the semantics is driven by Hoare rule for conditionals:
% \begin{displaymath}
%   \frac{
%     \hoare{\aExp}{\aCmd}{\bForm}
%     \quad
%     \hoare{\lnot\aExp}{\bCmd}{\bForm}
%   }{
%     \hoare{\aExp\lor \lnot\aExp}{\IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI}{\bForm}
%   }
% \end{displaymath}

% As a result of the definition, the operators commute:
% \begin{displaymath}
%   \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI}
%   =
%   \sem{\IF{\aExp} \THEN \aCmd \FI \PAR \IF{\lnot\aExp} \THEN \bCmd \FI}
% \end{displaymath}


\paragraph{Program Order Prefixing.} % for Trivial Expressions.}
We present several candidate definitions for prefixing before giving the
final definition.  We begin by considering programs with trivial expressions.

% For programs with only trivial expressions, the simplest candidate
% definitions of read and write result in top-level executions being
% sequentially consistent.
\begin{candidate}
  \label{def:rw:sc1}
  Let $(\aForm \mid \aAct) \prefixsimp \aPSS$ be the set $\aPSS'$ where
  $\aPS'\in\aPSS'$ when there is $\aPS\in\aPSS$ such that $\aPS'$ adds a
  new event with the given label that precedes all of the events in $\aPS$.
  \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsimp \sem{\aCmd}}
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS\aVal\SEMI \aCmd} & =
    %\textstyle\bigcup_\aVal\; (\bVal=\aVal \mid
    \smash{\DWmode\aLoc\aVal \prefixsimp \sem{\aCmd}}
  \end{align*}
\end{candidate}
%For now, ignore the preconditions and substitutions. We explain them in the subsections below.

The definition ensures that program order is included in the pomset order.
Due to the requirements of fulfillment, we also have that $\reco$ is included
in pomset order.  As a result, all executions are sequentially consistent.
For example, consider the \emph{store buffering} litmus test:
\begin{gather*}
  x\GETS0\SEMI x\GETS1\SEMI\aReg\GETS y
  \PAR
  y\GETS0\SEMI y\GETS1\SEMI \aReg\GETS x
  \\
  \tag{\textsc{sb}}\label{SB}
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wy0}{\DW{y}{0}}{below=of wx0}
      \event{wx}{\DW{x}{1}}{right=of wx0}
      \event{wy}{\DW{y}{1}}{right=of wy0}
      \event{ry}{\DR{y}{0}}{right=of wx}
      \event{rx}{\DR{x}{0}}{right=of wy}
      \wk{wx0}{wx}
      \wk{wy0}{wy}
      \po{wy}{rx}
      \po{wx}{ry}
      \rf{wy0}{ry}
      \rf{wx0}{rx}
      \wk{ry}{wy}
      \wk{rx}{wx}
      % \po{rx}{wy}
    \end{tikzinline}}
\end{gather*}
The read to write order is required by the definition of fulfillment.
This candidate execution is \emph{not} a pomset due to the resulting cycle;
thus it is disallowed by Candidate~\ref{def:rw:sc1}.

To allow this outcome, we will drop program order between ``independent''
actions.  Before doing that, we consider non-trivial expressions, writing the
definition of prefixing more carefully this time.  We highlight some of the changes:

%\paragraph{Program Order Prefixing.}
\begin{definition}
  \label{def:pre-sc}
Let $(\aForm \mid \aAct) \prefixsc \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when
there is $\aPS\in\aPSS$ such that:
\begin{enumerate}
\item\label{pre-E} $\Event' = \Event \uplus \{\bEv\}$,
\item\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item[3a.] $\labelingAct'(\bEv) = \aAct$,
\item[3b.] $\labelingForm'(\bEv)$ implies $\aForm$,
\item[4a.] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
\item[4b.] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
\item[4c.] if $\bEv$ does not \externally read then
  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$, and
\item[5.] $\bEv \lt' \aEv$, 
\end{enumerate}
\end{definition}
\vspace{-2ex}
\begin{candidate}\ \vspace{-1ex}
    \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \smash{\textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefixsc \sem{\aCmd}\mkern3.5mu \mathhl{[\aLoc/\aReg] }}
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS{\aExp}\SEMI \aCmd} & =
    \smash{\mathhl{\textstyle\PAR_\aVal\; (\aExp=\aVal} \mid \DWmode\aLoc\aVal) \prefixsc\; \sem{\aCmd}}
  \end{align*}
\end{candidate}

% In the definition of prefixing,
Item 1 introduces a new event.  Item 2 ensures that no order is removed from old
events. Item 3 describes the label of the new event, which must imply
$\aForm$. Item 4 describes the labels of old events, as discussed below.
Item 5 ensures that program order is included for the new event.

We first discuss writes, then reads.

For writes, item 4 is simple: For old events, the new precondition in $\aPS'$
must imply old the precondition in $\aPS$.  (This is very similar to the
treatment of the new event in item 3.)

The semantics of write introduces a write action for each possible value of
the expression $\aExp$.  To ensure that at most one write is enabled, these
are given disjoint preconditions.

The semantics is again driven by the rules of
Hoare logic---for write, the rule is left disjunction:
\begin{displaymath}
  \frac{
    \hoare{\aForm^1}{\aCmd}{\bForm}
    \quad
    \hoare{\aForm^2}{\aCmd}{\bForm}
  }{
    \hoare{\aForm^1\lor\aForm^2}{\aCmd}{\bForm}
  }
\end{displaymath}
Note that
\begin{math}
  \sem{x \GETS 1{+}r{*}r{-}r}
\end{math}
includes both of the pomsets:
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  %\\[-1.5ex]\intertext{and:}\\[-5ex]
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ1\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{align*}
By using \!$\PAR$\! in the definition of write, it also includes:
% (where,
% contrary to convention, we show disjoint events):
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{x}{1}}{}
    \end{tikzinline}}%\;\;\cdots
\end{gather*}
An alternate definition using $\cup$ would exclude this pomset.

Given that the conditional is defined using \!$\PAR$\!, the use of \!$\PAR$\!
in the definition of write is necessary to validate \emph{case analysis}:
\begin{math}
  \sem{\aCmd}
  =
  \sem{\IF{\aExp}\THEN \aCmd\ELSE \aCmd\FI}.
\end{math}


The use of \!$\PAR$\! is neither necessary nor desirable for reads.
% : the read rule does not introduce read preconditions, and item 5a of
% Definition \ref{def:prefix} ignores them.
Whereas a write action introduces a precondition---satisfied
sequentially---on the value to be written; a read introduces a pomset
requirement---fulfilled concurrently---on the value to be read.  In the
concurrent world, writes are capabilities; reads are obligations.  Thus, a
read should introduce at most one event per pomset.


In the semantics of read, item 4b %(Candidate \ref{def:pre-sc})
allows some preconditions to weaken and requires others to strength\-en.
Recall \eqref{ex-1} from the beginning of this section:
\begin{align*}
  \begin{gathered}
    y\GETS r
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r=1\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    \IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{r<0\mid\DW{y}{1}}{}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Prepending $\aReg\GETS\aLoc$ first causes the substitution $[x/r]$:
\begin{align*}
  \begin{gathered}
    r\GETS x\SEMI y\GETS r
    \\    
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x=1\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    \\
    \hbox{\small $(\DR{x}{1}) \;\prefixsc\;$}
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{x<0\mid\DW{y}{1}}{}
        % \event{rx1}{\DR{x}{1}}{left=of wy1}
        % \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
Item 4b then the substitutes the chosen value $[1/x]$:
\begin{align}
  \label{ex-2}
  \begin{gathered}
    % r\GETS x\SEMI y\GETS r
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{1=1\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{1<0\mid\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align}
We can write these more succinctly as:
% We often drop preconditions on tautological events and sometimes cross out
% unsatisfiable ones (which may are ignored):
\begin{align*}
  \begin{gathered}
    % r\GETS x\SEMI y\GETS r
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wy1}{\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
  &&
  \begin{gathered}
    % r\GETS x\SEMI\IF{r<0}\THEN y\GETS1 \FI
    % \\
    \hbox{\begin{tikzinline}[node distance=1em]
        \nonevent{wy1}{\DW{y}{1}}{}
        \event{rx1}{\DR{x}{1}}{left=of wy1}
        \po{rx1}{wy1}
      \end{tikzinline}}
  \end{gathered}
\end{align*}
On the right, the write has become impossible.  On the left, it has become
causally dependent on the read.  By prefixing a read event, the precondition
$x=1$ has moved from the sequential realm of Hoare logic to the concurrent
memory model.  Rather than a precondition that must be \emph{satisfied}, the
resulting pomset has a read event that must be \emph{fulfilled}.

% We can now explain the substitution in the semantics of read in Candidate~\ref{def:rw:sc1}.
% % (The substitution in the semantics of write \eqref{sc-write} is not used here; we explain
% % it after introducing \emph{internal reads}, below.)
% Returning to our example, to compute
% $\sem{r\GETS x\SEMI y\GETS r}$, we first compute
% $(r\EQ1\mid\DW{y}{1})[x/r]$, then perform prefixing on the resulting $(x\EQ1\mid\DW{y}{1})$.  By 4b, reading $1$
% performs the further substitution of $[1/x]$, allowing the precondition to
% weaken to $(1\EQ1)$.  Likewise, reading $0$ performs $[0/x]$, requiring the precondition
% to strengthen to $(0\EQ1)$.

% Second, the use of $\PAR$ to combine pomsets formed by write prefixing
% ensures that the semantics is ``disjunctive'' in a certain sense.
% The following example uses address calculation, defined formally in
% \textsection\ref{sec:variants}.  It also use the operator ``$\BANG \aExp$,''
% which evaluates to $1$ when $\aExp$ is $0$, and
% $0$ otherwise.  Note that 
% \begin{math}
%   \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
% \end{math}
% includes both of the following pomsets:
% \begin{align*}
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
%   \qquad
%   %\\[-1.5ex]\intertext{and:}\\[-5ex]
%   \hbox{\begin{tikzinline}[node distance=.2em]
%       \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
%       \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
%     \end{tikzinline}}%\;\;\cdots
% \end{align*}
% By using $\PAR$ rather than $\cup$, it also includes the following (where,
% contrary to convention, we show disjoint events):
% \begin{gather*}
%   \hbox{\begin{tikzinline}[node distance=.5em]
%       \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
%       \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
%       \event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
%     \end{tikzinline}}%\;\;\cdots
% \end{gather*}
% Using $\cup$, the semantics would exclude this pomset, and thus fail to
% validate \emph{case analysis}---for example, refining this program,
% \begin{math}
%   \aCmd = (a[r] \GETS 0\SEMI a[0]\GETS \BANG r),
% \end{math}
% to
% \begin{math}
%   \IF{r\EQ1}\THEN \aCmd\ELSE \aCmd\FI.
% \end{math}

\paragraph{General Prefixing.}

We now relax item 5 of Definition \ref{def:pre-sc} so that only some program
order is {preserved} in the pomset, arriving at the final definition of
the prefix operator: % and our last failed candidate semantics.
\begin{definition}
  \label{def:prefix}
Two actions \emph{conflict} if one writes a location and the other
either reads or writes the same location.

Let $(\aForm \mid \aAct) \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ when
there is $\aPS\in\aPSS$ that satisfies the items 1-4 of
Definition \ref{def:pre-sc} and:
\begin{enumerate}
\item[5a.] if %$\bEv$ \externally reads and
  $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and $\aEv$ writes, then
  $\bEv\lt'\aEv$,
\item[5b.] if $\bEv$ and $\aEv$ are \external actions in conflict,
    then $\bEv\lt'\aEv$, %$\bEv \gtN' \aEv$,
\item[5c.] if $\bEv$ is an acquire or $\aEv$ is a release, then $\bEv \lt' \aEv$, 
\item[5d.] if $\bEv$ is an SC write and $\aEv$ is an SC read, then $\bEv \lt' \aEv$, and
\item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
  is location independent.
\end{enumerate}
\end{definition}
\vspace{-2ex}
\begin{candidate}\ \vspace{-1ex}
    \begin{align*}
    % \tag{$\dagger$}\label{sc-read}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd} [\aLoc/\aReg] 
    \\
    % \tag{$\ddagger$}\label{sc-write}
    \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
    \textstyle\PAR_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \mathhl{\prefix}\; \sem{\aCmd}\mkern3.5mu\mathhl{[\aExp/\aLoc]}
  \end{align*}
\end{candidate}
% \end{definition}
% \begin{candidate}
%   Replace $\prefixsc$ in Candidate~\ref{def:rw:sc1} by $\prefix$.
% \end{candidate}
Item 5a captures \emph{read to write} dependency\footnote{When $\bEv$ is not a read,
  4c trivially implies 5a.}; it only requires order when the precondition of
the write is weakened by prefixing.  Item 5b captures the coherence
requirement on actions that touch the same location.  Item 5c imposes the
order required by acquire and release actions.  Item 5d imposes the
additional order required by SC actions\footnote{Recall that SC reads are
  acquires and SC writes are releases.}.  (We explain item 6 in the next subsection.)

Item 5c ensures access ensure correct publication.  For
example, the following candidate execution is disallowed.
\begin{gather*}
    x\GETS0\SEMI %y\GETS0\SEMI
    x\GETS 1\SEMI y \REL\GETS1 \PAR r\GETS y\ACQ; s\GETS x
    \\[-1ex]
    \hbox{\begin{tikzinline}[node distance=1em]
        \event{wx0}{\DW{x}{0}}{}
        \event{wx1}{\DW{x}{1}}{right=of wx0}
        \event{wy1}{\DWRel{y}{1}}{right=of wx1}
        \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
        \event{rx0}{\DR{x}{0}}{right=of ry1}
        \po{wx1}{wy1}
        \po{ry1}{rx0}
        \rf{wy1}{ry1}
        \rf[out=10,in=170]{wx0}{rx0}
        \wk{wx0}{wx1}
      \end{tikzinline}}
\end{gather*}
Since $(\DW x0) \gtN (\DW x1) \lt (\DR x0)$, this pomset does not satisfy the
requirements to fulfill the read.

%This example is also disallowed if we use $\modeSC$ rather than $\modeRA$.
Items 5d ensures that program order between SC operations is always
preserved.  Combined with the requirements for fulfillment, this is
sufficient to establish that programs with only SC access have only SC
executions; for example, execution \eqref{SB} is banned when all accesses are
$\modeSC$.  It is also immediate that SC actions can be totally ordered.
Just as SC access is simplified by \mca\ in \armeight, it is simplified by
the use of a single partial order in our model.
% \begin{gather*}
%   x\GETS0\SEMI x\GETS1\SEMI\aReg\GETS y
%   \PAR
%   y\GETS0\SEMI y\GETS1\SEMI \aReg\GETS x
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wy0}{\DW{y}{0}}{below=of wx0}
%       \event{wx}{\DW{x}{1}}{right=of wx0}
%       \event{wy}{\DW{y}{1}}{right=of wy0}
%       \event{ry}{\DR{y}{0}}{right=of wx}
%       \event{rx}{\DR{x}{0}}{right=of wy}
%       \wk{wx0}{wx}
%       \wk{wy0}{wy}
%       \po{wy}{rx}
%       \po{wx}{ry}
%       \rf{wy0}{ry}
%       \rf{wx0}{rx}
%       \wk{ry}{wy}
%       \wk{rx}{wx}
%       % \po{rx}{wy}
%     \end{tikzinline}}
% \end{gather*}

We relax program order on non-SC accesses in order to allow the outcome
of executions such as \eqref{SB}.
Order is relaxed between reads, between writes to different
locations, and from a read to an independent write:
\begin{gather*}
  \aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
    \end{tikzinline}}
\end{gather*}
Let $\aCmd$ be the program above.  The existence of this pomset is justified
by the triple
$\hoare{\TRUE}{\aCmd}{y=1}$.

Unordered actions can be scheduled freely.

% Program order is only imposed from read to write when the precondition of
% the write is weakened.  Thus we have:
% \begin{displaymath}
%   \aReg\GETS x\SEMI \IF{\aReg}\THEN y\GETS1 \ELSE y\GETS1\FI
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{wy1}{\DW{y}{1}}{}
%   \event{rx1}{\DR{x}{1}}{left=of wy1}
% \end{tikzdisplay}
% Since no order is imposed, the two actions can be reordered.
% Let $\aCmd$ be the program above.  The existence of this pomset is justified
% by the triple
% $\hoare{\TRUE}{\aCmd}{y=1}$.

Item 5a imposes order from read to write when weakening the
precondition of the write via 4b, as on the left hand side of
\eqref{ex-2}.
% \begin{gather*}
%   r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
%   \\
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wy1}{1\geq0\mid\DW{y}{1}}{}
%       \event{rx1}{\DR{x}{1}}{left=of wy1}
%       \po{rx1}{wy1}
%     \end{tikzinline}}
% \end{gather*}
Item 4b \emph{allows} a precondition to weaken, but does not \emph{require} it.
Item 5a only requires order when the precondition weakens.
Thus, no order is required in the following execution:
\begin{gather*}
  r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{x\geq0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather*}
Let $\aCmd$ be the program above.  The existence of this pomset is justified
by the triple $\hoare{x=1}{\aCmd}{y=1}$, rather than by the value of the read
action.  Nonetheless, item 4b requires that the value of the read action must
be compatible with subsequent formulae.  In this example, the write
precondition must be unsatisfiable if a negative number is read:
\begin{gather}
  \ref{ex555}
  r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \nonevent{wy1}{{-2}\geq0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{{-2}}}{left=of wy1}
      % \po{rx1}{wy1}
    \end{tikzinline}}
\end{gather}

The substitution in the semantics of write allows
preconditions to be satisfied without imposing order:
\begin{gather*}
  x \GETS 0\SEMI r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wy1}{0\geq0\mid\DW{y}{1}}{}
      \event{rx1}{\DR{x}{1}}{left=of wy1}
      \event{wx0}{\DW{x}{0}}{left=of rx1}
      \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gather*}
In the JMM test cases \citep{PughWebsite}, such executions are justified via
compiler analysis, possibly in collusion with the scheduler:  If every racing
value read by a thread can be shown to satisfy a precondition, then the
precondition can be dropped.  For example, TC1 determines that the
following top-level execution should be allowed, as it is in our model:
\begin{gather*}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y)
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 1em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
    \end{tikzinline}}
\end{gather*}
Unlike \cite{DBLP:conf/lics/JeffreyR16}, this semantics is robust
with respect to the introduction of concurrent writes, as in TC9:
\begin{gather*}
  x\GETS 0 \SEMI
  (r\GETS x\SEMI\IF{r\geq0}\THEN y\GETS1 \FI
  \PAR
  x\GETS y
  \PAR
  x\GETS {-2})
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wy1}{0\geq0\mid\DW{y}{1}}{}
  \event{rx1}{\DR{x}{1}}{left=of wy1}
  \event{wx0}{\DW{x}{0}}{below left=-.2em and 1em of rx1}
  \event{ry1}{\DR{y}{1}}{below=of rx1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wx2}{\DW{x}{{-2}}}{below right=-.2em and 1em of wy1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=10,in=155]{wx0}{wx1}
  \wk{wx0}{rx1}
  \wk{wx1}{wx2}
    \end{tikzinline}}
\end{gather*}


\paragraph{Local reads and writes.}
In the semantics thus far, we have supposed that every read must be fulfilled
by a matching write action, and that the order between them must therefore be
part of the global pomset order.  This is overly restrictive for reads that
are fulfilled locally.  Consider Example 3.6 from
\citet{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  %\tag{$\dagger$}
  %\label{exlocal3.6}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\SEMI
  \bReg\GETS y\SEMI
  z\GETS \bReg
  %z\GETS y
  \PAR
  x\GETS z
  \\
  \nonumber
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DWRel{y}{1}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DR{y}{1}}{right=of a2}
  \event{a4}{\DW{z}{1}}{right=of a3}
  \rf{a2}{a3}
  \po{a3}{a4}
  \event{b1}{\DR{z}{1}}{below=of a3}
  \event{b2}{\DW{x}{1}}{left=of b1}
  %\po[out=10,in=170]{a2}{a4}
  \po{b1}{b2}
  \rf{a4}{b1}
  \rf{b2}{a1}
    \end{tikzinline}}
\end{gather*}
This behavior is allowed by \armeight, but disallowed in the model presented
thus far, due to the evident cycle.

To allow this outcome, we remove the requirement for an explicit read action
when a read is matched by a local write---and, symmetrically, for an explicit
write action when a write is only used to match local reads.  We treat
relaxed access in this section, extending to $\modeRA$/$\modeSC$-access after
introducing fences in \textsection\ref{sec:variants}.
We first give the semantics of read.
\begin{definition} \ \vspace{-1ex}
  \label{def:rw:local}
  \begin{align*}
    \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
    \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
    \\[-.5ex] &
    % \mkern2mu\cup
    \;\mathhl{\cup\;
      % (\iDRmode{\aLoc}{}) \prefix
      \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
      \sem{\aCmd}[\aLoc/\aReg]
      % \text{ else $\emptyset$}
    }
  \end{align*}
\end{definition}

Revisiting the example, %\eqref{exlocal3.6},
note that $\sem{z\GETS \bReg}$ includes $(\bReg{=}1\mid \DW{z}{1})$.
Therefore, applying the local read rule,
% of Definition~\ref{def:rw:local},
$\sem{\bReg\GETS y \SEMI z\GETS \bReg}$ includes $(y{=}1\mid \DW{z}{1})$.
Crucially, there is no explicit read event.  Further prepending
$(\DWRel{y}{1})$ results in $(1{=}1\mid \DW{z}{1})$.
% performs the substitution $(y=1\mid \DW{z}{1})[1/y]$ resulting in a
% tautology.
By removing the read event, the outcome is
allowed by our semantics, enabling efficient compilation to \armeight:
\begin{gather*}
  % \aReg\GETS x\SEMI
  % y\REL\GETS 1\SEMI
  % z\GETS y
  % \PAR
  % x\GETS z
  % \\
  \hbox{\begin{tikzinline}[node distance=.5em and 1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DWRel{y}{1}}{right=of a1}
  \po{a1}{a2}
  \internal{a3}{\DR{y}{1}}{right=of a2}
  \event{a4}{\DW{z}{1}}{right=of a3}
  %\rf{a2}{a3}
  \graypo{a3}{a4}
  \event{b1}{\DR{z}{1}}{below=of a3}
  \event{b2}{\DW{x}{1}}{left=of b1}
  %\po[out=10,in=170]{a2}{a4}
  \po{b1}{b2}
  \rf{a4}{b1}
  \rf{b2}{a1}
    \end{tikzinline}}
\end{gather*}
In drawings, we include a ``non-event''---dashed border---to mark each use of
a local rule.  

Local reads invalidate \emph{thread inlining}, which is invalid in most relaxed models.
To see this, consider that the execution above is impossible for 
\begin{math}
  \aReg\GETS x\SEMI
  y\REL\GETS 1\PAR
  \bReg\GETS y\SEMI
  z\GETS \bReg
  \PAR
  x\GETS z.
\end{math}

As in \eqref{ex555}, Item 4b (Definition \ref{def:pre-sc}) ensures that
intervening writes are not ignored:
\begin{math}
  x\GETS 0\SEMI x\GETS 1\SEMI y\GETS x
\end{math}
cannot write 0.
% NEED TO MAKE THIS POINT:
% So consider the single threaded program

% x=4; x=5; y=x;

% Clearly, this should not be able to give us Wy1.
% Here is why that is not possible:

% [[ y=1 ]] contains (Wy1)

% [[ if(r==4){y=1} ]] contains (r==4|Wy1)

% [[ r=x; if(r==4){y=1} ]] contains (Rx5)  (x==4|Wy1) // with no order

% [[ x=5; r=x; if(r==4){y=1} ]] contains (Wx5)-->(Rx5)  (5==4|Wy1) // 5 is forced.


% Consider the program variant:

% x=0; r=x; if(r<2){y=1} || x=5

% [[ y=1 ]] contains (Wy1)

% [[ if(r<2){y=1} ]] contains (r<2|Wy1)

% [[ r=x; if(r<2){y=1} ]] contains (Rx5)  (x<2|Wy1)  //with no order

% [[ x=0; r=x; if(r<2){y=1} ]] contains (Wx0)  (Rx5)  (x<2|Wy1) //does not work, since violates (6a) 𝜆Φ′(𝑒) implies 𝜆Φ(𝑒)[𝑣/𝑥].


% 6. if 𝑎 externally reads 𝑣 from 𝑥 then both 
% (6a) 𝜆Φ′(𝑒) implies 𝜆Φ(𝑒)[𝑣/𝑥], and 
% (6b) if 𝑒 is a write then either 𝑐 <′ 𝑒 or 𝜆Φ′(𝑒) implies 𝜆Φ(𝑒)





\begin{definition}
  Let $(\relfilt{\aLoc} \aPSS)$ be the subset of $\aPSS$ such that
  $\aPS\in\aPSS$
  when for every release $\aEv$ that does not write $\aLoc$, there is some $\bEv\le\aEv$
  such that $\bEv$ \externally  writes $\aLoc$.  % For $\amode\neq\modeRLX$, let
  % $(\relfilt {\aLoc} \aPSS)$ be the empty set.
  \begin{align*}
    \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
    \textstyle\PAR_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
    \\[-.5ex] &
    %\mkern2mu\cup
    \;\mathhl{\cup\;
      % (\iDWmode{\aLoc}{}) \prefix
      \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
      (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
      % \text{ else $\emptyset$}
    }
  \end{align*}
\end{definition}

The use of \textsf{cover} in Definition~\ref{def:rw:local} prevents the local
write rule from applying immediately before a release.  This prevents bad
executions such as:
\begin{gather*}
  x\GETS 1\SEMI
  x\GETS 2\SEMI
  y\REL\GETS 1
  \PAR
  \aReg\GETS y\ACQ \SEMI \bReg\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \internal{a2}{\DW{x}{2}}{right=of a1}
  \graywk{a1}{a2}
  \event{a3}{\DWRel{y}{1}}{right=of a2}
  \graypo{a2}{a3}
  \event{b1}{\DRAcq{y}{1}}{right=of a3}
  \rf{a3}{b1}
  \event{b2}{\DR{x}{1}}{right=of b1}
  \po{b1}{b2}
  \rf[out=10,in=170]{a1}{b2}
    \end{tikzinline}}
\end{gather*}
Symmetrically, item 6 of Definition \ref{def:prefix} ensures that local reads
are not matched to local writes that could be blocked by another thread.
This prevents bad executions such as:
\begin{gather*}
  x\GETS1 \SEMI
  a\REL\GETS1 \SEMI
  \IF{b\ACQ}\THEN  y\GETS x \FI
  \PAR
  \IF{a\ACQ}\THEN  x\GETS 2\SEMI b\REL\GETS1 \FI
  \\
  \hbox{\begin{tikzinline}[node distance=.8em and 1em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{a}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b3}{\DRAcq{a}{1}}{below=of a2}
  \rf{a2}{b3}
  \event{b4}{\DW{x}{2}}{right=of b3}
  \po{b3}{b4}
  \event{b5}{\DWRel{b}{1}}{right=of b4}
  \po{b4}{b5}
  \event{a6}{\DRAcq{b}{1}}{above=of b5}
  \rf{b5}{a6}
  \internal{a7}{\DR{x}{1}}{right=of a6}
  \graypo{a6}{a7}
  \event{a8}{\DW{y}{1}}{right=of a7}
  \graypo{a7}{a8}
  \po[out=10,in=170]{a6}{a8}
    \end{tikzinline}}
\end{gather*}
% In item~\ref{pre-acquire}, we do not require that $\bForm'$ is independent of
% every $\bLoc$; were we to require this, the definition would not be augment closed.







% \paragraph{Par-closure and Case Analysis.}
% Par closure.
% \begin{definition}
%   \label{def-par-closed}
%   $\aPSS$ is \emph{par-closed} if $\aPS^i\!\in\aPSS$ implies $\aPS^1\!{\PAR}\aPS^2\!\in\aPSS$\!\!.
% \end{definition}

% \begin{definition}
%   Let $\aPS'\in\sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd}$ if
%   \begin{math}
%     \aPS'= %(\iDRmode{\aLoc}{}) \prefix
%     \sem{\aCmd}[\aLoc/\aReg]
%   \end{math}
%   or
%   \begin{math}
%     \aPS'=\PAR_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%   \end{math}
%   where $\aPS\in\sem{\aCmd}[\aLoc/\aReg]$ and $\aForm_k$ are
%   disjoint\footnote{For $i$, $j$ in $K$: if $\aForm_i \land \aForm_j$ is
%     satisfiable then $i=j$.}.
% \begin{align*}
%     \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
%     \textstyle\bigcup_K\; \PAR_{k\in K}(\aForm_k \mid \DRmode\aLoc{\aVal_k}) \prefix \aPS_k
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDRmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     \sem{\aCmd}[\aLoc/\aReg]
%     %\text{ else $\emptyset$}
%     \\
%     \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & \eqdef
%     \PAR_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
%     \\[-.5ex] & \mkern2mu\cup
%     %(\iDWmode{\aLoc}{}) \prefix
%     \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%     (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
%     %\text{ else $\emptyset$}
% \end{align*}
% \end{definition}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
