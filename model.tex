\begin{comment}
https://preshing.com/20131125/acquire-and-release-fences-dont-work-the-way-youd-expect/

Cannot encode R/A actions with actions+fences...

A release operation prevents preceding memory operations from being delayed
past it (a;Rel =/=> Rel;a)
 
A release fence prevents preceding memory operations from being delayed past
subsequent writes (a;FR;w =/=> w;a;FR)

An acquire operation prevents subsequent memory operations from being advanced
before it (Acq;a =/=> a;Acq)

An acquire fence prevents subsequent memory operations from being advanced
before prior reads (r;FA;a =/=> FA;a;r)

https://www.modernescpp.com/index.php/fences-as-memory-barriers

StoreLoad: Full fence allows a store before to be reordered with respect to a
load after (wx;F;ry) ===> (ry;F;wx)

StoreLoad+LoadLoad: Release fence also allows (rx;FR;ry) ===> (ry;FR;rx)

StoreLoad+StoreStore: Acquire fence also allows (wx;FR;wy) ===> (wy;FR;wx)

LoadStore: No fence allows a prior load to reorder w.r.t. a subsequent store
(rx;FR;wy) =/=> (wy;FR;rx)

https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/
Good news is that a fullFence does it.

Bizarrely, it seems this is not supported in C++... You have to go to assembly.
\end{comment}

\section{Model}
\label{sec:model}

\subsection{3-valued pomsets}
\label{sec:pomsets}

Structures similar to 3-valued pomsets have come up in many guises, for example
rough sets~\cite{Pawlak1982} or ultrametrics over
$\{0,{}^1\!/_2,1\}$. They correspond to axioms A1--A3 of Lamport's
\emph{system executions}~\cite{DBLP:journals/dc/Lamport86}.
They are the notion of pomset given by interpreting
$\bEv\le\aEv$ in a 3-valued logic~\cite{Urquhart1986}. 


\begin{definition}
  A \emph{3-valued pomset} with alphabet $\Alphabet$ is tuple $(\Event,
  {\le}, {\gtN}, \labeling)$, such that 
  \begin{itemize}
  \item $\Event$ is a set of \emph{states},
  %\item $\ESub\subseteq\Event$ is a set of \emph{accepting states}, 
  \item $\labeling: \Event \fun \Alphabet$ is a \emph{labeling},
  \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
    % \begin{enumerate}
    % \item $\aEv \le \aEv$,
    % \item if $\bEv \le \aEv$ and $\aEv \le \bEv$ then $\bEv = \aEv$,
    %   \\(this follows from 5a and 5b)
    % \item if $\cEv \le \bEv \le \aEv$ then $\cEv \le \aEv$, and
    % \end{enumerate}
  \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
    \begin{itemize}
    \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$,
    \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then $\bEv = \aEv$,
    \item if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$ then $\cEv \gtN \aEv$.
    \end{itemize}
\end{itemize}
\end{definition}
Note that $\gtN$ is reflexive.


We visualize a pomset as a graph where the nodes are drawn from $\Event$,
each node $\aEv$ is labeled with $\labeling(\aEv)$, and an edge
$\bEv \rightarrow \aEv$ corresponds to an ordering $\bEv\le\aEv$.  We
visualize $(\bEv \gtN \aEv)$ as a dashed arrow from $\bEv$ to $\aEv$.  For
example:
\begin{tikzdisplay}[node distance=1em]
  \event{rx1}{a}{}
  \event{wy0}{b}{below right=of rx1}
  \event{wy1}{c}{above right=of wy0}
  \po{rx1}{wy0}
  \po{rx1}{wy1}
  \wk{wy0}{wy1}
\end{tikzdisplay}
is a visualization of the pomset where:
\[\begin{array}{c}
    E = \{ 0,1,2 \}
    \quad
    {\labeling} = \{(0,a),\,(1,b),\,(2,c)\}
    \\
    {\le} = \{(0,1),\,(0,2)\}\cup\{(0,0),\,(1,1),\,(2,2)\}
    \quad
    {\gtN} = {\le}\cup\{(2,3)\}
\end{array}\]
We refer to edges introduced by $(\bEv \leq \aEv)$ as
\emph{strong edges} and by $(\bEv \gtN \aEv)$
as \emph{weak edges}.


\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{memory locations} $\Loc$, ranged over by $\aLoc$ and
  $\bLoc$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$.
\end{itemize}

Let $\aSub$ range over substitutions of the form
$\aForm[\aLoc/\aReg]$ or $\aForm[\bExp/\aLoc]$.

We require that data models satisfy the following:
\begin{itemize}
\item the sets of values, registers and memory locations are disjoint,
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations or the operator $\REF{\aExp}$,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form
  $(\aExp=\aVal)$ and $(\REF{\aExp}=\aLoc)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitution\footnote{Since formulae are closed under substitutions of the
    form $\aForm[\aLoc/\aReg]$, they must include equalities of the form
    $(\aEExp=\aVal)$ and $(\REF{\aEExp}=\aLoc)$, where $\aEExp$ is an
    \emph{extended expression} that includes memory locations.  We elide the
    details.  By composition of the closure conditions, formulae must also be
    closed under that substitutions of the form
    $\aForm[\aExp/\aReg]=\aForm[\aLoc/\aReg][\aExp/\aLoc]$.}, and
\item there is a relation $\vDash$ between formulae.
\end{itemize}

We say that $\aForm$ is \emph{independent of $\aLoc$} whenever
$\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$, and that
$\aForm$ is \emph{dependent on $\aLoc$} otherwise.  We say that $\aForm$
\emph{implies} $\bForm$ whenever $\aForm\vDash\bForm$, that $\aForm$ is a
\emph{tautology} whenever $\TRUE\vDash\aForm$, that $\aForm$ is
\emph{unsatisfiable} whenever $\aForm\vDash\FALSE$.

For the actions of a data model, we require that
\begin{itemize}
\item there are partial functions $\rreads$ and
  $\rwrites: \Act \fun (\Loc \times \Val)$,
\item there are sets $\Rel$ and $\Acq \subseteq\Act$, and
\item there is a function $\finternalize: (\Loc\times\Act) \fun \Act$ that
  satisfies the restrictions given below.
\end{itemize}

We say that $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$\rreads(\aAct) = (\aLoc,\aVal)$, and that $\aAct$ \emph{writes} $\aVal$
\emph{to} $\aLoc$ whenever $\rwrites(\aAct) = (\aLoc,\aVal)$.  Two actions
\emph{conflict} if at least one action writes a location and the other either
reads or writes the same location.  Actions that read or write are
\emph{external}, other actions are \emph{internal}.
% Actions in
% $\Ext=\fdom(\rreads)\cup\fdom(\rwrites)$ are \emph{external}, whereas those
% in $\Int=\Act\setminus\Ext$ are \emph{internal}.

We say that $\aAct$ is an \emph{acquire} if $\aAct\in\Acq$, and that $\aAct$
is a \emph{release} if $\aAct\in\Rel$.  Actions that acquire or release are
\emph{synchronizations}, other actions are \emph{relaxed}.
% We say that $\aAct$ is a
% \emph{synchronization} if it is either a release or an acquire.

We require that $\finternalize$ satisfy the following:
\begin{itemize}
\item the codomain of $\finternalize$ includes only internal actions, %$\fcodom(\finternalize)\subseteq\Int$,
\item $\finternalize(\aAct)$ is an acquire exactly when $\aAct$ is an acquire, and 
\item $\finternalize(\aAct)$ is a release exactly when $\aAct$ is a release.
\end{itemize}


In examples, we use actions of the form $(\DR{\aLoc}{\aVal})$, which reads
$\aVal$ from $\aLoc$, and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to
$\aLoc$, $(\DRAcq{\aLoc}{\aVal})$, which is an acquire that reads $\aVal$
from $\aLoc$, $(\DWRel{\aLoc}{\aVal})$, which is a release that writes
$\aVal$ to $\aLoc$, and $(\DF{})$, which is internal and both an acquire and
a release.  For each external action, we also define a corresponding internal
action which replaces the letter $\mathsf{R}$ or $\mathsf{W}$ with $\tau$.
For example, $(\iDRAcq{\aLoc}{\aVal})$ is an acquiring internal action, which
neither reads nor writes. In pictures, we draw internal actions grayed out,
rather than using $\tau$.  For example, the ``read'' action is internal in:
\begin{tikzdisplay}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \internal{rx1}{\DR{x}{1}}{below right=of rx1}
  \event{wy1}{\DW{y}{1}}{above right=of wy0}
  \po{wx1}{wy1}
\end{tikzdisplay}


% In examples, we use fence actions of the form $(\DF{\aF})$, where the annotation
% indicates that the fence is a release ($\FR$), an acquire ($\FA$) or both ($\FF$):
% \begin{displaymath}
%   \aF\BNFDEF\FR\BNFSEP\FA\BNFSEP\FF
% \end{displaymath}

\subsection{3-valued pomsets with preconditions}

Fix an alphabet $\Alphabet=(\Formulae\times\Act)$.
Define %$\labelingForm$ and $\labelingAct$ so that
$\labelingForm(\aEv)=\aForm$ and $\labelingAct(\aEv)=\aAct$ whenever
$\labelingForm(\aEv)=(\aForm\mid\aAct)$.

We write pairs in $(\Formulae\times\Act)$ as $(\aForm \mid \aAct)$.  We elide
$\aForm$ when it is a tautology.

We lift terminology from logical formulae and actions to events. For example,
we say that $\aEv$ is unsatisfiable when $\labelingForm(\aEv)$ is unsatisfiable,
and that $\aEv$ is an acquire when $\labelingAct(\aEv)$ is an acquire.


In this paper, we are not investigating speculative execution.  So we make
the global assumption formulae can only get stronger in dependent actions:

\begin{definition}
  A \emph{3-valued pomset with preconditions} is a 3-valued pomset such
  that $\labelingForm(\aEv)$ implies $\labelingForm(\bEv)$ whenever
  $\bEv\le\aEv$.
\end{definition}

In the remainder of the paper, we refer to 3-valued pomsets with
preconditions simply as \emph{pomsets}.

We give the semantics of programs as sets of pomsets.  Each pomset
$\aPS\in\sem{\aCmd}$ will represent a single execution of $\aCmd$.  We do not
expect $\sem{\aCmd}$ to be prefixed closed; thus, one may view each
$\aPS\in\sem{\aCmd}$ as a \emph{completed} execution\footnote{NOTE: because
  implication closed, any event can go false, and we kill everything after
  it, so that means we do get a kind of prefix closure.}.  However, we do
expect the sets of pomsets given by the semantics to be closed with respect
to \emph{isomorphism}, \emph{augmentation} and \emph{implication}.
\begin{definition}
  $\aPS'$ is an \emph{isomorphism} of $\aPS$ if there is a bijection
  $f:\Event\fun\Event'$ such that $\labeling(\aEv)=\labeling'(f(\aEv))$,
  $\aEv\le\bEv$ iff $f(\aEv)\le'f(\bEv)$, and $\aEv\gtN\bEv$ iff
  $f(\aEv)\gtN'f(\bEv)$.

  $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$,
  ${\labeling'}={\labeling}$, ${\le'}\supseteq{\le}$, and
  ${\gtN'}\supseteq{\gtN}$.

  $\aPS'$ \emph{implies} $\aPS$ if $\Event'=\Event$, ${\le'}={\le}$,
  ${\gtN'}={\gtN}$, $\labelingAct'=\labelingAct$, and $\labelingForm'(\aEv)$
  implies $\labelingForm(\aEv)$ for all $\aEv\in\Event$.
\end{definition}
% \begin{definition}
%   $\aPS'$ is an \emph{augmentation} of $\aPS$ if $\Event'=\Event$, ${\labeling'}={\labeling}$,
%   ${\le}\subseteq{\le'}$, %$\aEv\le\bEv$ implies $\aEv\le'\bEv$,
%   and ${\gtN}\subseteq{\gtN'}$. %$\aEv\gtN\bEv$ implies $\aEv\gtN'\bEv$,
%   % $\labelingAct'=\labelingAct$, and  $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.
%   % if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) = (\bForm' \mid \bAct)$ where $\bForm'$ implies $\bForm$.
% \end{definition}


% Restriction also filters a set of pomsets; we have
% $(\nu\aLoc\st\aPSS)\subseteq\aPSS$.
% The definition requires that we define
% when a read is possible.

% \begin{definition}\label{def:rf}
%   In a pomset, $\aEv$ \emph{can read $\aLoc$ from} $\bEv$ whenever: 
%   \begin{itemize}
%   \item $\bEv \lt \aEv$,  
%   \item $\aEv$ implies $\bEv$,
%   \item $\bEv$ writes $\aVal$ to $\aLoc$,
%     and $\aEv$ reads $\aVal$ from $\aLoc$, and
%   \item if $\cEv$ writes to $\aLoc$
%     then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
%   \end{itemize}
% \end{definition}

At top-level, we expect the use of each variable to be \emph{closed} and \emph{coherent}.

\begin{definition}
\label{def:x-closed}
  A pomset is \emph{$\aLoc$-closed} if, for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads $\aVal$ from $\aLoc$, then there is some $\bEv$ such that
    % $\aEv$ can read $\aLoc$ from $\bEv$.
  \begin{itemize}
  \item $\bEv \lt \aEv$,  
  %\item $\aEv$ implies $\bEv$,
  \item $\bEv$ writes $\aVal$ to $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}    
  % \item if $\aEv$ writes $\aLoc$, then either $\aEv$ is a synchronization or there is
  %   some $\bEv$ such that $\bEv$ can read $\aLoc$ from $\aEv$.
  \end{itemize}

  A pomset is $\aLoc$-\emph{coherent} if, when restricted to events that read
  or write $\aLoc$, $\gtN$ forms a partial order.

  A pomset is \emph{top-level} if it is $\aLoc$-closed and $\aLoc$-coherent,
  for every $\aLoc$.
\end{definition}
% Our model of reads-from is strong, and could be weakened by replacing the
% requirement $\bEv\lt\aEv$ % in Definition~\ref{def:rf}
% by $\bEv\gtN\aEv$. It remains to be seen how this impacts the model.


For readability, we often highlight the reads-from edges as well.
% for example:
For example:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=2.5 em of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \wk{rx1}{wx2}
\end{tikzdisplay}


Need to forbid cycles in $\gtN$ per location:
\[
  \IF{x\EQ1}\THEN r\GETS x \FI
  \PAR
  x\GETS 1
  \PAR
  x\GETS2
  \PAR
  \IF{x\EQ2}\THEN s\GETS x \FI
\]
which includes the execution:
\begin{tikzdisplay}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{below=of wx1}
  \event{rx1a}{\DR{x}{1}}{left=of wx1}
  \event{rx2a}{\DR{x}{2}}{left=of wx2}
  \event{rx1b}{\DR{x}{1}}{right=of wx1}
  \event{rx2b}{\DR{x}{2}}{right=of wx2}
  \po{rx1a}{rx2a}
  \po{rx2b}{rx1b}
  \rf{wx1}{rx1a}
  \rf{wx1}{rx1b}
  \rf{wx2}{rx2a}
  \rf{wx2}{rx2b}
  \wk{rx1a}{wx2}
  \wk{rx2a}{wx1}
  \wk{rx1b}{wx2}
  \wk{rx2b}{wx1}
\end{tikzdisplay}
This satisfies the requirements for $x$-closure, but is not coherent.

With the restrictions in $x$-closure, is forbidding cycles forces an order
between any writes that are read from:
\[
  x\GETS 3
  \PAR
  \IF{x\EQ1}\THEN r\GETS x \FI
  \PAR
  x\GETS 1
  \PAR
  x\GETS2
\]
\begin{tikzdisplay}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{below=of wx1}
  \event{rx1a}{\DR{x}{1}}{left=of wx1}
  \event{rx2a}{\DR{x}{2}}{left=of wx2}
  \po{rx1a}{rx2a}
  \rf{wx1}{rx1a}
  \rf{wx2}{rx2a}
  \wk{rx1a}{wx2}
  \wk{wx1}{wx2}
  \event{wx3}{\DW{x}{3}}{below left=-.2em and 1em of rx1a}
  \wk{rx1a}{wx3}
  \wk{rx2a}{wx3}
\end{tikzdisplay}


Across variables, however, cycles in $\gtN$ arise naturally in non-multicopy
atomic examples, such as IRIW.
\[\begin{array}{rl}
  &x\GETS0\SEMI x\GETS 1
  \PAR
  \IF{x}\THEN r\GETS y \FI
 \\{}
  \PAR&
  y\GETS0\SEMI y\GETS 1
  \PAR
  \IF{y}\THEN s\GETS x \FI
\end{array}\]
which includes the execution:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=4ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
\end{tikzdisplay}

\subsection{Combinators}

We give the semantics using combinators over sets of pomsets, defined below.
Using $\aPSS$ to range over sets of pomsets, these are:
\begin{itemize}
\item \emph{substitution} $\aPSS\aSub$, which applies the substitution to
  every precondition,
\item \emph{restriction} $\nu\aLoc\st\aPSS$, which internalizes $\aLoc$ for
  pomsets that are $\aLoc$-closed and $\aLoc$-coherent,
\item \emph{guarding} $\aForm\guard\aPSS$, which filters $\aPSS$,
  keeping pomsets where all events imply $\aForm$,
\item \emph{composition} $\aPSS^1\parallel\aPSS^2$, which unions pomsets, allowing events to be merged, and
\item \emph{prefixing} $\aAct\prefix\aPSS$, which adds an event with action
  $\aAct$ to pomsets in $\aPSS$, ordering $\aAct$ before any $\aEv$ whose predicate
  depends on the value read by $\aAct$.
\end{itemize}
These operations are similar to those from models of concurrency such
as~\cite{Brookes:1984:TCS:828.833}, but adapted here to the setting of
speculative evaluation.

%% A write generates a write event that may be visible
%% to other threads.  A read may see a
%% thread-local value, or it may generate a read event that must be justified by
%% another thread.  In the latter case, occurrences of $\aReg$ are replaced with
%% $\aLoc$ (rather than $\aVal$) to ensure that dependencies are tracked
%% properly.  The subsequent substitution of $\aVal$ for $\aLoc$ occurs in
%% Definition~\ref{def:prefix} of prefixing.

% We have completed the formal definition of our model of speculative
% evaluation, and now turn to examples.

%\subsubsection{Substitution and Guarding} 

% Substitution updates the preconditions in a pomset, thus we expect the number
% of pomsets to be unchanged; in addition, the number of events in each of the
% pomsets is unchanged.

% Guarding and restriction filter a set of pomsets; we have
% $(\aForm\guard\aPSS)\subseteq\aPSS$ and
% $(\nu\aLoc\st\aPSS)\subseteq\aPSS$.

The definitions of substitution, restriction and guarding are
straightforward\footnote{We have chosen the definition of restriction for its
  simplicity.  It is worth noting, however, that our definition does not
  support renaming of variables.  In particular
  $(\nu\aLoc\st\aPSS\parallel(\nu\aLoc\st\bPSS))$ is generally not the same
  as $(\nu\aLoc\st\aPSS\parallel(\nu\bLoc\st\bPSS[\bLoc/\aLoc]))$.  To
  support renaming, $(\nu\aLoc\st\aPSS)$ would need to either remove or
  relabel events that mention $\aLoc$.}:
\begin{definition}
  %For a substitution $\aSub$, of the form $[\aLoc/\aReg]$ or $[\bExp/\aLoc]$,
  Let $\aPSS\aSub$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
$\Event' = \Event$,
${\le'} = {\le}$, 
${\gtN'} = {\gtN}$,
and
$\labeling'(\aEv) = (\bForm\aSub \mid \aAct)$ when $\labeling(\aEv) = (\bForm \mid \aAct)$.
% \begin{itemize}
% \item if $\labeling(\aEv) = (\bForm \mid \aAct)$ then $\labeling'(\aEv) =
%   (\bForm\aSub \mid \aAct)$, and
% \item if $\labeling(\aEv) = (\bForm \mid \aSub)$ then $\labeling'(\aEv) = (\bForm\bSub \mid \aSub\bSub)$.
%\end{itemize}

  % Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
  % and $\aPS$ is $\aLoc$-coherent and $\aLoc$-closed.

  Let $(\nu\aLoc\st\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aLoc$-coherent and $\aLoc$-closed $\aPS\in\aPSS$ such that:
$\Event' = \Event$,
${\le'} = {\le}$, 
${\gtN'} = {\gtN}$,
and
$\labeling'(\aEv) = (\bForm \mid \finternalize(\aAct))$ when $\labeling(\aEv) = (\bForm \mid \aAct)$.

Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aForm$ implies $\labelingForm(\aEv)$ for every $\aEv\in\Event$. % if $\labelingAct(\aEv)$ writes.
% \begin{itemize}
% \item if $\labeling(\aEv) = (\bForm \mid \aActSub)$ then $\aForm$ implies $\bForm$.
% \end{itemize}
\end{definition}
% Note that this liberalization allows reads more flexibility.  This is
% desirable in the language and architectural models, but not necessarily in
% microarchitectural models where reads are visible.


% \subsubsection{Restriction}
% \label{sec:restriction}


% We say that $\aPS' = \aPS\restrict{\Event'}$ when 
%  $\Event' \subseteq \Event$,
%  ${\labeling'} = {\labeling}\restrict{\Event'}$, 
%  ${\le'} = {\le}\restrict{\Event'}$, and
%  ${\gtN'} = {\gtN}\restrict{\Event'}$.

% \begin{definition}
%   Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
%   and $\aPS$ is $\aLoc$-coherent and $\aLoc$-closed.
%   % Let $(\nu\aLoc\st\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$
%   % whenever there is $\aPS\in\aPSS$ such that $\aPS' = \aPS\restrict{\Event'}$
%   % and $\aPS'$ is $\aLoc$-coherent and $\aLoc$-closed.
%   % Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
%   % \begin{itemize}
%   % \item $\aEv$ is independent of $\aLoc$, and
%   % \item if $\aEv$ reads $\aLoc$, then there is some $\bEv$ such that $\aEv$ can read $\aLoc$ from $\bEv$.
%   % \end{itemize}
% \end{definition}
%This definition throws away useless writes.

%\subsubsection{Composition}
\begin{definition}
Let $\aPS' \in (\aPSS^1 \parallel \aPSS^2)$
whenever there are $\aPS^1 \in \aPSS^1$ and $\aPS^2 \in \aPSS^2$ such that:
\begin{itemize}
\item $\Event' = \Event^1 \cup \Event^2$,
\item ${\le'}\supseteq{\le^1}\cup{\le^2}$, %if $\aEv \le^1 \bEv$ or $\aEv \le^2 \bEv$ then $\aEv \le' \bEv$,
\item ${\gtN'}\supseteq{\gtN^1}\cup{\gtN^2}$, and %if $\aEv \gtN^1 \bEv$ or $\aEv \gtN^2 \bEv$ then $\aEv \gtN' \bEv$,
% \item if $\labeling'(\aEv) = (\aForm' \mid \aAct)$ then either:
%   \begin{itemize}
%   \item $\labeling^1(\aEv) = (\aForm^1 \mid \aAct)$ and $\labeling^2(\aEv) = (\aForm^2 \mid \aAct)$
%     and $\aForm'$ implies $\aForm^1 \lor \aForm^2$,
%   \item $\labeling^1(\aEv) = (\aForm^1 \mid \aAct)$ and $\aEv \not\in \Event^2$
%     and $\aForm'$ implies $\aForm^1$, or
%   \item $\labeling^2(\aEv) = (\aForm^2 \mid \aAct)$ and $\aEv \not\in \Event^1$
%     and $\aForm'$ implies $\aForm^2$.
%   \end{itemize}
\item either
  % \begin{gather*}
  %   \labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv),\\
  %   \aEv \not\in \Event^2,\; \labelingAct'(\aEv) = \labelingAct^1(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor\\    
  %   \aEv \not\in \Event^1,\; \labelingAct'(\aEv) = \labelingAct^2(\aEv) \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv).
  % \end{gather*}
  \begin{itemize}
  \item $\labelingAct'(\aEv) = \labelingAct^1(\aEv) = \labelingAct^2(\aEv)
    \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv) \lor \labelingForm^2(\aEv)$,
  \item $\labelingAct'(\aEv) = \labelingAct^1(\aEv),\;\; \aEv \not\in \Event^2\,
    \textand \labelingForm'(\aEv) \textimplies \labelingForm^1(\aEv),\; \textor$
  \item $\labelingAct'(\aEv) = \labelingAct^2(\aEv),\;\; \aEv \not\in \Event^1\,
    \textand \labelingForm'(\aEv) \textimplies \labelingForm^2(\aEv)$.
  \end{itemize}
\end{itemize}
\end{definition}
Composition is used in giving the semantics for conditionals and concurrency.
$\aPSS^1 \parallel \aPSS^2$ contains the union of pomsets from $\aPSS^1$ and
$\aPSS^2$, allowing overlap as long as they agree on actions. For example, if
$\aPSS^1$ and $\aPSS^2$ contain:
\begin{tikzdisplay}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm^1 \mid \bAct}{right=of a}
  \po{a}{b}
  \event{b2}{\bForm^2 \mid \bAct}{right=6em of b}
  \event{c2}{\cForm \mid \cAct}{right=of b2}
  \wk{b2}{c2}
\end{tikzdisplay}
then $\aPSS^1 \parallel \aPSS^2$ contains:
\begin{tikzdisplay}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{a}{b}
  \wk{b}{c}
\end{tikzdisplay}

% We use $\aPSS^1 \parallel \aPSS^2$ in defining the semantics of conditionals
% and concurrency.
% It contains the union of pomsets from $\aPSS^1$ and $\aPSS^2$,
% allowing overlap as long as they agree on actions. For example, if
% $\aPSS^1$ and $\aPSS^2$ contain:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \mid \bAct}{right=of a}
%   \po{a}{b}
% \end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
%   \event{b}{\bForm^2 \mid \bAct}{}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \wk{b}{c}
% \end{tikzdisplay}
% then $\aPSS^1 \parallel \aPSS^2$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm^1 \lor \bForm^2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \wk{b}{c}
% \end{tikzdisplay}


%\subsubsection{Prefixing}
\begin{definition}
  \label{def:prefix}
Let $\aAct \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{enumerate}
\item\label{pre-E} $\Event' = \Event \cup \{\cEv\}$,
\item\label{pre-le} ${\le'}\supseteq{\le}$, % if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item\label{pre-gtN} ${\gtN'}\supseteq{\gtN}$, %if $\aEv \gtN \bEv$ then $\aEv \gtN' \bEv$,
% \item $\labelingAct'(\cEv) = \aAct$, 
% \item if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) =
%   (\bForm' \mid \bAct)$, where:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire then $\bForm'$ is independent of every $\bLoc$,
%   \item if $\aAct$ does not read then $\bForm'$ implies $\bForm$,
%   \item if $\aAct$ reads then $\aVal$ from $\aLoc$ then
%     \begin{itemize}
%     \item $\bForm'$ implies $\bForm[\aVal/\aLoc]$, and
%     \item either $\bForm'$ implies $\bForm$ or $\cEv\lt'\aEv$, 
%     \end{itemize}
%   \end{itemize}
% \item if $\labelingAct(\aEv) = \bAct$ then:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire or $\bAct$ is a release then $\cEv \lt' \aEv$, 
%   \item if $\aAct$ and $\bAct$ both touch the same location and one is a write,
%     then $\cEv \gtN' \aEv$, and
%   \end{itemize}
\item\label{pre-act} $\labelingAct'(\cEv) = \aAct$ and $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
\item\label{pre-implies} either $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$ or
  $\aAct$ is a read and $\cEv\lt'\aEv$,
% \item if $\aAct$ does not read then $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$,
% \item if $\aAct$ reads then either $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$ or $\cEv\lt'\aEv$,  %
\item\label{pre-read} if $\aAct$ reads $\aVal$ from $\aLoc$ then
   $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$, %
\item\label{pre-coherence} if $\aAct$ conflicts with $\labelingAct(\aEv)$ 
    then $\cEv \gtN' \aEv$,
\item\label{pre-sync} if $\aAct$ is an acquire or $\labelingAct(\aEv)$ is a release then $\cEv \lt' \aEv$, and
\item\label{pre-acquire} if $\aAct$ is an acquire then $\labelingForm(\aEv)$ is independent of every $\bLoc$.
% \item if $\aAct$ is a read but not a synchronization then either
%   $\labelingForm'(\cEv)$ is unsatisfiable or there is some $\aEv$ such
%   that $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$.
% \item if $\labeling(\aEv) = (\bForm \mid \bAct)$ then $\labeling'(\aEv) =
%   (\bForm' \mid \bAct)$, where:
%   \begin{itemize}
%   \item if $\aAct$ is an acquire or $\bAct$ is a release then $\cEv \lt' \aEv$, 
%   \item if $\aAct$ is an acquire then $\bForm$ is independent of every $\bLoc$,
%   \item if $\aAct$ and $\bAct$ both touch the same location and one is a write,
%     then $\cEv \gtN' \aEv$, and
%   \item $\bForm'$ implies \(\left\{\begin{array}{l@{~}ll}
%     % \bForm[\aVal/\aLoc]                     & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv\lt'\aEv$} & \textsc{[dependent read]} \\
%     % \bForm[\aVal/\aLoc] \text{ and } \bForm & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  & \textsc{[independent read]} \\
%     % \bForm                                  & \mbox{otherwise}                                              & \textsc{[non-read]} \\        
%     \bForm[\aVal/\aLoc]                     \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv\lt'\aEv$} \\\qquad \textsc{[dependent read]} \\[\jot]
%     \bForm[\aVal/\aLoc] \text{ and } \bForm \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  \\\qquad \textsc{[independent read]} \\[\jot]
%     \bForm                                  \\\quad \mbox{otherwise}                                              \\\qquad \textsc{[non-read]} \\
%   \end{array}\right.\)
%   \end{itemize}
\end{enumerate}
\end{definition}
% The last condition ensures that useless reads are not included.
% Otherwise, $\labelingForm'(\cEv)$ is unconstrained.

% In order to keep augmentation closure, we need to keep the unsatisfiable
% elements in the set of pomsets.

$\aAct\prefix\aPSS$ adds a new event $\cEv$ with action $\aAct$ to each
pomset in $\aPSS$.  As in the definition of parallel composition, the
definition allows the new event to overlap with events in $\aPSS$ as long as
they agree on the action.  Overlapping of synchronization events is
disallowed by item~\ref{pre-sync}.

If $\cEv$ writes to a location that is also written by some $\aEv$ in $\aPSS$,
item~\ref{pre-coherence} introduces weak order between them: $\cEv \gtN \aEv$.  This
ensures that these writes cannot be given the reverse order in an augmentation.

If $\cEv$ reads from a location that occurs in the predicate of $\aEv$, then
prefixing introduces order from $\cEv$ to $\aEv$.
whose predicate depends on $\aLoc$. 
For example, if $\aPSS$ contains %a pomset with only
\begin{tikzinline}[node distance=1em]
  \event{b}{y=1 \mid \DW{x}{1}}{}
  \event{c}{x>0 \mid \DW{z}{1}}{right=of b}
\end{tikzinline}
then $(\DR{x}{1})\prefix\aPSS$ contains:
\begin{displaymath}
\begin{tikzsmall}[node distance=1em]
  \event{a}{\DR{x}{1}}{}
  \event{b}{y=1 \mid \DW{x}{1}}{above right=0em and 2em of a}
  \event{c}{1>0 \mid \DW{z}{1}}{below right=0em and 2em of a}
  \po{a}{c}
  \wk{a}{b}
\end{tikzsmall}
\qquad\text{and}\qquad
\begin{tikzsmall}[node distance=1em]
  \event{a2}{\DR{x}{1}}{right=4em of a}
  \event{b2}{y=1 \mid \DW{x}{1}}{above right=0em and 2em of a2}
  \event{c2}{x>0 \mid \DW{z}{1}}{below right=0em and 2em of a2}
  \wk{a2}{b2}
\end{tikzsmall}
\end{displaymath}
In order to weaken the predicate on $(\DW{z}{1})$, item~\ref{pre-implies}
requires that we include the order from $(\DR{x}{1})$ to $(\DW{z}{1})$.
If the precondition on $(\DW{z}{1})$ in $\aPSS$ was $x<0$, then, by
item~\ref{pre-read}, all preconditions for $(\DW{z}{1})$ in
$(\DR{x}{1})\prefix\aPSS$ must be equivalent to $\FALSE$, regardless of
the ordering of the events.

% For example, if $\aAct$ and $\bAct$ write to the same location, $\aAct$ reads
% $\aVal$ from $\aLoc$, $\bForm$ is independent of $\aLoc$, and $\aPSS$
% contains:
% $\footnotesize\begin{tikzpicture}[baselinecenter,node distance=1em]
%   \event{b}{\bForm \mid \bAct}{}
%   \event{c}{\cForm \mid \cAct}{right=of b}
% \end{tikzpicture}$
% then $\aAct\prefix\aPSS$ contains:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm \mid \bAct}{right=of a}
%   \event{c}{\cForm[\vec\aVal/\vec\aLoc] \mid \cAct}{right=of b}
%   \po[out=25,in=155]{a}{c}
%   \wk{a}{b}
%   \po{b}{c}
% \end{tikzdisplay}

% We say $\aEv$ \emph{depends on} $\cEv$ if
% $\labeling(\aEv) = (\bForm \mid \dontcare)$,
% $\labeling(\cEv) = (\dontcare \mid \aSub)$,
% and $\bForm$ depends on $\aSub$.

% We say $\aEv$ \emph{conflicts with}  $\bEv$ if
% $\labeling(\aEv) = (\dontcare \mid \aAct)$,
% $\labeling(\cEv) = (\dontcare \mid \bAct)$,
% $\aAct$ and $\bAct$ touch the same location, and either
% $\aAct$ or $\bAct$ is a write.

Item~\ref{pre-acquire} ensures that thread-local reads do
not cross acquire fences.  This prevents bad executions like the following:
\begin{verbatim}
   x=1; rel; acq; if (x) {y=1};  ||  acq; x=0; rel; 
\end{verbatim}
where the second thread is interleaved between the rel and acq of the first.
In item~\ref{pre-acquire}, we do not require that $\bForm'$ is independent of
every $\bLoc$; were we to require this, the definition would not be augment closed.

Item~\ref{pre-sync} ensures that events are ordered before a release and
after an acquire.  As an example, consider the program:
\[
  x\GETS0\SEMI f\GETS0\SEMI x\GETS 1\SEMI f \REL\GETS1 \PAR r\GETS f\ACQ; s\GETS x
\]
This has a top-level execution:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{below=of wx0}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf1}{\DWRel{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx1}{\DR{x}{1}}{above=of rf1}
  \po{wx0}{wf1}
  \po{wf0}{wf1}
  \po{wx1}{wf1}
  \po{rf1}{rx1}
  \rf{wf1}{rf1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
\end{tikzdisplay}
but \emph{not}:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{below=of wx0}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf1}{\DWRel{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{above=of rf1}
  \po{wx0}{wf1}
  \po{wf0}{wf1}
  \po{wx1}{wf1}
  \po{rf1}{rx1}
  \rf{wf1}{rf1}
  \rf[bend left]{wx0}{rx0}
  \wk{wx0}{wx1}
\end{tikzdisplay}
since $(\DW x0) \gtN (\DW x1) \lt (\DR x0)$, so this pomset does not satisfy the
requirements to be $x$-closed.
If we replace the release
with a plain write, then the outcome $(\DRAcq f1)$ and $(\DR x0)$ is possible:
\begin{tikzdisplay}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{below=of wx0}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf1}{\DW{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{above=of rf1}
  \wk{wf0}{wf1}
  \po{rf1}{rx0}
  \rf{wf1}{rf1}
  \rf[bend left]{wx0}{rx0}
  \wk{wx0}{wx1}
\end{tikzdisplay}
since no order is required between $(\DW x1)$ and $(\DW f1)$.  
Symmetrically, if we replace the acquire of the original program
with a plain read, then the outcome $(\DR f1)$ and $(\DR x0)$ is possible.

\subsection{Semantics of programs}
\label{sec:semantics}

We consider a simple shared-memory concurrent language, with statements defined as follows.
\begin{align*}
\aCmd,\,\bCmd
\BNFDEF& \SKIP
\BNFSEP \FENCE\SEMI \aCmd
\BNFSEP \REF{\bExp}\GETS\aExp\SEMI \aCmd
\BNFSEP \REF{\bExp}\REL\GETS\aExp\SEMI \aCmd
\BNFSEP \aReg\GETS\REF{\bExp}\SEMI \aCmd
\BNFSEP \aReg\GETS\REF{\bExp}\ACQ\SEMI \aCmd \\
\BNFSEP& \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\BNFSEP \aCmd \PAR \bCmd
\BNFSEP \VAR\aLoc\SEMI \aCmd
\end{align*}
We write $\VAR\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\VAR\aLoc\SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\REL\aLoc\GETS\aExp\SEMI \aCmd$ as shorthand for $\FENCE_{\FR} \SEMI\aLoc\GETS\aExp\SEMI \aCmd$.
% We write $\ACQ\aReg\GETS\aLoc\SEMI \aCmd$ as shorthand for $\aReg\GETS\aLoc\SEMI \FENCE_{\FA}\SEMI \aCmd$.
We write $\IF{\aExp} \THEN \aCmd^1 \ELSE \aCmd^2 \FI \SEMI \bCmd$ as
shorthand for $\IF{\aExp} \THEN \aCmd^1 \SEMI \bCmd\ELSE \aCmd^2 \SEMI \bCmd\FI$.

We only consider programs with top level parallelism.   We expect programs to
be of the form
\begin{displaymath}
  \VAR\vec{\aLoc}\SEMI
  \vec{\aLoc}\GETS\vec{0}\SEMI
  \vec{\bLoc}\GETS\vec{0}\SEMI
  \FENCE\SEMI
  (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
\end{displaymath}
where $\aCmd^1$, \ldots, $\aCmd^n$ do not include $\PAR$.  (More generally,
we could allow any program where parallel composition is always preceded by
an acquire fence --- this is needed to keep register state from percolating
to the forked threads.)

% In Figure~\ref{fig:programs}, we give the semantics as sets of pomsets.  
% \begin{figure*}
The semantics of programs is as follows:
\allowdisplaybreaks
\begin{align*}
  \sem{\SKIP} & = \{ \emptyset \} \\
  \sem{\FENCE\SEMI \aCmd} & = (\DF{}) \prefix \sem{\aCmd} \\
  \sem{\REF{\bExp}\GETS\aExp\SEMI \aCmd} & = \textstyle\bigcup_\aLoc\; \textstyle\bigcup_\aVal\; \bigl((\REF{\bExp}=\aLoc \land \aExp=\aVal) \guard (\DW\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] \\
  \sem{\REFRel{\bExp}\GETS\aExp\SEMI \aCmd} & = \textstyle\bigcup_\aLoc\; \textstyle\bigcup_\aVal\; \bigl((\REF{\bExp}=\aLoc \land \aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] \\
  % \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DW\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] \\
  % \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}\bigr)[\aExp/\aLoc] \\
  \sem{\aReg\GETS\REF{\bExp}\SEMI \aCmd} & = \textstyle\bigcup_\aLoc\; (\REF{\bExp}=\aLoc) \guard (\sem{\aCmd}[\aLoc/\aReg] \cup \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]) \\
  \sem{\aReg\GETS\REFAcq{\bExp}\SEMI \aCmd} & = \textstyle\bigcup_\aLoc\; (\REF{\bExp}=\aLoc) \guard (\textstyle\bigcup_\aVal\; (\DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]) \\
  % \sem{\aReg\GETS\aLoc\SEMI \aCmd} & =  \sem{\aCmd}[\aLoc/\aReg] \cup \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  % \sem{\ACQ\aReg\GETS\aLoc\SEMI \aCmd} & =  \textstyle\bigcup_\aVal\; (\DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI} & =  \bigl((\aExp \neq 0) \guard \sem{\aCmd}\bigr) \parallel \bigl((\aExp=0) \guard \sem{\bCmd}\bigr) \\
  \sem{\aCmd \PAR \bCmd} & =  \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & =  \nu \aLoc \st \sem{\aCmd}
% \caption{Semantics of a concurrent shared-memory language}
% \label{fig:programs}
% \end{figure*}
\end{align*}

Note that the rule for write uses the substitution $[\aExp/\aLoc]$ with
precondition $\aExp=\aVal$, rather than using $[\aVal/\aLoc]$ directly.
To see the need for this, consider
$\sem{\IF{\bReg\EQ\aReg}\THEN \cLoc\GETS 1\FI}$,
which includes
\begin{tikzinline}[node distance=1em]
  \event{c}{\bReg=\aReg \mid \DW\cLoc1}{}
\end{tikzinline}.
Therefore
$\sem{\bReg\GETS\aLoc\SEMI\IF{\bReg\EQ\aReg}\THEN \cLoc\GETS 1\FI}$
includes
\begin{tikzinline}[node distance=1em]
  \event{c}{\aLoc=\aReg \mid \DW\cLoc1}{}
\end{tikzinline}
and
$\sem{\aLoc\GETS\aReg\SEMI\bReg\GETS\aLoc\SEMI\IF{\bReg\EQ\aReg}\THEN \cLoc\GETS 1\FI}$
includes
\begin{tikzinline}[node distance=1em]
  \event{c}{\aReg=\aReg \mid \DW\cLoc1}{}
\end{tikzinline}
which is independent of $\aReg$.
%
If we took the semantics of write to use $[\aVal/\aLoc]$, then we would end
up with pomsets of the form
\begin{tikzinline}[node distance=1em]
  \event{c}{\aVal=\aReg \mid \DW\cLoc1}{}
\end{tikzinline}
which depend on $\aReg$.

It is worth emphasizing that prefixing does not necessarily induce a
dependency, even for read actions where the read is used.  To see that this
is desirable, consider  the semantics of
$\bLoc\GETS0\SEMI\aReg\GETS\bLoc\SEMI\IF{\aReg\leq1}\THEN \aLoc\GETS 2\FI$.
To begin, not that 
$\sem{\IF{\aReg\leq1}\THEN \aLoc\GETS 2\FI}$ includes
\begin{tikzinline}[node distance=1em]
  \event{c}{\aReg\leq1 \mid \DW\aLoc2}{}
\end{tikzinline}
which depends on $\aReg$.
Then $\sem{\aReg\GETS\bLoc\SEMI\IF{\aReg\leq1}\THEN \aLoc\GETS 2\FI}$ includes
\begin{tikzdisplay}[node distance=1em]
    \event{b}{\DR\bLoc1}{}
    \event{c}{\bLoc\leq1 \mid \DW\aLoc2}{right=of b}
\end{tikzdisplay}
which has no order between the read and write.
By prefixing a write to $\bLoc$, $\sem{\bLoc\GETS0\SEMI\aReg\GETS\bLoc\SEMI\IF{\aReg\leq1}\THEN \aLoc\GETS
  2\FI}$ discharges the precondition of the write to $\aLoc$, giving
\begin{tikzdisplay}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{0\leq1 \mid \DW\aLoc2}{right=of b}
\end{tikzdisplay}
which is simply:
\begin{tikzdisplay}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
\end{tikzdisplay}
Here the thread-local value of $\bLoc$ discharges the predicate.
Using the left-hand side of the read rule, the semantics of this program also includes
\begin{tikzdisplay}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{c}{\DW\aLoc2}{right=of a}
\end{tikzdisplay}

A variant of this which indicates the branch taken:
$\sem{\bLoc\GETS0\SEMI\aReg\GETS\bLoc\SEMI\IF{\aReg\leq1}\THEN
  \aLoc\GETS2\SEMI\cLoc\GETS\aReg\FI}$
includes
\begin{tikzdisplay}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
    \event{d}{\DW\cLoc1}{right=of c}
    \po[bend left]{b}{d}
\end{tikzdisplay}
A program to that witnesses the independence of $\DR\bLoc1$ and $\DW\aLoc2$ is
\begin{math}
  \IF{\bLoc\EQ0}\THEN
    \IF{\aLoc\EQ2}\THEN
      \bLoc\GETS1\SEMI
      \IF{\cLoc\EQ1}\THEN\PASS\FI
    \FI
  \FI
\end{math}.
Putting these in parallel gives you:
\begin{tikzdisplay}[node distance=1em]
    \event{a}{\DW\bLoc0}{}
    \event{b}{\DR\bLoc1}{right=of a}
    \event{c}{\DW\aLoc2}{right=of b}
    \event{d}{\DW\cLoc1}{right=of c}
    \po[bend left]{b}{d}
    \event{a2}{\DR\bLoc0}{below=of a}
    \event{b2}{\DR\aLoc2}{right=of a2}
    \event{c2}{\DW\bLoc1}{right=of b2}
    \event{d2}{\DR\cLoc1}{right=of c2}
    \po{a2}{b2}
    \po{b2}{c2}
    \po[bend right]{b2}{d2}
    \rf{a}{a2}
    \rf{c}{b2}
    \rf{c2}{b}
    \rf{d}{d2}
\end{tikzdisplay}

% Local Variables:
% mode: latex
% TeX-master: "paper"
% End:
