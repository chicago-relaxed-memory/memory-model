\section{Proof of DRF}\label{drfproof}

In this section of the appendix, we develop a proof of DRF.  In this section, we first develop closure conditions on semantics.  Next, we prove DRF.

\subsection{Closure properties}

We say that $\aPS' = \aPS\restrict{\Event'}$ when 
 $\Event' \subseteq \Event$,
 ${\labeling'} = {\labeling}\restrict{\Event'}$, 
 ${\le'} = {\le}\restrict{\Event'}$, and
 ${\gtN'} = {\gtN}\restrict{\Event'}$.

\begin{definition}
Let $(\aPS \after \aEv) = {\{ \bEv\in\Event \mid \aEv \le \bEv
  \}}$ be the set of events that follow $\aEv$ in $\aPS$.
\end{definition}

The semantics of read is ``input''-enabled, since it permits the read of any visible value.   Thus, any racy read in a program can be replaced by a read of a earlier value (wrt $\reco$), even while  the races with existing independent writes are maintained.   A canonical example to keep in mind for this lemma is the program:
\begin{align*}
\mbox{Thread 1: } &\VAR y\GETS 0 \SEMI \aReg \GETS y  \SEMI x \GETS 1  \SEMI \\[-.5ex]
\mbox{Thread 2: } &\VAR x\GETS 0 \SEMI \bReg \GETS x \SEMI y \GETS 1  \SEMI 
\end{align*}
with both registers getting value $1$ via the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{y}{0}}{}
\event{ry1}{\DR{y}{1}}{right=of wy0}
\event{wx1}{\DW{x}{1}}{right=of ry1}
\event{wx0}{\DW{x}{0}}{below=of wy0}
\event{rx1}{\DR{x}{1}}{right=of wx0}
\event{wy1}{\DW{y}{1}}{right=of rx1}
\rf{wx1}{rx1}
\rf{wy1}{ry1}
\wk{wx0}{rx1}
\wk{wy0}{ry1}
\end{tikzdisplay}
The lemma constructs the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{y}{0}}{}
\event{ry1}{\DR{y}{0}}{right=of wy0}
\event{wx1}{\DW{x}{1}}{right=of ry1}
\event{wx0}{\DW{x}{0}}{below=of wy0}
\event{rx1}{\DR{x}{0}}{right=of wx0}
\event{wy1}{\DW{y}{1}}{right=of rx1}
\rf{wx0}{rx1}
\rf{wy0}{ry1}
\wk{rx1}{wx1}
\wk{ry1}{wy1}
\end{tikzdisplay}


\begin{lemma}\label{inputen}
%Let $\aCmd = \vec{\aLoc}\GETS\vec{0}\SEMI \FENCE\SEMI (\aCmd^1 \PAR \cdots \PAR \aCmd^n)$.
Let $\aCmd$ have an initial value for $\aLoc$.   
Let $\aPS \in \sem{\aCmd}$.  
Let $\aEv \in \aPS$ read from write event $\bEv$  on $\aLoc \in \vec{\aLoc}$.  Let $\neg(\bEv \xhb \aEv)$ in $\aPS$. 
Then, there exists $\bPS \in \sem{\aCmd}$ such that:
\begin{itemize}
%\item $(\exists \aEv' \in \Event_{\bPS})$ such that $
%\Event_{\bPS}$ is the disjoint union of  $\Event_{\aPS} \setminus  
%(\aPS \after \aEv))$ and $(\bPS \after \aEv')$.
\item $\aEv'$ reads from $\aLoc$, with matching write event $\bEv'$, such that $\bEv' \xeco \bEv$ in $\bPS$
\item The restriction of $\le$ (resp. $\gtN$) in $\aPS$ to $\Event_{\aPS} \setminus  (\aPS \after \aEv)$ agrees with the the restriction of $\le$ (resp. $\gtN$) in $\bPS$ to $\Event_{\bPS} \setminus  (\aPS \after \aEv)$  in  $\bPS$.  
\end{itemize}
\end{lemma}
\begin{proof}
The key observation behind the proof is that change in a  prefixing read action can only affect the events that are dependent, ie. in the $\lt$ order to the read action.  

The form of the command in the hypothesis of the proof initializes the locations in $\vec{\aLoc}$, thus  ensuring that there is always a value visible to be read. 
\end{proof}
In particular, in the above lemma, $\bEv,\bEv'$ are events of both $\aPS$ and $\bPS$, and  $\bPS$ continues to witness the race of $\aEv', \bEv$ in $\bPS$.   

In the following lemma,  invert the $\reco$ relationship between a read and a write.   A canonical example to keep in mind for this lemma is the program:
\begin{align*}
\mbox{Thread 1: } &\VAR y\GETS 0 \SEMI   x \GETS 1  \SEMI \aReg \GETS y  \SEMI \\[-.5ex]
\mbox{Thread 2: } &\VAR x\GETS 0 \SEMI  y \GETS 1  \SEMI  \bReg \GETS x \SEMI
\end{align*}
with both registers getting value $0$ via the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{y}{0}}{}
\event{wx1}{\DW{x}{1}}{right=of wy0}
\event{ry0}{\DR{y}{0}}{right=of wx1}
\event{wx0}{\DW{x}{0}}{below=of wy0}
\event{wy1}{\DW{y}{1}}{right=of wx0}
\event{rx0}{\DR{x}{0}}{right=of wy1}
\rf[bend right]{wx0}{rx0}
\rf[bend left]{wy0}{ry0}
\wk{rx0}{wx1}
\wk{ry0}{wy1}
\wk{wx0}{wx1}
\wk{wy0}{wy1}
\end{tikzdisplay}
The lemma constructs the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{y}{0}}{}
\event{wx1}{\DW{x}{1}}{right=of wy0}
\event{ry0}{\DR{y}{1}}{right=of wx1}
\event{wx0}{\DW{x}{0}}{below=of wy0}
\event{wy1}{\DW{y}{1}}{right=of wx0}
\event{rx0}{\DR{x}{1}}{right=of wy1}
\rf{wx1}{rx0}
\rf{wy1}{ry0}
\wk{wx0}{wx1}
\wk{wy0}{wy1}
\end{tikzdisplay}



\begin{lemma}\label{removerw}
Let $\aPS \in \sem{\aCmd}$.   
Let $\bEv \in \aPS$ be a write on $\aLoc$. 
Let $\aEv \in \aPS$ read from $\aLoc \in \vec{\aLoc}$ such that $\aEv \xeco \bEv$ and $\neg(\aEv \lt \bEv)$.  Then, there exists $\bPS \in \sem{\aCmd}$ such that:
\begin{itemize}
%\item $(\exists \aEv' \in \Event_{\bPS})$ such that $
%\Event_{\bPS}$ is the disjoint union of  $\Event_{\aPS} \setminus  
%(\aPS\ \after\ \aEv))$ and $(\bPS\ \after\ \aEv')$.
\item $\aEv' \in \bPS \setminus \aPS$ reads from $\aLoc$, with matching write $\bEv$.
\item The restriction of $\le$ (resp. $\gtN$) in $\aPS$ to $\Event_{\aPS} \setminus (\aPS\ \after\ \aEv)$ agrees with the the restriction of $\le$ (resp. $\gtN$) in $\bPS$ to $\Event_{\bPS} \setminus  (\aPS\ \after\ \aEv)$.  
\end{itemize}
\end{lemma}
\begin{proof}
The proof proceeds similar to the above proof; in this case, replace the value read in $\aEv$ to come from $\bEv$.  
\end{proof}
Any new  event $\bEv'$ in $\bPS \after \aEv'$ reading from $\aLoc$ cannot have a matching write event $\bEv'' \xeco \bEv$ since that  implies $\bEv' \xeco \bEv$ and a $\reco$ cycle $\bEv \lt \aEv \lt \aEv' \xeco \bEv$.  Thus, the above lemma can be iterated if the new pomset is has any further reads that precede $\bEv$ in $\reco$, so we can finally derive a pomset with no reads and writes satisfying the hypothesis of the lemma.   

The $\reco$ order between writes that are not related by $\lt$ can be reversed. 
A canonical example to keep in mind for this lemma is the program:
\begin{align*}
\mbox{Thread 1: } &\VAR x\GETS 1 \\[-.5ex]
\mbox{Thread 2: } &\VAR x\GETS 0 
\end{align*}
with both registers getting value $0$ via the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{x}{1}}{}
\event{wx0}{\DW{x}{0}}{below=of wx0}
\wk{wy0}{wx0}
\end{tikzdisplay}
The lemma constructs the execution:
\begin{tikzdisplay}[node distance=1em]
\event{wy0}{\DW{x}{1}}{}
\event{wx0}{\DW{x}{0}}{below=of wx0}
\wk{wx0}{wy0}
\end{tikzdisplay}
\begin{lemma}\label{cohww}
Let $\aPS \in \sem{\aCmd}$.  Let $\bEv, \aEv$ be a writes to $\aLoc$ such that:
\begin{itemize}
\item $\bEv\gtN \aEv$  
\item forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$,  it is the case that  $ \neg(\cEv \lt \aEv)$ and $\neg(\cEv \xpox \aEv)$
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$ such that $\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$,
and $\aEv \gtN \bEv$ in $\bPS$.
\end{lemma}
\begin{proof}
We show how to interchange $\aEv, \bEv$ adjacent in $\gtN$, ie. we assume that  $\neg(\exists \cEv) \  \bEv \gtN \cEv \gtN \aEv$.  The full proof follows by induction.

Since  $\sem{\aCmd}$ is augmentation closed, it suffices to show that we can build $\bPS$ while satisfying the constraints between $\lt,\gtN$.  We list the changes below.
\begin{itemize}
\item $\aEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\aEv$, change from $\bEv \gtN \cEv$ in $\aPS$ to $\cEv \gtN \bEv$ in $\bPS$
\item Forall reads $\cEv$ matched to $\bEv$, change from $\cEv \gtN \aEv$ in $\aPS$ to $\aEv \gtN \cEv$ in $\bPS$
\end{itemize}

\end{proof}


\subsection{DRF Proof}
In the rest of this section, we assume that $\aPS$ is a generator for
$\aCmd$, as defined in \textsection\ref{sec:sc}.

We prove:
\begin{description}
\item[DRF1: ] If $\aPS$ does not have a race, $\aPS \in \semsc{\aCmd}$. 
\item[DRF2: ] If $\aPS$ has a race, then there exists $\bPS\in \semClosed{\aCmd}$ such that $\bPS \in \semsc{\aCmd}$ and has a race.
\end{description}

\paragraph*{Proof of DRF1}
We first show that if $\aPS \in \sem{\aCmd} \setminus \semsc{\aCmd}$, then $\aPS$ has a race.  By assumption, there is a cycle in  $\rpox \cup \lt \cup \xeco$.  Let this cycle be $\aEv_0, \aEv'_0, \aEv_1, \aEv'_1, \ldots, \aEv_n, \aEv'_n, \aEv_0$ where for all $i$, $\aEv_i \xpox \aEv'_i$ and $\aEv'_i  \not\xpox \aEv'_{i+1}$.
If for all $i$, $\aEv'_i  \xhb \aEv'_{i+1}$, then the above is a cycle in $\rhb$, which is a contradiction.
So, there is at least one $i$ such that $\aEv'_i  \not\xhb \aEv'_{i+1}$.  There are two cases to consider.
\begin{itemize}
\item $\aEv'_i  \xeco \aEv'_{i+1}$.   In this case, there is a race.
\item  $\aEv'_i  \lt \aEv'_{i+1}$.  In this case, $\aEv'_i$ is a write and $\aEv'_{i+1}$ is a conflicting read, so there is a race. 
\end{itemize}


\paragraph*{Proof of DRF2}

We define a size $|\aPS|$ as follows: $\size(\aPS)$ is the number of events in $\aPS$.    Since we are considering loop free programs, there is an $\aPS \in \semsc{\aCmd}$ with maximum size, which we identify as $\size(\aCmd)$.  

We prove by induction on $\size(\aCmd) - \size(\bPS)$ that given $(\aPS, \bPS)$ such that:
\begin{itemize}
\item $\bPS$ is a prefix of some $\aPS' \in \semsc{\aCmd}$
\item $\bPS$ is a prefix of $\aPS$ under all of $\xpox,\gtN,\lt$ 
\item $\aPS$ has a race
\end{itemize}
there exists $\bPS\in \sem{\aCmd}$ that demonstrates the race.

The required theorem follows by setting $\bPS$ to be the empty pomset.

For the base case, $\bPS = |\aPS|$.  In this case, $\aPS$ is the required witness.

Otherwise, consider a maximal sequential prefix, extending $\bPS$, wrt to all of  $\rpox,\reco,\lt$.  If it strictly contains $\bPS$, result follows from induction hypothesis.  

If not, $\bPS$ is already maximal.  Consider the set of all events in $\aPS \setminus \bPS$ that are minimal wrt $\rhb$.  In particular, these events will also be minimal wrt $\rpox$.  

If one of these events, say $\aEv$  is a write, we proceed as follows.   Using $\rhb$-minimality of $\aEv$, we deduce that $\aEv$ is $\lt$-minimal .  Using lemma~\ref{removerw}, we build $\aPS_1$ from $\aPS$ without changing $\bPS$ to ensure that there are is no read $\bEv \in \aPS_1 \setminus \bPS$ such that $\bEv \xeco \aEv$.  Using lemma~\ref{cohww}, we build $\aPS_2$ from $\aPS_1$ without changing $\bPS$ to ensure that there are is no write $\bEv \in \aPS_2 \setminus \bPS$ such that $\bEv \xeco \aEv$.  Thus, $\aEv$ is $\reco$-minimal in $\aPS_2 \setminus \bPS$.  Result follows from induction hypothesis by considering $(\aPS_2,\bPS_1)$ where $\bPS_1$ is got from $\bPS$ by adding $\aEv$.  


So, we can assume that  all events in $\aPS \setminus \bPS$, say $\aEv_0, \ldots, \aEv_n$  that are minimal wrt $\rhb$ are reads, and we have  events 
$\aEv'_0, \aEv'_1, \ldots, \aEv'_n, \aEv_0$ such that:
\[
\begin{array}{lrl}
\aEv_i \xpox\ \aEv'_i \\
\aEv'_i \  (\reco\ \cup \lt)  \ \aEv_{(i+1)\mod n}
\end{array}
\]
Let $\bEv$ be the matching write for $\aEv_{(i+1)\mod n}$. If $\bEv_i \in \bPS$bEv , then by $\reco$ prefix closure of $\bPS$, $\bEv \xeco\ \aEv'_i$ and $\aEv_{(i+1)\mod n} \reco\ \aEv'_i$, which is a contradiction to $\reco$ being a total order per location.  So, we can assume that $\aEv'_i \  \lt  \ \aEv_{(i+1)\mod n}$. 

We proceed as follows.  We use lemma~\ref{inputen} on the  pomset $\aPS$ and read $\aEv_{(i+1)\mod n}$ and write $\aEv'_i$ to construct $\cPS$ that changes the value read in $\aEv_{j}$ to a value from $\bPS$.  $\dPS$  is derived adding the modified read yielded by lemma~\ref{inputen} to $\bPS$.  Result follows by induction hypothesis since $\dPS$ is a prefix of $\cPS$ under all of $\xpox,\lt, \reco$,  $\cPS$ has a race, and $\size(\dPS) = \size(\bPS) + 1$. 

\section{Proof for ARMv8}
\label{sec:arm:proof}

In this section, we develop the proof of correctness of compilation to \armeight.  In order to ease readability, we reproduce the definitions from the main text. 



Given a relation $R$, $R^?$ denotes reflexive closure, $R^+$ denotes
transitive closure and $R^*$ denotes reflexive and transitive closure.  Given relations $R$ and $S$, $R;S$ denotes composition.


The ARMv8 model is described using the following relations.
\begin{itemize}
\item $\IDR$, $\IDW$, $\IDAcq$, $\IDRel$: identity on reads, writes, acquires
  and releases.
% \item $\IDR$ identity on reads
% \item $\IDW$: identity on writes
% \item $\IDAcq$: identity on acquires
% \item $\IDRel$: identity on releases
\item $\IDLoc$: relates any two events that touch the same location.
\item $\rpox$: program order.
\item $\rdata$, $\rctrl$, $\raddr$: data, control and address dependencies.
\item $\rrfx$: reads-from. $\rrfx^{-1}$ relates each read to a matching write
  on the same location.
\item $\rco$: coherence, which is a total order on the writes to a single
  location.
\item ${\rfr}\eqdef{\rco};\rrfx^{-1}$: from-read, which relates reads to
  subsequent writes.
\end{itemize}
For any relation, the cross-thread subrelation is denoted by appending $e$;
the intra-thread subrelation is denoted by appending $i$.  For example,
${\rrfe}\eqdef{\rrfx}\setminus{\rpox}$ and ${\rrfi}\eqdef{\rrfx}\cap{\rpox}$.
The subrelation restriction attention to actions on the same location is
given by appending $\mathsf{loc}$.  For example, ${\rpoloc}\eqdef{\rpox}\cap{\IDLoc}$.

The ARMv8 model defines the following relations.
In our presentation, we have elided rules concerning fences and RMW operations.
\begin{align*}
  \tag{Extended coherence}
  {\reco} &\eqdef {\rrf} \cup {\rfr} \cup {\rco}
  \\
  \tag{Observed externally}
  {\robs} &\eqdef \smash{
    {\rrfe} \cup {\rfre} \cup {\rcoe}
  }
  \\
  \tag{Dependency order}
  {\rdob} &\eqdef\smash{
    ({\raddr}\cup{\rdata}); {\rrfi}^?
    \cup ({\rctrl}\cup{\rdata}); {\IDW}; {\rcoi}^?
    \cup {\raddr}; {\rpox}; {\IDW}
  }
  \\
  \tag{Barrier order}
  {\rbob} &\eqdef\smash{
    {\IDAcq}; {\rpox}
    \cup {\rpox};{\IDRel}; {\rcoi}^?
  }
  \\
  \tag{Acyclic order}
  {\rob} &\eqdef\smash{
    ({\robs} \cup {\rdob} \cup {\rbob})^+
  }
\end{align*}
\begin{definition}
  An RMW-free and fence-free execution is \emph{ARM-consistent} if
  \begin{align*}&
    \tag{\textsc{$\rrfx$-completeness}}\label{rf-comp}
    \fcodom(\rrfx)=\fdom(\rreads)
    \\[-1ex]&
    \tag{\textsc{$\rco$-totality}}\label{co-tot}
    \text{For every location $\aLoc$, $\rco$ totally orders the writes of $\aLoc$}  
    \\[-1ex]&
    \tag{\textsc{sc-per-loc}}\label{sc-per-loc}
    {\rpoloc} \cup {\rrfx} \cup {\rfr} \cup {\rco}\;\text{is acyclic}
    \\[-1ex]&
    \tag{\textsc{external}}\label{external}
    {\rob}\;\text{is acyclic}
  \end{align*}
\end{definition}

% Use these to refer to the rules in text:
%\ref{rf-comp} 
%\ref{co-tot}
%\ref{sc-per-loc}
%\ref{external}


Given an execution graph $G$, we say that $\aEv$ is an \emph{internal read} if
$\aEv\in\fcodom(\mathsf{po}\cap \mathsf{rf})$.

From $G$ we construct a candidate pomset $\aPS$ as follows:
\begin{itemize}
\item $\Event= \textsf{E}$,
\item $\labelingAct(\aEv)=\tau \mathsf{lab}(e)$, if $\aEv$ is a relaxed
  internal read, 
\item $\labelingAct(\aEv)=\mathsf{lab}(e)$, if $\aEv$ is not a relaxed
  internal read,
\item $\labelingForm(\aEv)=\TRUE$,
\item ${\le} = {\rob}$, and
\item ${\gtN} = ({\rob} \cup {\reco})^*$
\end{itemize}

We show that $\aPS$ is a top-level pomset, reasoning as follows.

 First, we establish the criteria for a 3-valued pomset (Definition~\ref{def:3valued}).
\begin{itemize}
\item ${\le}$ is a partial order.  This holds since $G.{\rar}$ is acyclic.
\item If $\bEv \le \aEv$ then $\bEv \gtN \aEv$.  By construction.
\item If $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then $\bEv = \aEv$.  Proved below.
\item If $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$ then
  $\cEv \gtN \aEv$. By construction.
\end{itemize}

Next, we establish the criteria for a 3-valued pomset with preconditions (Definition~\ref{def:3pre}).
\begin{itemize}
\item $\labelingForm(\aEv)$ implies $\labelingForm(\bEv)$ whenever
  $\bEv\le\aEv$.   Trivial, since every formula is $\TRUE$.
\item $\aPS$ is $\aLoc$-coherent; that is, when restricted to events that
  read or write $\aLoc$, $\gtN$ forms a partial order.
\end{itemize}

Finally, we establish the criteria for a top-level pomset
(Definition~\ref{def:x-closed}).
\begin{itemize}
\item $\aEv$ is location independent. Trivial, since every formula is $\TRUE$.
\item If $\aEv$ reads $\aVal$ from $\aLoc$, then there is some $\bEv$ such that
  \begin{itemize}
  \item $\bEv \lt \aEv$,  
  \item $\bEv$ writes $\aVal$ to $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}    
\end{itemize}

\subsection{Proof that  $({\rob} \cup {\reco})^*$ is irreflexive. }
We develop a key tool about the composition of $\rob,\reco$.
\begin{lemma}\label{extendob}
Suppose $\aEv$, $\bEv$ and $\aEv$ are distinct events.
\begin{itemize}
\item If $\cEv\xob\bEv\xeco\aEv$ then $\cEv\xob\aEv$.
\item If $\cEv\xeco\bEv\xob\aEv$ then $\cEv\xob\aEv$.
\end{itemize}
\begin{proof}
If the $\reco$ relation in the above is contained in $\robs$, the result is immediate.  So, it suffices to consider the case when they are contained in $\rpox$.  



We next prove  that if $\cEv\xeco\bEv (\xob\cap \xpox) \aEv$ then $\cEv\xob\aEv$.  Proof proceeds by cases on the witness for $\bEv (\xob\cap \xpox) \aEv$.  

\begin{itemize}
\item  If $\bEv \xbob  \aEv$, then: 
\[ \bEv\ (\smash{
    {\IDAcq}; {\rpox}
    \cup {\rpox};{\IDRel}; {\rcoi}^?) \ 
  }
\aEv
\]
So, $\bEv ({\rpox};{\IDRel}; {\rcoi}^?) \aEv$, yielding the result since $\cEv \xpox\ \bEv$.


\item If $\bEv \xdob  \aEv$, then:
\[ \bEv \ (\smash{
    ({\raddr}\cup{\rdata}); {\rrfi}^?
    \cup ({\rctrl}\cup{\rdata}); {\IDW}; {\rcoi}^?
    \cup {\raddr}; {\rpox}; {\IDW} ) \ 
  }
\aEv
\]
So, $\bEv$ is a read.  Thus, $\cEv$ is a write such that there exists $\cEv'$ such $\cEv \rcoe \cEv' \rrfe \bEv$.  Thus, $\cEv \xob \bEv \xob \aEv$, yielding required result.
\end{itemize}
\end{proof}
\end{lemma}

\begin{lemma}\label{obeco1}
If $\bEv\xob\aEv$ then $\lnot(\aEv\xeco\bEv)$.

\begin{proof}
Proof by contradiction.  Let 
\[ \aEv \xob \aEv' \xeco \bEv' \xob \bEv \xob \cEv \xob \cEv' \xob \aEv \]
where $\aEv' \xpox \bEv'$.

By lemma~\ref{extendob}, if $\aEv \not=\aEv'$, we deduce $\aEv \xob \bEv'$, and thus $\aEv \xob \bEv$.  If $\bEv \not=\bEv'$, we deduce $\aEv' \xob \bEv$ and thus $\aEv \xob \bEv$.

Thus, if $\aEv \not=\aEv'$ or $\bEv \not=\bEv'$, then there is a cycle $\aEv \xob \bEv \xob \cEv \xob \cEv' \xob \aEv$.  

So we can assume that  $\aEv' = \aEv$, $\bEv' = \bEv$ and 
\[ \aEv  \xeco \bEv \xob \cEv \xob \cEv' \xeco \aEv \]
where all of $\aEv, \bEv, \cEv, \cEv'$ access the same location and at least one of $\aEv,\bEv$ is a write, at least one of $\aEv,\cEv'$ is a write, and at least one of $\bEv,\cEv$ is a write.

We reason by cases.
\begin{itemize}
\item If $\cEv'$ is a write or both $(\aEv, \bEv)$ are writes.

We deduce that $\bEv \xeco \cEv' \xeco \aEv$ and thus $\bEv \xeco \aEv$.

\item $\cEv'$ is a read.  $\aEv$ is a write.  $\bEv$ is a read.

In this case $\cEv$ is a write.  From $\cEv \xob \aEv$, we deduce $\cEv \xeco \aEv$. Combining with $\bEv \xeco \cEv$, we deduce that $\bEv \xeco \aEv$.  


\end{itemize}
In either case, there is a contradiction $\aEv \xeco \bEv \xeco \aEv$.
\end{proof}
\end{lemma}


\begin{lemma}\label{obeco2}
$({\rob} \cup {\reco})^*$ is irrreflexive.
\end{lemma}
\begin{proof}
The simple case that $\rob; \reco$ is irreflexive is proved above.  The full proof by contradiction.  

Let $n \geq 1$ be the minimum such that:
\begin{align*} 
&\aEv^0_0 \xob \aEv^0_1 \xeco \bEv^0_0 \xob \bEv^0_1  \\
(\xeco \cap \xob) &  \   \aEv^1_0 \xob \aEv^1_1 \xeco \bEv^1_0 \xob \bEv^1_1 \\
(\xeco \cap \xob) & \ \ldots \\
& \ldots \bEv^n_1 \\
 (\xeco \cap \xob) & \  \aEv^0_0
\end{align*}
where  for all $i$, we have:
\[ \aEv^i_0 \xpox \aEv^i_1 (\xeco \cap \xpox) \bEv^i_0 \xpox \bEv^i_1\] and 
\[ \neg (\bEv^i_1 \xpox (\aEv^{(i+1) \mod n}_0 \]

For any $i$, if $\aEv^i_0 \not= \aEv^i_1$ or $\bEv^i_0 \xpox \bEv^i_1$, via lemma~\ref{extendob}, we deduce that $\aEv^i_0  \xob \bEv^i_1$, contradicting minimality of $n$.  

So, we can assume that $n \geq 1$ is such that:
\begin{align*} 
&\ \aEv^0 \xeco  \bEv^0 \\
(\xeco \cap \xob) &  \   \aEv^1  \xeco \bEv^1 \\
(\xeco \cap \xob) & \ \ldots \\
& \ldots \bEv^n \\
 (\xeco \cap \xob) & \ \aEv^0
\end{align*}
which is a contradiction since it is a cycle in $\xeco$.
\end{proof}

\endinput 








\begin{comment}
Operation        Implementation
Relaxed read     ldr                     
Relaxed write    str             
Acquiring read   ldar            
Releasing write  stlr
Fence            dmb.sy
\end{comment}

\begin{comment}
ob does not contradict eco

ob does not contradict (co cap po):

Suppose that wx1 po wx2 then it cannot be that wx2 ob wx1.
We know that wx1 co wx2 by SC-PER-LOC

% Case 1. w1 is read externally, then we have
%   wx1 rfe r
% and
%   r fre w2
% so
%   wx1 obs+ wx2
% which contradicts EXTERNAL

% Case 2. wx1 is not read externally.
We show this by contradiction
Assume
  wx1 co wx2
and
  wx2 ob wx1

Note that
  po supseteq dob cup aob cup bob
So in order to get order into wx1, we must have
  wx2 (ob?; obs; ob?; obs; ob?) wx1

Note that we cannot have dob or bob into wx1 after obs, since then we would
also have it into wx2, creating a cycle in EXTERNAL.  This holds because both
dob and bob are closed on the right w.r.t. coi

So it must be that 
  wx2 (ob?; obs; ob?; wx0; coe) wx1, 
in which case we also have wx0 coe wx2, contradicting EXTERNAL
or 
  wx2 (ob?; obs; ob?; rx0; fre) wx1
in which case we also have rx0 fre wx2, contradicting EXTERNAL




Internal reads do not need to respect ob:
Arm allows the following:

  Ra1 -ctrl-> Wx1 -rfi-> Rx1 ---> Wb1    if(a){x=1}; b=x
   |                               |
  Wa1 <-------------------------- Rb1    a=b


Suppose that wx1 po rx2 and rx2 is read externally.
Then it cannot be that rx2 ob wx1.

Case 1: if wx1 co wx2, then we have wx1 coe wx2 rfe rx2, contradicting EXTERNAL
Case 2: if wx2 co wx1, then we have rx2 fr wx1, contradicting SC-PER-LOC



Suppose that rx1 po wx2 and rx1 is read externally.
Then it cannot be that wx2 ob rx1.

Case 1: if wx2 co wx1, then wx2 co wx1 rf rx1 po wx2, contradicting SC-PER-LOC 
Case 2: if wx1 co wx2, for a contradiction, suppose wx2 ob rx1.
then we need another thread involved to get order from wx2 to rx1.
To get order into the read, there are several options:
- use cross thread read, then dob; but dob does not include reads in it's domain.
  An attempt to do this is something like:

              Wx1                 x=1
               |
  Ra2 -ctrl-> Rx1 - - -> Wx2      if(a){r=x}; x=2
   |                      |
  Wa2 <----------------- Rx2      a=x

  But the ctrl dependency is not included in ob between reads.
- use cross thread read then barrier, but then you contradict EXTERNAL
- create and ob edge from Rx2 to Wx1.
  An attempt to do this is, 

  Wx1 <-------------- Ra1       
   |                   |        But cannot get Wx2 --> Wa1 without a barrier
  Rx1 - - -> Wx2 ---> Wa1       

  Wx1 <----- Rx2                         
   |          |                 contradicts SC-PER-LOC 
  Rx1 - - -> Wx2                         


Other examples to type in:
Allowed:
Rx1 -> Wy0  Wy1
Ry1 -> Wz0  Wz1
Rz1 -> Wx0  Wx1

Forbidden:
Rx1 -> Wy0 Wy1
Ry1 -> Wx0 Wx1

\end{comment}



\begin{comment}
\citet{DBLP:journals/pacmpl/PodkopaevLV19} define the \emph{Intermediate
  Memory Model (IMM)} and provide efficient implementations of the IMM into
several processor architectures, including TSO, ARMv8 and Power.

In this section, we show that any execution allowed by a sublanguage of the
IMM is also allowed by our semantics.  The sublanguage we consider bans
loops, read-modify-write (RMW) operations, and fences.  In addition, we take
the set of memory locations, $\Loc$, to be finite.  Syntactically, we drop
the superscript \textsf{rlx} on relaxed reads and writes; in addition, we use
structured conditionals rather than the more general \textsf{goto}.  We refer
to this sublanguage as $\muIMM$.

$\muIMM$ programs sit in the restriction-free fragment of our language, where
all memory locations are initialized to $0$ and parallel-composition occurs
only at top level.  In other words, $\muIMM$ programs have the form
\begin{displaymath}
  {\aLoc_1}\GETS{0}\SEMI
  \cdots\SEMI
  {\aLoc_m}\GETS{0}\SEMI
  (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
\end{displaymath}
where $\aCmd^1$, \ldots, $\aCmd^n$ do not include either composition or
restriction.

Due to space limitations, we do not include a full description of the IMM.
The broad strokes of the argument given here should be clear, but interested
readers will need to refer to \citep{DBLP:journals/pacmpl/PodkopaevLV19} for
details.
\end{comment}



\endinput

\section{Proof of DRF}

For any $\aPS$, then $\closed(\aPS)$ is set enriched with useless reads
(preserving augmentation closure) and where we remove any event whose
precondition is not a tautology.

For top level programs:
\begin{displaymath}
  \semClosed{\VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\aCmd^1 \PAR \cdots \PAR \aCmd^n)}
  =
  \VAR\vec{\aLoc}\SEMI
    \vec{\aLoc}\GETS\vec{0}\SEMI
    \vec{\bLoc}\GETS\vec{0}\SEMI
    \FENCE\SEMI
    (\semClosed{\aCmd^1} \PAR \cdots \PAR \semClosed{\aCmd^n})
\end{displaymath}

\begin{definition}
A thread: top level component of a parallel composition
\end{definition}

\begin{definition}
$\aPS$ is a generator of  $\semClosed{\aCmd}$ if for all $\bPS \in \semClosed{\aCmd}$ such that $\aPS$ augments $\bPS$, $\aPS = \bPS$.
\end{definition}


Since the program we consider are loop free, for any command $\aCmd$, the size of the pomsets in $\aCmd$ are bounded by a constant, that we denote by $\size(\aCmd)$.  
 

\section{Generators for semantics of programs with parallel composition}
All generators $\aPS$  satisfy the following factorization of cross-thread $\lt$.  

\begin{lemma}\label{pargen}
Consider the subset of pomsets of $\semClosed{\aCmd \PAR \bCmd}$ that are  $\aLoc$-closed for all $\aLoc$.  

Let $\aPS$  be any generator.  
%\begin{itemize}
% \item
 Let $\aEv\lt\bEv$ and $\aEv \in \semClosed{\aCmd}$ and  $\bEv \in \semClosed{\bCmd} $.
  
Then there is a write  $\aEv' \in \semClosed{\aCmd}$, and  a read $\bEv' \in \semClosed{\bCmd}$ such that  $\bEv'$ reads-from $\aEv'$ and $\aEv \lt \aEv' \lt \bEv' \lt \bEv$. 

%\item $\aEv \gtN \bEv$ only if $ \aEv  [\lt \cup (\le; \reco;\le)^{\star}]  
%\bEv$.

% \item If $\aEv\lt\bEv$ and $\aEv, \bEv \in \semClosed{\aCmd}$, 
%then there exists 

%There exists a release action $\aEv'$ in $\sem{\aCmd}$, a 
%matching acquire action $\bEv'$ in $\sem{\bCmd}$ such that $
%\aEv \lt \aEv'$, $\bEv' \lt \bEv$ and $\aEv' \lt \bEv'$.

\end{lemma}








The proof of lemma~\ref{cohsat} yields the following two corollaries.
\begin{corollary}\label{cohrw}
Let $\aPS \in \sem{\aCmd}$ be a generator. Let 
\begin{itemize}
\item $\bEv'$ be a read from $\aLoc$ with matching write $\bEv$.  \item $\aEv$ be a write to $\aLoc$ such that  $\bEv' \gtN \aEv$.   \item Forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$,  it is the case that  $ \neg(\bEv' \lt \cEv)$ and $\neg(\bEv \xpox \cEv) ]$
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that $\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$, and $\aEv \gtN \bEv'$ in $\bPS$.
\end{corollary}
\begin{corollary}\label{cohwr}
Let $\aPS \in \sem{\aCmd}$ be a generator. Let 
\begin{itemize}
\item $\aEv'$  read from $\aLoc$ with matching write $\aEv$. 
\item $\bEv$ be a  write to $\aLoc$ such that  $\bEv \gtN \aEv'$.  \item Forall writes $\cEv$ to $\aLoc$ such that  $ \bEv \gtN \cEv \gtN  \aEv$ and $\cEv \not= \aEv$,  it is the case that  $ \neg(\cEv \lt \aEv')$ and $\neg(\cEv \xpox \aEv) ]$. 
\end{itemize}

Then, there exists $\bPS \in \sem{\aCmd}$, also a generator, such that:
$\Event_{\aPS} = \Event_{\bPS}$, $\le_{\aPS} = \le_{\bPS}$, and 
$\aEv' \gtN \bEv$ in $\bPS$.  

\end{corollary}
        

===============good lemma. Not used. ==================




\begin{definition}
$ \aEv \xeco  \bEv$ if both $\aEv$ and $\bEv$ touch the same location, at least one is a write, and $\aEv \xird \bEv$  or $\aEv \xrb \bEv$ or $\aEv\xird \bEv$ or $\bEv \gtN \aEv$.
\end{definition}



