Given P: such that any cross thread edge in w--> comes from:
         a hb edge, or 
         a conflicting edge on the same variable.


Minimal P:
   * w--> = s--> cup SCperVar closure
   * Only cross thread s--> edges are from hbe or write-- read
   * Only 


(Indn on (P, Q, |remaining events|), where 
     Q is an augmentation of a prefix of P such that (po subseteq w-->, or acyclic(po cup w-->))

Proving:either that Q can be extended into Q' such that
     |Q'| = |P|
    or Q' witnesses a data race.
   In either case, Q' will also satisfy  po subseteq w-->

Proof:
Consider prefixes wrt both po,w-->. 
Consider a maximal such prefix.  
If it is bigger than Q, we are done.

Otherwise
Let e0... en be the next events wrt po

Wlog, assume that e0..en are minimal wrt hb.
a)if all ei are acquires: Q is the full deadlocked pomset  P

b)if an ei is a pure release (* minimality assumption
    all edges into a release arise via edges into those po before it 
*)
   add ei to Q.  Induction HYP
   
c) e0..en are not acquires or releases. 

(i) If ei is a write.  
   Consider Q' = Q cup ei
            P = P \ CUP after(ei), 
                        after(f) for any event f >-->ei

(* If so, just add it to the prefix, and wait for 
   the racy read/write to arise *)

UNFINISHED
 
(ii) e0..en are all reads.
         ei are R/W actions.  There are e0'..ek'  such that:
                ei   po  ei'
                ei'  w-> e[(i+1) mod k]


So, we deduce that ei' are all writes (* minimality stuff *)

Case when: eis are all reads.  ei's are all writes.  ei'  w-> e[(i+1) mod k] is racy.
   (* last by assumption of hb minimality *)
   We deduce that at least one of the ej po ej' is such that not(ej s--> ej')
        (since owise we have a s--> cycle) 

P' = [P\ after(ej)] with ej turning into a read of available value
Q' = Q + changed ej 
Race from ej'  is still valid
            
Induction applies.  

       


Closure properties:
  a. Let P in [| C |].  Let e be a read.    
           Then, there is a pomset Q in [| C |]
                     Q changes value of read
                     Q agrees with P on Q \ follow(e)

  b. 
