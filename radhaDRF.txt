Def: Let P be a pomset.  e an event in P
   after(e) = {f in P | f = e (OR) e s--> f }
   strictlyAfter(e) = {f in P | f = e (OR) e s--> f }
   

Closure properties:
  Lemma. Let P in [| C |]. Let e be an event.   Then, there is a pomset Q in [| C |] st
           * Q agrees with P on P \ after(e)
           * Q \ P has a maximal event e' of the same type as e
                     
Some interesting cases.
  a. Let P in [| C |].  Let e be a read, (R x v). v' chosen as any value.   
           Then, there is a pomset Q in [| C |]
                     there is a maximal event e' = (R x v'), for any v'
                     Q agrees with P on P \ after(e)

  b. Let P in [| C |].  Let e be a write, (W x v).  
           Then, there is a pomset Q in [| C |]
                     Q agrees with P on P \ strictlyafter(e)




Def: 
    f ifr g if: e ird f, e -->g, (e,g) writes on same var
    WeakPerVar =  w-->|var cup ifr cup ird

Require: [COHERENCE]
  linearorder( w-->| writes of a var)  

Def: P is said to be SEQ if:
  acylic(po cup s--> cup WeakPerVar)

Def: If P is SEQ, def Explicate(P):
For each ird edge
      W x i --> f
add a new event R x i and edges:
      R x i s--> f
      W x i s--> R x i
and any induced edges
   e s--> W x i  ==> e s--> R x i  [same for weak]
   f s--> e      ==> R x i s--> e  [same for weak]
  
Lemma:
   If P is SEQ, explicate(P) is a valid pomset
Proof:
      * No s--> cycles (since any cycle in explicate(P) involving new event induces a cycle in P)
      * Visibility maintained since W x i is immediate s--> predecessor of new event

Lemma.  Let P in [| C |] is SEQ,  then explicate(P) in SEQ[| C |]

Proof: (* Structural induction *)
  

Def: Two events are in conflict if they are on same variable and at least one of them is a write 

Def: A race is a pair of conflicting events unrelated by hb

Def: (Minimal)
Let P be such that:
    * Only cross thread s--> edges are from hb or write--->read
 
Def: Q in [| C |] demonstrates a race if:
               a. Q is SEQ
               b. There is a race in Q 
  
Thm:
Given a minimal P.
    if P does not have a race, then P is SEQ
    if P has a race, then there exists Q in [| C |] that demonstrates a race

Lemma.Given (P,Q) where:
          a) P, Q are minimal elements of an execution.  P has a race
          b) Q is a prefix of P under all of po, s-->, WeakPerVar
             Q is SEQ
    Then, either:
         Q can be extended into a SEQ Q' in [| C |] that demonstrates a race.
          
Proof:     
Indn on |Q\P|.

Consider maximal prefix ( wrt all of po,s-->,WeakPerVar) of P that extends Q.   
If it is bigger than Q, we are done (by IH)

Otherwise, Q is maximal such prefix of P. 

Choose events that are minimal wrt po.
Choose subset of events that are minimal wrt s--> (so also hb minimal)

Let this subset be e0... en

Let  be the next events wrt po that are minimal wrt 

  There are e0'..en'  such that:
                ei   po  ei'
                ei'  WPV-> e[(i+1) mod k]

  Choose e0' ... en' to make the cycle the smallest.

  If there is an ej po ej' is such that not(ej s--> ej').  Choose:
         
P' = P\ after=(ej) + fj, (where fj is with ej turning into a read of available value)
Q' = Q + fj 
P' still has a race including ej'  (Induction hyp)


Otherwise: we have e0'..en'  such that:
                ei   s>-->  ei'
                ei'  WPV-> e[(i+1) mod k]

This is a cycle in w--> on a SingleVar.  Contradiction.

==================================== SO FAR SO GOOD =================================
 If there a read in the {e0... en}, say ei
 It has to be fulfilled by e(i-1)
                   since e(i-1)'  WPV-> e[i mod k], e(i-1) is a write          
    We argue it has to be e'(i-1) has to be the matching write
    If not, we have a smaller cycle
  
if One of the ei' --> e(i+1) edges is a rf edge
                 Change the read at e(i+1)
                 Drop strictly after e(i+1)

 





=============================

So,    ei's are reads.  
   ==> ei's are writes.
   ==> ei WPV e(i+1) is either a   

(i) If ei is a write.  
   Consider Q' = Q cup ei
            P = P \ CUP after(ei), 
                        after(f) for any event f >-->ei

(* If so, just add it to the prefix, and wait for 
   the racy read/write to arise *)

UNFINISHED
 
(ii) e0..en are all reads.
        There are e0'..ek'  such that:
                ei   po  ei'
                ei'  w-> e[(i+1) mod k]


So, we deduce that ei' are all writes (* minimality stuff *)

Case when: eis are all reads.  ei's are all writes.  ei'  w-> e[(i+1) mod k] is racy.
   (* last by assumption of hb minimality *)
   
            
Induction applies.  

       



