Def.  s-> is the skeleton of strong arrow.i.e
  * transitive closure of s-> is the strong arrow
  * a s-> b  ===> !exists c \not\in {a,b}: a strong c strong b

Def: minimum model:
    (*)  s-> across threads is (a) write to read, or (b) hbe edge 
    (**) within thread is a subset of po
    (**) only edges out of writes are to release
         only edges into reads are from acquire/reads
    (***) NO DANGLING READS

Assumptions.
1. po;hbe;hbe = hbe
2. hbe strict partial order, po is a union of total orders. (so, hb transitive)
3. ??poloc subseteq weak??? (* not used in these proofs *)
4. hbe subseteq strong
5. Closure.  For any prefix of events, there is an extending execution where the new
         events are sequential (ie. any two new events related by po are related by strong)

Def: race. (w,r) in execution, not related by hb   

Order on (w,r) pairs of an execution:
   (w1,r1) < (w2, r2) if r1 < r2       

Lemma 1. Consider a minimum model.
    * events e (Write),f (Read) are in a race
    * (e,f) minimal in above order.

(A)Let e' strong e.  Then:
   not (f po e')
   not (e po e')

(B)Let f' strong e.  Then:
   not (f po f')
   not (e po f')

Proof:
(A)
   Let e'=a0 s-> a1 s-> a2 .... s-> a(n+1) = e
     be the s-> path from e' to e.
   Let us assume that there is at least one edge
           in this path that crosses threads.  
   Any edge in this path in the same thread is a po edge.
   Any edge that crosses threads in this path is a hbe edge.
     If not:
          (ak,a(k+1)) is a race
           ak is a write
           a(k+1) s-> e s-> f
   Contradicting minimality of (e,f)

     So, e' hbe e.

Case (i): not (f po e')
   Two cases.
        case a. e' in different thread than e. Then, above holds. So:
            f po e' hbe e ==> f hbe e (contradiction to (e,f) being a race/matching pair)
        case b. e' in same thread as e.
            Then e', f in different threads.

Case (ii): not (e po e')
       Two cases.
       case a. e' in different thread than e. Then, above holds:
            e' hbe e po e' ==> e' hbe e' (contradiction)
       case b. e' is same thread as e. Then, 
                case (i) above holds:
                    e' hbe e po e' ==> e' hbe e' (contradiction) 
                case (ii) above does not hold.  Whole path in same thread.
                    In this case, e' po e ===> not (e po e')

======== COPYING ABOVE ================================================
(B)
   Let f'=a0 s-> a1 s-> a2 .... s-> a(n+1) = f
     be the s-> path from f' to f.
   Let us assume that there is at least one edge
           in this path that crosses threads.  
   Any edge in this path in the same thread is a po edge.
   Any edge that crosses threads in this path is a hbe edge.
     If not:
          (ak,a(k+1)) is a race
           ak is a write
           a(k+1) s->.. f
   Contradicting minimality of (e,f)

     So, f' hbe f.

Case (i): not (f po f')
       Two cases.
       case a. f' in different thread than f. Then, above holds:
            f' hbe f po f' ==> f' hbe f' (contradiction)

       case b. f' is same thread as f Then, 
                case (i) above holds:
                    f' hbe f po f' ==> f' hbe f' (contradiction) 
                case (ii) above does not hold.  Whole path in same thread.
                    In this case, f' po f ===> not (f po f')

Case (ii): not (e po f')
    Two cases.
        case a. f' in different thread than f. Then, above holds. So:
            e po f' hbe f ==> e hbe f (contradiction to race)
        case b. f' in same thread as f.
            Then f', e in different threads.

=============================================================================

Def. L-sequential.  L-events related by po are related by strong

Def.  Given L, let L-po be the restriction of po to L.

Thm 1.  (DRF ==> SEQ)  If a minimal execution has no data-races, then:
    po cup strong order is acyclic.

Proof. [By contradiction]
    Every cross thread edge is hbe, by DRF.  Every in thread edge is a po edge.
    So, since po;hbe;po is contained in hbe, we get a hbe cycle.
    Contradiction.

NonThm. (LDRF ==> LSEQ) 
If a minimal execution has no data-races, then:
    L-po cup strong order is acyclic.

Counter example:
if (Ru1)         W_R(y1)       if (Rz1) 
   Wx1;      ||             ||    Wu1
if R_A(y1)
   Wz1

L = {x,y}.  No L Data races
But, no L-sequential execution

However. 
Def: An execution is L-valid if there is no information flow
from L-locs to nonL-locs.

Example:
  if (Ru1) Wy1;            acq;
  Wx1;                ||    Wu1;
  release;

Def of information flow:
   (a) From reads to writes that depend on it.
   (b) From writes to hbe dependent writes
(eg) There is an information flow out of Wx1 to Wu1!

Thm 2.  (LDRF ==> LSEQ)
If a minimal, L-valid execution has no L-data races, then:
               L-po cup strong order is acyclic.
Proof [by contradiction]
  Consider a simple cycle in L-po cup strong order.  
  The cycle has to have at least one L event e.

  Let cycle be e=f0 f1... fn 
        where fi are in the same thread t.
  Then, fn in L and fn is a write.


  We prove by indn on length of seq |f0..fn| that if
           f0 is a L-event
          (OR) there is a strong arrow from an L-read into f0
 then fn in L.

  Base.  n=0. By NO DANGLING, f0 is a write.  So, f0 in L (by info flow)

  Induction. Consider f0...fn, where f0 in L.
    If f0 is a write.
        f0 f1 is a new L-po edge. (minimality)
               So, f1 in L.  Indn on f1..fn
    If f0 is a read. 
        f0 in L: then, f1..fn satisfies IH.
        f0 not in L:
             then, by minimality, f0 is a read
             f1..fn satisfies IH.
   

Thm 3[Finding L-races by L-seq]
===============================
  Find minimal L-race (e,f).
  Consider the strong prefix P of (e,f).
  By lemma 1, (e,f) are po-maximal.
  P can be extended to a L-sequential prefix P'.
  P' +(e,f) is the required witness. 
  
  
  
  

 









      


