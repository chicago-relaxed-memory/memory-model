\newcommand{\oota}{{\sc OOTA}}

\newcommand{\tso}{{\sc tso}}
\newcommand{\armseven}{{\sc armv7}}
\newcommand{\armeight}{{\sc armv8}}
\newcommand{\ppc}{{\sc ppc}}
\newcommand{\mca}{{\sc MCA}}

\section{Introduction}
\citet{Manson:2005:JMM:1047659.1040336} identify the central problem in the design of software relaxed memory models: ``The memory model must strike a balance between ease-of-use for programmers and implementation flexibility for system designers.''   This paper provides a solution  in the context of multi-copy atomicity.

In order to sharpen the criteria to evaluate memory models, we first outline desiderata  that concretize the above prescription.  

There are two dimensions to implementation flexibility, namely:
\begin{itemize}
\item The memory model should facilitate compiler transformations.    Ideally, the model should support the known transformations used to optimize  synchronization free single threaded code.  A canonical example is the  commuting of independent statements.

\item Compiling to hardware models.  The model should be realizable on modern hardware with minimal synchronization.  A canonical example is that the relaxed atomics of C11 (or the raw variables of Java) should not require any extra synchronization.
\end{itemize}

There are two dimensions to ``ease-of-use'', namely:
\begin{itemize}
\item The ``DRF'' criterion~\cite{DBLP:journals/tpds/AdveH93, DBLP:conf/isca/AdveH90} permits the programmer to forget about relaxed memory for correctly synchronized programs without data races.  

\item All programs, racy or not,  should support compositional reasoning on safety properties~\cite{PnueliSafety,Misra:1981:PNP:1313338.1313770,StarkSafety,Abadi:1993:CS:151646.151649}.  The simplest form of such a composition principle, addressing temporal invariants is:
\[
  \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
\]
where $\afo$ is a temporal safety property on read and write actions, and $\afo, \aPSS_1 \models\afo$ indicates that $\aPSS_1$ satisfies $\afo$ if the environment satisfies $\afo$.  This cyclical compositional proof rule permits us to reason separately about individual threads. 
\end{itemize}
We illustrate the last criterion, perhaps novel in this context, with examples.   
\begin{itemize}
\item ``Out Of Thin Air''(\oota)  violates the principle.  For example, consider the program:
\begin{align*}
& \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI  \\[-.5ex]
\mbox{Thread 1: } & y\GETS x \\[-.5ex]
\mbox{Thread 2: } & x \GETS y
\end{align*}
Informally, both threads satisfy the invariant that conjoins ``A write of 1  to x  requires a prior read  of 1 from y'' and ``A write of 1  to y  requires a prior read  of 1 from x ''.  If composition holds, the full program satisfies the invariant.  Since the variable declaration closes the program from other writes to $x,y$, we  deduce the conjunction of  ``A write of 1  to x  requires a prior write  of 1 to x'' and ``A write of 1  to y  requires a prior write  of 1 from x'' . Thus, we deduce that ``A write of 1  to x  requires a prior write  of 1 to x'', and consequently ``there is no write of 1 to x''. 

Composability  of safety properties provides an  objectively {\em falsifiable} measurement of \oota\ in a memory model. 

\item   ~\citet{DBLP:journals/toplas/Lochbihler13} considers a racy program:
\begin{align*}
& \VAR x\GETS null \SEMI \VAR y\GETS null  \SEMI \VAR b\GETS \FALSE \SEMI  \\[-.5ex]
\mbox{Thread 1: } & x \GETS y \\[-.5ex]
\mbox{Thread 2: } & \aReg\GETS x \SEMI \IF{b} \THEN \bReg_1 \GETS\ new \ C()  \ELSE\ \bReg_2 \GETS\ new \ D()    \SEMI y \GETS \bReg_2 \SEMI \\[-.5ex]
\mbox{Thread 3: } & b \GETS \TRUE
\end{align*}
Prima facie, the allocation operation can pick the same address for the two new objects, because only one of them occurs in any one execution.   This causes type safety to break for racy programs in the JMM, forcing~\citet{Lochbihler13} to include the type information in the address itself.

Informally, all threads satisfy the invariant that conjoins ``a creation of a C object is preceded by a read of b as true'' and ``a creation of a D object is preceded by a read of b as false''.  If composition holds, the the full program satisfies the invariant.   

Composability of safety properties provides the temporal context needed to prevent the ``pointer forging''  within a single execution.  
\end{itemize}
None of the extant memory models validate both ``implementation flexibility'' and ``ease-of-use''.  

Models that validate ``ease-of-use'' include Sequential Consistency (SC)~\citet{Lamport:1979:MMC:1311099.1311750}, \citet{Dolan:2018:BDR:3192366.3192421}, \citet{DBLP:conf/pldi/LahavVKHD17}, \citet{DBLP:conf/lics/JeffreyR16} and~\citet{BoehmOOTA}.  However, {\em all} of them invalidate reordering of independent statements.  \cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA,DBLP:conf/lics/JeffreyR16} forbid breaking of the program order from reads to writes and thus require extra fences after read actions in hardware implementations.  ~\citet{Boehm:2014:OGA:2618128.2618134} show that the RC11 model\cite{DBLP:conf/pldi/LahavVKHD17} forces a dependency or a fence between between a relaxed atomic
read and a subsequent relaxed atomic write.  


As the quote reveals, the JMM\citet{Manson:2005:JMM:1047659.1040336} was motivated by these two aims.  However, the JMM and the related models of~\citet{DBLP:conf/esop/JagadeesanPR10} and \citet{DBLP:conf/popl/KangHLVD17} invalidate compositional reasoning\footnote{We show an example to demonstrate.} It is also known that the JMM does not support reordering of independent statements.  

\paragraph{Our results. } We describe a software relaxed memory model based on pomsets whose events are decorated by logical  preconditions.   Our model satisfies the desiderata outlined earlier.

\begin{itemize}
\item The model satisfies the ``DRF criterion''.  

\item The model validates a variety of single threaded transformations including reordering of independent statements and roach motel laws for synchronization.  

We provide two forms of abstract evidence that our model supports as many sequential transformations as can be expected.  First, we show a precise relationship with standard Hoare-triples for sequential code provides abstract evidence for the support afforded for compiler  transformations of traditional sequential code.  Second, we prove a ``full abstraction'' style completeness  theorem : any two synchronization free threads that are distinguished by our model can be done so with a parallel thread that is also synchronization free. 

\item The model compiles to \armeight\ and \tso\ {\em without} any extra synchronization for raw variables.  

However, a semantic version of \mca\ in our model means that a compilation to \armseven\ or \ppc\ requires extra synchronization.  

\item The model validates compositional reasoning on safety properties.  Thus, it supports the infrastructure required to prove a realistic type safety theorem that includes racy programs without requiring that that the type information is included in the address itself.
\end{itemize}
In addition, the presentation of our model provides a simple way to adapt it to forbid the relaxing of the program order from reads to writes, thus modeling\cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA}.  Perforce, this variant p limits the compiler transformations; however, it still satisfies the properties of ``DRF'', hardware compilation and compositional reasoning. 


    

\section{Related work}

\citet{BoehmOOTA} revisits \oota.  The solution p
The work on re
2. Use\cite{BoehmOOTA} to 
classify into decreasing worlds.
           OOTA world
              Our paper
                 RC11, Boehm,LDRF






