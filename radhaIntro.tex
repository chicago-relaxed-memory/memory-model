\newcommand{\oota}{{\sc OOTA}}
\section{Introduction}
\citet{Manson:2005:JMM:1047659.1040336} identify the central problem in the design of software relaxed memory models: ``The memory model must strike a balance between ease-of-use for programmers and implementation flexibility for system designers.''   This paper proposes a solution to the problem.

In order to sharpen the criteria to evaluate memory models, we first outline desiderata  that concretize the above prescription.  

There are two dimensions to implementation flexibility, namely:
\begin{itemize}
\item The memory model should facilitate compiler transformations.    Ideally, the model should support the known transformations used to optimize  synchronization free single threaded code.  A canonical example is the  commuting of independent statements.

\item Compiling to hardware models.  The model should be realizable on modern hardware with minimal synchronization.  A canonical example is that the relaxed atomics of C11 (or the raw variables of Java) should not require any extra synchronization.
\end{itemize}

There are two dimensions to ``ease-of-use'', namely:
\begin{itemize}
\item The ``DRF'' criterion~\cite{DBLP:journals/tpds/AdveH93, DBLP:conf/isca/AdveH90} permits the programmer to forget about relaxed memory for correctly synchronized programs without data races.  

\item All programs, racy or not,  should support compositional reasoning on safety properties~\cite{PnueliSafety,Misra:1981:PNP:1313338.1313770,StarkSafety,Abadi:1993:CS:151646.151649}.  The simplest form of such a composition principle, addressing only temporal invariants is:
\[
  \frac{
      \afo, \aPSS_1 \models\afo
      \qquad
      \afo, \aPSS_2 \models\afo
    }{\aPSS_1 \parallel \aPSS_2 \models \afo}
\]
where $\afo$ is a temporal safety property on read and write actions, and $\afo, \aPSS_1 \models\afo$ indicates that $\aPSS_1$ satisfies $\afo$ if the environment satisfies $\afo$.  This cyclical compositional proof rule permits us to reason separately about individual threads. 
\end{itemize}
We illustrate the last criterion, perhaps novel in this context, with examples.   
\begin{itemize}
\item ``Out Of Thin Air''(\oota)  violates the principle.  For example, consider the program:
\begin{align*}
& \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI  \\[-.5ex]
\mbox{Thread 1: } & y\GETS x \\[-.5ex]
\mbox{Thread 2: } & x \GETS y
\end{align*}
Informally, both threads satisfy the invariant that conjoins ``A write of 1  to x  requires a prior read  of 1 from y'' and ``A write of 1  to y  requires a prior read  of 1 from x ''.  If composition holds, the full program satisfies the invariant.  Since the variable declaration closes the program from other writes to $x,y$, we  deduce the conjunction of  ``A write of 1  to x  requires a prior write  of 1 to x'' and ``A write of 1  to y  requires a prior write  of 1 from x'' . Thus, we deduce that ``A write of 1  to x  requires a prior write  of 1 to x'', and consequently ``there is no write of 1 to x''. 

Composability  of safety properties provides an  objectively {\em falsifiable} measurement of \oota\ in a memory model. 

\item   ~\citet{DBLP:journals/toplas/Lochbihler13} considers a racy program:
\begin{align*}
& \VAR x\GETS null \SEMI \VAR y\GETS null  \SEMI \VAR b\GETS \FALSE \SEMI  \\[-.5ex]
\mbox{Thread 1: } & x \GETS y \\[-.5ex]
\mbox{Thread 2: } & \aReg\GETS x \SEMI \IF{b} \THEN \bReg_1 \GETS\ new \ C()  \ELSE\ \bReg_2 \GETS\ new \ D()    \SEMI y \GETS \bReg_2 \SEMI \\[-.5ex]
\mbox{Thread 3: } & b \GETS \TRUE
\end{align*}
Prima facie, the allocation operation can pick the same address for the two new objects, because only one of them occurs in any one execution.   This causes type safety to break for racy programs in the JMM, forcing~\citet{Lochbihler13} to include the type information in the address itself.

Informally, all threads satisfy the invariant that conjoins ``a creation of a C object is preceded by a read of b as true'' and ``a creation of a D object is preceded by a read of b as false''.  If composition holds, the the full program satisfies the invariant.   

Composability of safety properties provides the temporal context needed to prevent the ``pointer forging''  within a single execution.  
\end{itemize}
None of the extant memory models validate both ``implementation flexibility'' and ``ease-of-use''.  

Models that validate ``ease-of-use'' include Sequential Consistency (SC)~\citet{Lamport:1979:MMC:1311099.1311750}, \citet{Dolan:2018:BDR:3192366.3192421}, \citet{RC11refs}, \citet{DBLP:conf/lics/JeffreyR16} and~\citet{BoehmOOTA}.  All of them invalidate reordering of independent statements; they forbid breaking of the program order from reads to writes and thus require extra fences for read actions in hardware implementations.

The JMM\citet{Manson:2005:JMM:1047659.1040336} and the related models of~\citet{DBLP:conf/esop/JagadeesanPR10} and \citet{DBLP:conf/popl/KangHLVD17} invalidate compositional reasoning.    It is also known that the JMM does not support reordering of independent statements.  

Two comments:
1. Clarify implementability of \citet{DBLP:conf/lics/JeffreyR16}.
2. Use\cite{BoehmOOTA} to 
classify into decreasing worlds.
           OOTA world
              Our paper
                 RC11, Boehm,LDRF






