\section{Efficient Implementation on ARMv8}
\label{sec:imm}


\begin{verbatim}
Operation        Implementation
Relaxed read     ldr                     
Relaxed write    str             
Acquiring read   ldar            
Releasing write  stlr
Fence            dmb.sy
\end{verbatim}

\begin{verbatim}
ob does not contradict eco

ob does not contradict (co cap po):

Suppose that wx1 po wx2 then it cannot be that wx2 ob wx1.
We know that wx1 co wx2 by SC-PER-LOC

% Case 1. w1 is read externally, then we have
%   wx1 rfe r
% and
%   r fre w2
% so
%   wx1 obs+ wx2
% which contradicts EXTERNAL

% Case 2. wx1 is not read externally.
We show this by contradiction
Assume
  wx1 co wx2
and
  wx2 ob wx1

Note that
  po supseteq dob cup aob cup bob
So in order to get order into wx1, we must have
  wx2 (ob?; obs; ob?; obs; ob?) wx1

Note that we cannot have dob or bob into wx1 after obs, since then we would
also have it into wx2, creating a cycle in EXTERNAL.  This holds because both
dob and bob are closed on the right w.r.t. coi

So it must be that 
  wx2 (ob?; obs; ob?; wx0; coe) wx1, 
in which case we also have wx0 coe wx2, contradicting EXTERNAL
or 
  wx2 (ob?; obs; ob?; rx0; fre) wx1
in which case we also have rx0 fre wx2, contradicting EXTERNAL




Internal reads do not need to respect ob:
Arm allows the following:

  Ra1 -ctrl-> Wx1 -rfi-> Rx1 ---> Wb1    if(a){x=1}; b=x
   |                               |
  Wa1 <-------------------------- Rb1    a=b


Suppose that wx1 po rx2 and rx2 is read externally.
Then it cannot be that rx2 ob wx1.

Case 1: if wx1 co wx2, then we have wx1 coe wx2 rfe rx2, contradicting EXTERNAL
Case 2: if wx2 co wx1, then we have rx2 fr wx1, contradicting SC-PER-LOC



Suppose that rx1 po wx2 and rx1 is read externally.
Then it cannot be that wx2 ob rx1.

Case 1: if wx2 co wx1, then wx2 co wx1 rf rx1 po wx2, contradicting SC-PER-LOC 
Case 2: if wx1 co wx2, for a contradiction, suppose wx2 ob rx1.
then we need another thread involved to get order from wx2 to rx1.
To get order into the read, there are several options:
- use cross thread read, then dob; but dob does not include reads in it's domain.
  An attempt to do this is something like:

              Wx1                 x=1
               |
  Ra2 -ctrl-> Rx1 - - -> Wx2      if(a){r=x}; x=2
   |                      |
  Wa2 <----------------- Rx2      a=x

  But the ctrl dependency is not included in ob between reads.
- use cross thread read then barrier, but then you contradict EXTERNAL
- create and ob edge from Rx2 to Wx1.
  An attempt to do this is, 

  Wx1 <-------------- Ra1       
   |                   |        But cannot get Wx2 --> Wa1 without a barrier
  Rx1 - - -> Wx2 ---> Wa1       

  Wx1 <----- Rx2                         
   |          |                 contradicts SC-PER-LOC 
  Rx1 - - -> Wx2                         


Other examples to type in:
Allowed:
Rx1 -> Wy0  Wy1
Ry1 -> Wz0  Wz1
Rz1 -> Wx0  Wx1

Forbidden:
Rx1 -> Wy0 Wy1
Ry1 -> Wx0 Wx1

\end{verbatim}


\citet{DBLP:journals/pacmpl/PodkopaevLV19} define the \emph{Intermediate
  Memory Model (IMM)} and provide efficient implementations of the IMM into
several processor architectures, including TSO, ARMv8 and Power.

In this section, we show that any execution allowed by a sublanguage of the
IMM is also allowed by our semantics.  The sublanguage we consider bans
loops, read-modify-write (RMW) operations, and fences.  In addition, we take
the set of memory locations, $\Loc$, to be finite.  Syntactically, we drop
the superscript \textsf{rlx} on relaxed reads and writes; in addition, we use
structured conditionals rather than the more general \textsf{goto}.  We refer
to this sublanguage as $\muIMM$.

$\muIMM$ programs sit in the restriction-free fragment of our language, where
all memory locations are initialized to $0$ and parallel-composition occurs
only at top level.  In other words, $\muIMM$ programs have the form
\begin{displaymath}
  {\aLoc_1}\GETS{0}\SEMI
  \cdots\SEMI
  {\aLoc_m}\GETS{0}\SEMI
  (\aCmd^1 \PAR \cdots \PAR \aCmd^n)
\end{displaymath}
where $\aCmd^1$, \ldots, $\aCmd^n$ do not include either composition or
restriction.

Due to space limitations, we do not include a full description of the IMM.
The broad strokes of the argument given here should be clear, but interested
readers will need to refer to \citep{DBLP:journals/pacmpl/PodkopaevLV19} for
details.

Let $G$ be an execution graph for a $\muIMM$ program satisfying the
consistency requirements in \textsection3.4 of
\citep{DBLP:journals/pacmpl/PodkopaevLV19}. (Because the source language
lacks RMW operations, the ``is exclusive'' flag on every read will be
\textsf{not-ex} and the RMW mode on every write will be \textsf{normal}.)

Let $R^*$ denotes the reflexive and transitive closure of relation $R$.  Let
$R;S$ denote the composition of relations $R$ and $S$.

Given an execution graph $G$, we say that $\aEv$ is an \emph{internal read} if
$\aEv\in\fcodom(G.\mathsf{po}\cap G.\mathsf{rf})$.

From $G$ we construct a candidate pomset $\aPS$ as follows:
\begin{itemize}
\item $\Event= G.\textsf{E}$,
\item $\labelingAct(\aEv)=\tau G.\mathsf{lab}(e)$, if $\aEv$ is a relaxed
  internal read, 
\item $\labelingAct(\aEv)=G.\mathsf{lab}(e)$, if $\aEv$ is not a relaxed
  internal read,
\item $\labelingForm(\aEv)=\TRUE$,
\item ${\leq} = G.{\rar}^*$, and
\item ${\gtN} = {\leq} \cup {\leq}; {G.{\reco}} \cup {G.{\reco}} ; {\leq}$
\end{itemize}

We show that $\aPS$ is a top-level pomset, reasoning as follows.
First, we establish the criteria for a 3-valued pomset (Definition~\ref{def:3valued}).
\begin{itemize}
\item ${\le}$ is a partial order.  This holds since $G.{\rar}$ is acyclic.
\item If $\bEv \le \aEv$ then $\bEv \gtN \aEv$.  By construction.
\item If $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then $\bEv = \aEv$.  ????
\item If $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$ then
  $\cEv \gtN \aEv$. By construction.
\end{itemize}

Next, we establish the criteria for a 3-valued pomset with preconditions (Definition~\ref{def:3pre}).
\begin{itemize}
\item $\labelingForm(\aEv)$ implies $\labelingForm(\bEv)$ whenever
  $\bEv\le\aEv$.   Trivial, since every formula is $\TRUE$.
\item $\aPS$ is $\aLoc$-coherent; that is, when restricted to events that
  read or write $\aLoc$, $\gtN$ forms a partial order.
\end{itemize}

Finally, we establish the criteria for a top-level pomset
(Definition~\ref{def:x-closed}).
\begin{itemize}
\item $\aEv$ is location independent. Trivial, since every formula is $\TRUE$.
\item If $\aEv$ reads $\aVal$ from $\aLoc$, then there is some $\bEv$ such that
  \begin{itemize}
  \item $\bEv \lt \aEv$,  
  \item $\bEv$ writes $\aVal$ to $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\cEv \gtN \bEv$ or $\aEv \gtN \cEv$.
  \end{itemize}    
\end{itemize}
