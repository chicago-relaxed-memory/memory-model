\section{Conclusions and Related Work}
\label{sec:outro}
\textsc{weakestmo} \cite{DBLP:journals/pacmpl/ChakrabortyV19, DBLP:journals/corr/abs-1911-06567}.

loop unrolling and sequential composition are a challenge when register can be
used more than once in an execution.

A memory consistency model for a shared-memory multiprocessor defines the
values that a read may return.  For a survey of hardware models, see
\citep{AlglaveThesis}. For software models, see
\citep{DBLP:journals/toplas/Lochbihler13,DBLP:phd/ethos/Batty15}.  For an
attempt to bridge the two, see \citep{DBLP:journals/pacmpl/PodkopaevLV19}.

We have defined a relaxed memory model, using standard tools from the
semantics and demonstrated that it satisfies the fundamental criterion for
software memory models, namely ``the memory model must strike a balance
between ease-of-use for programmers and implementation flexibility for system
designers.''

One key lesson we draw is that any software relaxed memory model should
support the cyclical composition proof rule of
\citet{Abadi:1993:CS:151646.151649} for temporal properties.  We posit that all
the benefits of \oota, such as typing guarantees, can be derived from this
principle. 

We conclude with a suggestion for the consideration of programming language
designers.  The semantics of a programming language should support a clear
and executable prescription of dependency in a program.  Such a specification
provides a nice interface between the language user and the compiler writer,
and a clear bridge from the compiler writer to architectures.

Our current paper is to be viewed as a step towards this goal.  We will
explore developing an executable specification based on these ideas in future
work.

A memory consistency model for a shared-memory multiprocessor defines the
values that a read may return.  For a survey of hardware models, see
\citep{AlglaveThesis}. For software models, see
\citep{DBLP:journals/toplas/Lochbihler13,DBLP:phd/ethos/Batty15}.  For an
attempt to bridge the two, see \citep{DBLP:journals/pacmpl/PodkopaevLV19}.

Use of MCA can be separated out to develop a model for weaker architectures
and distributed systems such as PPC.

The central challenge in software models is to relax order enough to allow
efficient implementation without admitting anomalous behaviors---called
\emph{out of thin air} \oota\ in the literature
\cite{DBLP:conf/esop/BattyMNPS15,BoehmOOTA}---such as
\citeauthor{DBLP:journals/toplas/Lochbihler13}'s type unsafety example.

One of our contributions is to articulate the goal of compositional reasoning
using safety properties, which suffices to forbid anomalous behavior.  \oota\
is a famously elusive creature, and thus is hence hard to prove or disprove.
Support of a model for a compositional proof principle, instead, is
objectively provable or falsifiable.

Our work strikes an unusual balance: Unlike Java and related models
\cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17},
we support compositional reasoning for safety properties
(\textsection\ref{sec:logic}).  Unlike models that invalidate load buffering
\cite{Dolan:2018:BDR:3192366.3192421,BoehmOOTA,DBLP:conf/pldi/LahavVKHD17},
we do not require fences for relaxed access on \mca\ architectures, such as
\armeight.

Optimizations and hoare logic!

Our approach follows several attempts to solve the problem within the
framework of true concurrency
\cite{DBLP:conf/lics/JeffreyR16,Pichon-Pharabod:2016:CSR:2837614.2837616,DBLP:conf/esop/CenciarelliKS07}.




% We have already discussed related work in context earlier in the paper.
% Here, we discuss in more detail the relationship with the most closely
% related work.

\paragraph{Memory Models Via Program Transformations.}
We Discuss prior approaches to definining memory models using program
transformations in chronological order.  The general flavor in these
approaches is to consider SC executions, albeit with the threads subject to
sequential program transformation.

\citet{Saraswat:2007:TMM:1229428.1229469}
aimed to describe a \jmm-like model this way.  \drfsc\ holds, but \citet{SP} 
discovered that it permits \oota\ behavior.

\citet{DBLP:conf/esop/FerreiraFS10} described a relaxed memory model as being
parametrized by available program transformations.  They showed \drfsc, but do not
study \oota, relate to concrete models, or demonstrate compilation results.

\citet{DBLP:conf/popl/DemangeLZJPV13} developed \textsc{bmm}, a model whose only
permitted reordering is of a relaxed write with a following relaxed read.
The paper develops an axiomatic and studies effects on compilation.  By
design, it is designed as a restriction of the \jmm\ that invalidates several
compiler optimizations.

\citet{DBLP:conf/fm/LahavV16} characterized \tso\ as being derived by
considering Write-Read (\textsc{wr}) reordering and Read-After-Write (\textsc{raw})
elimination.  They also showed that the release acquires of C11 are less
expressive than considering \textsc{wr}, \textsc{raw} and thread-inlining.  Our paper is
inspired by their implicit challenge: ``Some memory models can be defined via
transformations.  But there is more to weak memory than transformations.''

% \paragraph{Modeling the Invalidation of Load Buffering.} 

% In this paragraph, we argue that our paper is relevant even to the reader
% who desires a semantics that invalidates ``load buffering,'' or ``reads from the future.''
% There are two related lines of research that suggest to prohibit the
% reordering of loads with following stores.
% \begin{itemize}
% \item \citet{Dolan:2018:BDR:3192366.3192421} imposed this restriction in
%   order to ``bound data races in space and time.''
%   Consider the following program:
%   % In the following program $r,s$ are registers, and $x,y,z,u,v,w$
%   % are shared variables.
%   % \begin{align*}
%   %   & (u \GETS 0 \SEMI y \GETS 1 \SEMI v\REL  \GETS 1 \SEMI z \GETS 2 \SEMI r \GETS u \SEMI y \GETS 3) \\[-.5ex]
%   %   \PAR & (y \GETS 2 \SEMI  \IF{v\ACQ} \THEN w \GETS 1 + y -y \SEMI u \GETS 1 \SEMI x \GETS 1  \FI \SEMI s \GETS u \SEMI  y \GETS 2)
%   % \end{align*}
% \begin{displaymatharrayrl}
%   &x\GETS1\SEMI y\GETS1\SEMI v\REL\GETS1\SEMI z\GETS1\SEMI
%   \IF{w}\THEN x\GETS2\FI
%   \\\PAR
%   &y\GETS2\SEMI \aReg{}\GETS v\ACQ\SEMI z\GETS2\,\SEMI
%   \IF{\aReg{}}\THEN w\GETS{y-y+x}\FI
% \end{displaymatharrayrl}
% \begin{displaymath}
%     \begin{tikzpicture}[node distance=1.2em and .8em,baselinecenter]
%     \event{a1}{\DW{x}{1}}{}
%     \event{a2}{\DW{y}{1}}{right=of a1}
%     \event{a3}{\DWRel{v}{1}}{right=of a2}
%     \event{a4}{\DW{z}{1}}{right=of a3}
%     \pox{a1}{a2}
%     \pox{a2}{a3}
%     \pox{a3}{a4}
%     \event{b1}{\DW{y}{2}}{below=of a2}
%     \event{b2}{\DRAcq{v}{1}}{below=of a3}
%     \event{b3}{\DW{z}{2}}{right=of b2}
%     %\co{b1}[right]{a2}
%     \event{b4}{\DR{y}{?}}{right=of b3}
%     \event{b5}{\DR{y}{?}}{right=of b4}
%     %\co{b3}[right]{a4}
%     \event{b6}{\DR{x}{1}}{right=of b5}
%     \pox{b1}{b2}
%     \pox{b2}{b3}
%     \pox{b3}{b4}
%     \pox{b4}{b5}
%     \pox{b5}{b6}
%     \rf{a3}{b2}
%     \event{b7}{\DW{w}{1}}{right=of b6}
%     \event{a5}{\DR{w}{1}}{above=of b7}
%     \event{a6}{\DW{x}{2}}{right=of a5}
%     \pox{a4}{a5}
%     \pox{a5}{a6}
%     \pox{b6}{b7}
%     \rf{b7}{a5}
%     \rf[out=-18,in=162]{a1}{b6}
%     %\race{b7}{a5}
%     %\race{a6}{b6}
%   \end{tikzpicture}
% \end{displaymath}
% In their model, one can deduce that $w$ must be assigned $1$, despite the
% past race on $y$, concurrent race on $z$ and future race on $x$.
% % In their model, one can reason sequentially about the the assignment to $w$
% % and deduce that $x=1$ implies $z= 1$ despite the concurrent races on $u$, and
% % the past and future races on $y$, where past and future are stated with
% % respect to the assignment to $w$.

% \item In the C11 family of models, eg. see
%   \citep{Boehm:2014:OGA:2618128.2618134,DBLP:conf/pldi/LahavVKHD17,DBLP:conf/oopsla/VafeiadisN13},
%   load buffering is forbidden to avoid \oota. The elegant discussion in
%   \citet{BoehmOOTA} elucidates the issues via a series of ``\oota'' like
%   examples.  In particular, to rule out example~\ref{rfub}.
% \end{itemize}

% Our model can easily capture models that forbid load buffering.  It
% necessitates two changes.
% \begin{itemize}
% \item Modify the semantic rule for read to remove the possibility of an
%   internal read:
%   \begin{align*}
%     \sem{\aReg\GETS\REF{\cExp}\SEMI \aCmd} & =
%     \textstyle\bigcup_{\aLoc=\REF{\bVal}}\; ({\cExp}=\bVal) \guard \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] 
%   \end{align*}
% \item Modify item \ref{pre-read}b in the definition of prefixing to require
%   order from a read to subsequent write.  Item \ref{pre-read}b$'$ becomes: if
%   $\aEv$ is a write then $\cEv\lt'\aEv$.  In \ref{pre-read}b$'$ we removed
%   the ``or or $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)$.''
% \end{itemize}

% While \citet{Dolan:2018:BDR:3192366.3192421} already describes DRF and the
% compilation to \armeight, our approach yields the following new insights.
% \begin{itemize}
% \item Compositional treatment of temporal invariants
%   from \textsection\ref{sec:logic} holds mutatis mutandis, since all
%   executions of the restricted model are already accounted for in the general
%   model.

% \item With regards to single-threaded optimizations in
%   \textsection\ref{sec:opt}, our approach provides different methods to prove
%   optimizations, which complement the extant methods of
%   \citet{Dolan:2018:BDR:3192366.3192421} with data sensitivity; for example,
%   our methods provides a simple proof of the transformation of
%   $\IF{\aExp}\THEN x \GETS 1 \SEMI \aCmd \ELSE x\GETS 1 \SEMI \bCmd\FI$ to
%   $x \GETS 1 \SEMI \IF{\aExp}\THEN \aCmd \ELSE \bCmd\FI$.

% \end{itemize}

\paragraph{Relationship to Models of Speculation.}
\citet{2019-sp} is a close formal cousin to our approach.  In the spectrum
from micro architectures to architectures to software,whereas \citet{2019-sp}
lies between the micro and architectural levels, we aim to be as abstract as
possible to bridge the gap to programming languages.  This is reflected in
the several differences in the formal model.

We consider a single global acyclic order in contrast to the two studied in
\citet{2019-sp}.  We do not track false branches of conditionals, as seen in
our monotonicity axiom, whereby any event with a precondition $\FALSE$ can
only have $\FALSE$ successors in $\lt$, whereas in that paper, speculation on
false branches can lead to observable effects.  We are also less accurate
about tracking reads, as reflected in the removal of program order between
reads and reads.

\citet{2019-sp} does not study the properties as a memory model.  We
conjecture that our proofs of DRF and compositional reasoning can be carried
over to that setting. \citet{2019-sp} also preserves some $\rpox$ between
reads, whereas we do not; so, we certainly support more compiler
optimizations of single threaded code.

\citet{2019-sp} allow the three-location execution at the end of
\textsection\ref{sec:model}, but disallow the two-location variant.  This odd
behavior stems from the semi-transitivity of three-valued pomsets, inherited
from \citet{DBLP:journals/dc/Lamport86}.






% \section{Conclusions}
% We have defined a relaxed memory model, using standard tools from the
% semantics and demonstrated that it satisfies the fundamental criterion for
% software memory models, namely ``the memory model must strike a balance
% between ease-of-use for programmers and implementation flexibility for system
% designers.''

% One key lesson we draw is that any software relaxed memory model should
% support the cyclical composition proof rule of
% \citet{Abadi:1993:CS:151646.151649} for temporal properties.  We posit that all
% the benefits of \oota, such as typing guarantees, can be derived from this
% principle. 

% We conclude with a suggestion for the consideration of programming language
% designers.  The semantics of a programming language should support a clear
% and executable prescription of dependency in a program.  Such a specification
% provides a nice interface between the language user and the compiler writer,
% and a clear bridge from the compiler writer to architectures.

% Our current paper is to be viewed as a step towards this goal.  We will
% explore developing an executable specification based on these ideas in future
% work.
 


\section{SCRAPS}

Some \oota\ examples can be proven if we extend the logic with value
quantification---we leave the details to future work.  Consider
\cite[(\textsc{rng})]{DBLP:conf/esop/SvendsenPDLV18}:
\begin{gather*}
  % \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI %\\[-.5ex]
  \begin{aligned}
    ( y\GETS x+1
    \PAR
    x\GETS y ) && \hbox{\begin{tikzinline}[node distance=1em]
        \event{rx}{\DR{x}{1}}{}
        \event{wy}{\DW{y}{2}}{right=of rx}
        \po{rx}{wy}
        \event{ry}{\DR{y}{1}}{right=3em of wy}
        \event{wx}{\DW{x}{1}}{right=of ry}
        \po{ry}{wx}
        % \rf{wy}{ry}
        \rf[out=170,in=10]{wx}{rx}
      \end{tikzinline}}
  \end{aligned}
  \\
  \hbox{$
    \begin{gathered}
      [\forall u,v.\;(\once\DW{y}{u} \land \once\DW{y}{v}) \Rightarrow ((u \EQ v) \vee (u \EQ 0) \vee (v \EQ 0))]
      \\[-.5ex]
      \land [\DW{x}{1} \Rightarrow \once\DR{y}{1}]
      \land [\DW{y}{2} \Rightarrow \once\DR{x}{1}]
      % \land [\DW{z}{2} \Rightarrow \once\DR{y}{2}]
    \end{gathered}$}
\end{gather*}
% \begin{displaymath}
%   \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI \VAR z\GETS0\SEMI  %\\[-.5ex]
%   (
%     y\GETS x+1\SEMI z \GETS y
%   \PAR
%     x\GETS y
%     %   )
% \end{displaymath}
% \begin{scope}
%   \small
%   \begin{gather*}
%     [(\once\DW{y}{v_1} \land \once\DW{y}{v_2}) \Rightarrow ((v_1 = v_2) \vee (v_1 = 0) \vee (v_2 = 0))] \land\\[-.5ex]
%     [\once\DW{x}{1} \Rightarrow \once\DR{y}{1}] \land [\once\DW{y}{2}
%     \Rightarrow \once\DR{x}{1}] \land [\once\DW{z}{2} \Rightarrow
%     \once\DR{y}{2}]
%   \end{gather*}
% \end{scope}
The attempted execution is disallowed since there is no write to fulfill
$\DR{y}{1}$.  Closing $x$ and $y$ and using the last two conjuncts in the
invariant above:
% last conjunct, we have
% \begin{math}
%   % \once\DW{z}{2} \Rightarrow \once\DR{y}{2}
%   % \once\DW{z}{2} \Rightarrow \once\DW{y}{2}
%   \DW{y}{2} \Rightarrow \once\DR{x}{1}.
% \end{math}
% Closing $x$, we then have
\begin{math}
  % \once\DW{z}{2} \Rightarrow \once\DW{x}{1}
  \DW{y}{2} \Rightarrow \once\DW{y}{1}.
\end{math}
From the first conjunct, we then derive
\begin{math}
  \DW{y}{2} \Rightarrow \FALSE,
\end{math}
as required.

Other \oota\ examples may require that we extend the logic to deal with
intervening writes or coherence. The following outcome is allowed by the
promising semantics \cite{DBLP:conf/popl/KangHLVD17}, but not in \weakestmo{}
\cite[Fig.~3]{DBLP:journals/pacmpl/ChakrabortyV19} nor in our semantics, due
to the cycle:
\begin{gather*}
  \label{weakestmo}
  x\GETS 2\SEMI
  \IF{x\NOTEQ2}\THEN y\GETS 1 \FI
  \PAR
  x\GETS 1\SEMI
  r\GETS x\SEMI
  \IF{y}\THEN x\GETS 3 \FI
  \\\nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{wx2}{\DW{x}{2}}{}
  \event{rx3}{\DR{x}{3}}{right=of wx2}
  \event{wy1}{\DW{y}{1}}{right=of rx3}
  \po{rx3}{wy1}
  \event{wx1}{\DW{x}{1}}{right=2em of wy1}
  \event{rx2}{\DR{x}{2}}{right=of wx1}
  \wk{wx1}{rx2}
  \event{ry1}{\DR{y}{1}}{right=of rx2}
  \event{wx3}{\DW{x}{3}}{right=of ry1}
  \po{ry1}{wx3}
  \wk[in=165,out=15]{rx2}{wx3}
  \rf[in=-170,out=-10]{wy1}{ry1}
  \rf[in=170,out=10]{wx2}{rx2}
  \rf[out=-170,in=-10]{wx3}{rx3}
  \wk[out=-170,in=-10]{wx1}{wx2}
  \wk{wx2}{rx3}
    \end{tikzinline}}
\end{gather*}


\subsection{RFUB}
Let $\aCmd$ be the right thread in \eqref{rfub}.
\begin{align*}
  \aCmd = r\GETS y\SEMI \IF{r \NOTEQ 1} \THEN z\GETS 1\SEMI r\GETS 1\FI  \SEMI x\GETS r 
\end{align*}
Then, $\hoare{\TRUE}{\aCmd}{x=1} $ and $\hoare{y \neq 1}{\bCmd}{z=1}$.  Thus, the traditional sequential semantics {\em does not} attribute any cause for the write of $1$ to $x$, as seen by the execution:
\begin{tikzdisplay}[node distance=1em]
 \event{ry}{\DR{y}{1}}{}
 \event{wx}{\DW{x}{1}}{right=of ry}
 \event{wa}{\DW{z}{1}}{below=of rx}
 \rf{ry}{wa}
\end{tikzdisplay}
Consider the
following, where all locations are initialized to $0$.  In \textsection\ref{sec:logic} we provide machinery to prove that \oota{} is
incapable of writing $1$.  The question is whether this should be possible
for \rfub, which changes \oota{} only to include a \emph{Register assignment
  From an Unexecuted Branch} \cite{BoehmOOTA}:?  
\begin{align*}
  \label{oota}  \tag{\textsc{oota}}
  y\GETS x
  \PAR&
  r\GETS y\SEMI
  x\GETS r
  \\
  \tag{\rfub1}
  \label{rfub}
  y\GETS x
  \PAR&
  r\GETS y\SEMI
  \IF{r \NOTEQ 1} \THEN z\GETS 1\SEMI r\GETS 1\FI  \SEMI x\GETS r 
\end{align*}
%and the following \emph{Out Of Thin Air} litmus test:
The change in the second
thread from \oota{} to \rfub{} is not a valid refinement under Hoare logic:
\rfub{} validates the triple $\hoare{\TRUE}{\aCmd}{x=1}$, but \oota{} does
not.  As a result, it is expected that \rfub{} may have additional behaviors.

The program writes $1$ to $x$ in both branches of the conditional.  Further,
the writes to $z$ and $x$ in the then-branch of the conditional are
independent.  Therefore, it is sensible for a compiler to hoist the write to
$x$ out of the conditional.  In our semantics, there is no dependency from
the read of $y$ to the write to $x$
The execution in question is:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|
  (\DR{y}{1})
  \prefix
  \left(
    \begin{tikzcenter}[node distance=.5em]
      \event{b1}{r\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
    \end{tikzcenter}
    % \begin{tikzcenter}[node distance=.5em]
    %   \event{b1}{r\NOTEQ1\mid\DW{z}{1}}{}
    %   \event{b2}{r\NOTEQ1\mid\DW{x}{1}}{right=of b1}
    % \end{tikzcenter}
    % \biggm\|
    % \begin{tikzcenter}[node distance=1em]
    %   \event{c1}{r\EQ1\mid\DW{x}{1}}{}
    % \end{tikzcenter}
  \right)
\end{displaymathsmall}
With an internal read of $y$, we have:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|
    \begin{tikzcenter}[node distance=1em]
      \event{b1}{y\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
    \end{tikzcenter}
\end{displaymathsmall}
but the precondition $y\NOTEQ1$ cannot be satisfied locally.
With an external read of $(\DR{y}{1})$, we can discharge the precondition, but in this
case, the predicate becomes $1\NOTEQ 1$. 
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{right=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|  
    \begin{tikzcenter}[node distance=1em]
      \nonevent{b1}{1\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{right=of b1}
      \event{b0}{\DR{y}{1}}{left=of b1}
      \po{b0}{b1}
    \end{tikzcenter}
\end{displaymathsmall}


