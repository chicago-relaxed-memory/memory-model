\section{Additional Features}
\label{sec:variants}

\paragraph{Explicit Internal Actions}

The explicit use of internal actions facilitate the translation to \armeight\
(\textsection\ref{sec:arm}) and the definitions required in the proof of
\drfsc\ (\textsection\ref{sec:sc}).

Add condition to validate DRF.
\begin{itemize}
\item[5e.] if $\cEv$ internally reads from $\aLoc$, $\labelingForm(\aEv)$ is
  not independent of $\aLoc$, and $\aEv$ writes, then $\cEv\lt'\aEv$.
\end{itemize}

In defining \emph{data races} (and thus in the proof of \drfsc) it is
important to position internal actions relative to synchronization actions.
For example, the following execution is consider data-race free.
\begin{displaymath}
  x\GETS1\SEMI
  \aReg\GETS x \SEMI
  y\REL\GETS 1 \SEMI
  \PAR
  \bReg\GETS y\ACQ \SEMI
  x\GETS 2
\end{displaymath}
\begin{tikzdisplay}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \internal{a2}{\DR{x}{}}{right=of a1}
  %\graypo{a1}{a2}
  \event{a3}{\DWRel{y}{1}}{right=of a2}
  \graypo{a2}{a3}
  \po[bend left]{a1}{a3}
  \event{b1}{\DRAcq{y}{1}}{right=3em of a3}
  \rf{a3}{b1}
  \event{b2}{\DW{x}{2}}{right=of b1}
  \po{b1}{b2}
\end{tikzdisplay}
However, if we commute the read of $x$ and the release of $y$, the resulting
program has a data race.
% \begin{displaymath}
%   x\GETS0\SEMI
%   x\GETS1\SEMI
%   \aReg\GETS x \SEMI
%   y\REL\GETS 1 \SEMI
%   z\GETS\aReg
%   \PAR
%   \bReg\GETS z\ACQ \SEMI
%   \cReg\GETS x
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{a0}{\DW{x}{0}}{left=of a1}
%   \wk{a0}{a1}
%   \internal{a2}{\DR{x}{1}}{right=of a1}
%   \graypo{a1}{a2}
%    \event{a3}{\DWRel{y}{1}}{right=of a2}
%   \graypo{a2}{a3}
%   \po[bend left]{a1}{a3}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   \graypo[bend left]{a2}{a4}
%   \event{b1}{\DRAcq{z}{1}}{below=of a4}
%   \rf{a4}{b1}
%   \event{b2}{\DR{x}{0}}{left=8em of b1}
%   \po{b1}{b2}
%   \wk{b2}{a1}
%   \wk{a0}{b2}
% \end{tikzdisplay}


\paragraph{Address Calculation}

Definition of data model:
\begin{itemize}
\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations or the operator $\REF{\aExp}$,
\end{itemize}

\begin{align*}
\aCmd,\,\bCmd
\BNFDEF& \cdots
\BNFSEP \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
\BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
\end{align*}

\begin{align*}
  \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; \textstyle\bigcup_\aVal\; ({\cExp}=\cVal \mid \DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] 
  \\ & \mkern2mu\cup \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid\iDRmode{\aLoc}{\aVal}) \prefix \sem{\aCmd}[\aLoc/\aReg]
  \\
  \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
  \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; \textstyle\bigcup_\aVal\; ({\cExp}=\cVal \land \aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
  \\ & \mkern2mu\cup \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid \iDWmode{\aLoc}{\aVal}) \prefix \sem{\aCmd}[\aExp/\aLoc]  
\end{align*}

\paragraph{Fences}

All fence actions are internal, do not read or write.
\begin{align*}
  \fmode \BNFDEF& \modeREL \BNFSEP \modeACQ \BNFSEP \modeSC
  \\
  \aCmd,\,\bCmd
  \BNFDEF& \cdots
  \BNFSEP \FENCE^{\fmode} \SEMI \aCmd  
\end{align*}

\begin{align*}
  \sem{\FENCE\SEMI \aCmd} & =
  (\DF{}) \prefix \sem{\aCmd}
\end{align*}

\paragraph{Read-Modify-Write}

% \section{Variations}

% \citet{2019-sp} define \emph{3-valued pomsets with preconditions} to model
% security flaws that arise from speculative evaluation in computer
% microarchitecture (such as Spectre \cite{DBLP:journals/corr/abs-1801-01203}).
% \begin{definition}
%   %\label{def:3valued}
%   A \emph{3-valued pomset with preconditions} is a tuple
%   $(\Event, {\le}, {\gtN}, \labeling)$, such that
%   \begin{itemize}
%   \item $\Event$ is a set of \emph{states},
%   \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
%   \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
%   \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
%     \begin{itemize}
%     \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$, \hfill
%       (Inclusion)
%     \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then
%       $\bEv = \aEv$, and \hfill (Consistency)
%     \item\label{5c} if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$
%       then $\cEv \gtN \aEv$.  \hfill (Semi-transitivity)
%     \end{itemize}
%   \end{itemize}

%   A \emph{(memory model) pomset} is a 3-valued pomset with preconditions,
%   such that
%   \begin{itemize}
%   \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
%     $\labelingForm(\bEv)$, and \hfill (Causal-strengthening)
%   \end{itemize}
% \end{definition}
% The axioms for $\gtN$ are adapted
% from~\citet[A1--A3]{DBLP:journals/dc/Lamport86}.  

% \begin{definition}
%   A pomset \emph{coherent} if, when restricted to events that read or write
%   any single location $\aLoc$, $\gtN$ forms a partial order.
% \end{definition}
