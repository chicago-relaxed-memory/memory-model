\section{Examples and Extensions}
\label{sec:variants}
\citet{PughWebsite} developed a set of twenty {causality test cases} in the
process of revising the Java Memory Model (JMM)
\cite{Manson:2005:JMM:1047659.1040336}.  Using hand calculation, we have
confirmed that our model gives the desired result for all twenty cases,
unrolling loops as necessary.
% confirmed that our model gives the desired result these test cases, with the
% following caveats: to model TC14 and TC15 we must unroll loops; the behaviors
% of TC1 and TC8 are only allowed in our model if the inferred range of
% variables is included as a global assumption in the logic. 
Our model also gives the desired results for
all of the examples in \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15} and
\citet[\textsection 5.3]{SevcikThesis}.  Our model agrees with the JMM on the
``surprising and controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}. \textsection\ref{sec:examples} develops some of these examples.



\paragraph{Multi-copy atomicity.}
In the parlance of chapter 3.3 of~\citet{AlglaveThesis}, $\le$ is a ``global
happens-before'' relation.  The restriction of $\lt$ to conflicting writes is
called the coherence order, $\rco$.  

Many of the standard litmus tests for \mca\ are
variants of \iriw\ (Independent Reads of Independent Writes), such as \iriw\
with control dependencies between the reads:
\begin{displaymatharray}{rl}
  &x\GETS0\SEMI x\GETS 1
  \PAR
  \IF{x}\THEN r\GETS y \FI
 \\{}
  \PAR&
  y\GETS0\SEMI y\GETS 1
  \PAR
  \IF{y}\THEN s\GETS x \FI
\end{displaymatharray}
\begin{tikzdisplay}[node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  %\po{rx1}{ry0}
  %\po{ry1}{rx0}
\end{tikzdisplay}
Since our semantics does not enforce control dependencies between reads, 
this execution is acyclic and is allowed.  If the first read in each thread is acquiring, there is order between the reads.
\begin{displaymatharray}{rl}
  &x\GETS0\SEMI x\GETS 1
  \PAR
  r\GETS x\ACQ \SEMI s\GETS y
 \\{}
  \PAR&
  y\GETS0\SEMI y\GETS 1
  \PAR
  r\GETS y\ACQ \SEMI s\GETS x
\end{displaymatharray}
The resulting execution is disallowed due to the  cycle.
\begin{tikzdisplay}[node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DR{y\ACQ}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DR{x\ACQ}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
\end{tikzdisplay}

% Note that if you enforce the dependency between the reads, then the execution
% is disallowed, because the is a cycle on weak edges restricted to $x$:
% \begin{math}
%   (\DW{x}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
% then
% \begin{math}
%   (\DW{y}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}

Another class of non-\mca\ behavior is characterized by the following litmus test.
\begin{displaymathsmall}
  \IF{x}\THEN y\GETS0 \FI \SEMI y\GETS1
  \PAR
  \IF{y}\THEN z\GETS0 \FI \SEMI z\GETS1
  \PAR
  \IF{z}\THEN x\GETS0 \FI \SEMI x\GETS1
\end{displaymathsmall}
\begin{tikzdisplaysmall}[node distance=1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DW{y}{0}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \wk{a2}{a3}
  \event{b1}{\DR{x}{1}}{right=of a3}
  \event{b2}{\DW{y}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{y}{1}}{right=of b2}
  \wk{b2}{b3}
  \event{c1}{\DR{x}{1}}{right=of b3}
  \event{c2}{\DW{y}{0}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DW{y}{1}}{right=of c2}
  \wk{c2}{c3}
  \rf{a3}{b1}
  \rf{b3}{c1}
  \rf[out=170,in=10]{c3}{a1}  
\end{tikzdisplaysmall}
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DR{x}{1}}{}
%   \event{a2}{\DW{y}{0}}{right=of a1}
%   \po{a1}{a2}
%   \event{a3}{\DW{y}{1}}{right=of a2}
%   \wk{a2}{a3}
%   \event{b1}{\DR{x}{1}}{below=of a1}
%   \event{b2}{\DW{y}{0}}{right=of b1}
%   \po{b1}{b2}
%   \event{b3}{\DW{y}{1}}{right=of b2}
%   \wk{b2}{b3}
%   \event{c1}{\DR{x}{1}}{below=of b1}
%   \event{c2}{\DW{y}{0}}{right=of c1}
%   \po{c1}{c2}
%   \event{c3}{\DW{y}{1}}{right=of c2}
%   \wk{c2}{c3}
%   \rf{a3}{b1}
%   \rf{b3}{c1}
%   \rf[out=210,in=210]{c3}{a1}  
% \end{tikzdisplay}
This execution is disallowed due to the evident cycle.
%in weak order. 

% This execution is allowed by 3-valued pomsets with coherence 
%\citep{2019-sp}. Interestingly, the two thread/two variable variant of this 
%example is disallowed by 3-valued pomsets, due to the requirements of
%\citeauthor{DBLP:journals/dc/Lamport86}'s axiom A3, which requires that
%$\cEv \gtN \aEv$ if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv%$. If one were to shift from 3-valued logic to an interval logic, then it %would make sense to include \citeauthor{DBLP:journals/dc/Lamport86}'s %axiom A4,which requires that $\bEv \lt \aEv$ if $\bEv \lt \bEv' \geN \aEv' %\lt \aEv$.In the semantics of programs, requiring A4 for 3-valued pomsets %withcoherence is equivalent to the assumption that $\gtN$ is a partial %order, as in the memory model pomsets used here.  Thus, the two %thread/two variable variant is also disallowed.


\paragraph{Pointers.}
Our language allows address calculations.  To model this, we allow locations
to have the form $\REF{n}$, where $n$ is a natural number.  Because we do not
enforce order between reads, there is some danger that address calculations
could allow thin air behavior.   To see how our model addresses this, assume
that we have the following locations and initial values:
\begin{align*}
  \REF{0}&=0  &
  \REF{1}&=2  &
  \REF{2}&=1  &
  x &=0 &
  y &=0 
\end{align*}
Consider the program
\begin{math}
  (x\GETS\REF{y} \PAR y\GETS\REF{x})
\end{math}
with attempted execution:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DR{y}{2}}{}
%   \event{a2}{\DR{\REF{2}}{1}}{below=of a1}
%   \event{a3}{\DW{x}{1}}{below=of a2}
%   \po{a2}{a3}
%   \po[out=210,in=150]{a1}{a3}
%   \event{b1}{\DR{x}{1}}{right=3em of a1}
%   \event{b2}{\DR{\REF{1}}{2}}{below=of b1}
%   \event{b3}{\DW{y}{2}}{below=of b2}
%   \po{b2}{b3}
%   \po[out=-30,in=30]{b1}{b3}
%   \rf{b3}{a1}
%   \rf{a3}{b1}
% \end{tikzdisplay}
\begin{tikzdisplay}[node distance=1em]
  \event{a1}{\DR{y}{2}}{}
  \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
  \event{a3}{\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=10,in=170]{a1}{a3}
  \event{b1}{\DR{x}{1}}{right=3em of a3}
  \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
  \event{b3}{\DW{y}{2}}{right=of b2}
  \po{b2}{b3}
  \po[out=10,in=170]{b1}{b3}
  \rf[out=-170,in=-10]{b3}{a1}
  \rf{a3}{b1}
\end{tikzdisplay}
Although there is no order enforced between the reads, the read-to-write
order induced by the semantics is sufficient to prohibit this thin-air
behavior.

The dependency calculation in this example is interesting.  Desugaring, the
first thread is $\aReg\GETS y\SEMI \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg$.
In isolation, the write action is $(\bReg=1\mid\DW{x}{1})$.  Following the
discussion of execution \eqref{m1}, $\bReg\GETS \REF{\aReg}$ causes the
precondition to become $\REF{\aReg}=1$; subsequently prefixing with
$(\aReg=2\mid\DR{\REF{2}}{1})$, this can be weakened to $1=1$ by the
substitution of $1$ for $\REF{2}$, as long as there is order between the events.  But the precondition is also constrained
by the last clause of the Definition~\ref{def:mmpomset}:
 if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies $\labelingForm(\bEv)$.
%
Thus the we arrive at the label $(\aReg=2\mid\DW{x}{1})$.  Subsequently,
$\aReg\GETS y$ transforms the precondition to $y=2$ and prefixing $\DR{y}{2}$
allows this to be weakened to $2=2$.

% if $\bEv\lt\bEv'\geN\aEv'\lt\aEv$ then $\bEv\lt\aEv$.
%   \begin{displaymath}
%     y\GETS 1
%     \PAR
%     x\GETS 1\SEMI
%     x\GETS 2\SEMI
%     \FENCE\SEMI
%     \aReg\GETS y
%     \PAR
%     y\GETS 2\SEMI
%     \FENCE\SEMI
%     \bReg\GETS x
%   \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{a2}{\DW{x}{2}}{right=of a1}
%   \po{a1}{a2}
%   %\event{a3}{\DF{}}{right=of a2}
%   %\po{a2}{a3}
%   \event{a4}{\DR{y}{1}}{right=of a2}
%   \po{a2}{a4}
%   %
%   \event{b1}{\DW{y}{2}}{below=of a4}
%   %\event{b2}{\DF{}}{left=of b1}
%   %\po{b1}{b2}
%   \event{b3}{\DR{x}{1}}{left=of b1}
%   \po{b1}{b3}
%   \wk{a4}{b1}
%   %
%   \event{c1}{\DW{y}{1}}{above=of a4}
%   \po{c1}{a4}
%   \rf{a1}{b3}
%   \wk{b3}{a2}
% \end{tikzdisplay}
% Ie, it does publication by antidependency...



\paragraph{Read from unexecuted branch (\rfub).}
\begin{comment}
RFUB Example 1
Thread 1:	                        
r1 = x.load(memory_order_relaxed);
y.store(r1, memory_order_relaxed);	

Thread 2:
bool assigned_42(false);
r1 = y.load(memory_order_relaxed);
if (r1 != 42) {
    assigned_42 = true;
    r1 = 42;
}
x.store(r1, memory_order_relaxed);
assert_not(assigned_42);
\end{comment}

\citet{BoehmOOTA} analyzes programs in which register state from an
unexecuted branch can effect the outcome of an execution.  
\citeauthor{BoehmOOTA}'s \rfub1 example can be written in our language as:
\begin{displaymath}
  %\label{rfub}
  y\GETS x
  \PAR
  r\GETS y\SEMI
  \IF{r \NOTEQ 1} \THEN z\GETS 1\SEMI r\GETS 1\SEMI x\GETS r \ELSE x\GETS r \FI
\end{displaymath}
\citeauthor{BoehmOOTA}'s concern arises from the similarity of this program
with the \oota\ litmus test that replaces the second thread with
\begin{math}
  r\GETS y\SEMI
  x\GETS r.
\end{math}
Should an unexecuted conditional be allowed to change the outcome of the
program?  In our semantics the answer is ``yes''.  First note that the
program writes $1$ to $x$ in both branches of the conditional.  Further, the
writes to $z$ and $x$ in the then-branch of the conditional are independent.
Therefore, it is sensible for a compiler to hoist the write to $x$ out of the
conditional.

To analyze the example formally, we use combinators on pomsets that are
defined in the next section.  These are prefixing $(\prefix)$ and composition
$(\parallel)$.  We also include events with unsatisfiable conditions in our
drawings; we indicate unsatisfiability by crossing out the event.  The
execution in question is:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{below=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Biggm\|
  \DR{y}{1}
  \prefix
  \left(
    \begin{tikzcenter}[node distance=1em]
      \event{b1}{r\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{r\NOTEQ1\mid\DW{x}{1}}{below=of b1}
    \end{tikzcenter}
    \biggm\|
    \begin{tikzcenter}[node distance=1em]
      \event{c1}{r\EQ1\mid\DW{x}{1}}{}
    \end{tikzcenter}
  \right)
\end{displaymathsmall}
With an internal read of $y$, we have:
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{below=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Biggm\|
    \begin{tikzcenter}[node distance=1em]
      \event{b1}{y\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{below=of b1}
    \end{tikzcenter}
\end{displaymathsmall}
but the precondition $y\NOTEQ1$ cannot be satisfied locally.
With an external read of $(\DR{y}{1})$, we can discharge the precondition, but in this
case, the predicate becomes $1\NOTEQ 1$. 
\begin{displaymathsmall}
  \begin{tikzcenter}[node distance=1em]
    \event{a1}{\DR{x}{1}}{}
    \event{a2}{\DW{y}{1}}{below=of a1}
    \po{a1}{a2}
  \end{tikzcenter}
  \Bigm\|  
    \begin{tikzcenter}[node distance=1em]
      \nonevent{b1}{1\NOTEQ1\mid\DW{z}{1}}{}
      \event{b2}{\DW{x}{1}}{below=of b1}
      \event{b0}{\DR{y}{1}}{left=of b1}
      \po{b0}{b1}
    \end{tikzcenter}
\end{displaymathsmall}



\paragraph{Silent Actions and Fences}

All fence actions are internal, do not read or write.
\begin{align*}
  \fmode \BNFDEF& \modeREL \BNFSEP \modeACQ \BNFSEP \modeSC
  \\
  \aCmd,\,\bCmd
  \BNFDEF& \cdots
  \BNFSEP \FENCE^{\fmode} \SEMI \aCmd  
\end{align*}

\begin{align*}
  \sem{\FENCE\SEMI \aCmd} & =
  (\DF{}) \prefix \sem{\aCmd}
\end{align*}

 The explicit use of internal actions facilitate the translation to \armeight\
(\textsection\ref{sec:arm}) and the definitions required in the proof of
\drfsc\ (\textsection\ref{sec:sc}).

Add condition to validate DRF.
\begin{itemize}
\item[5e.] if $\cEv$ internally reads from $\aLoc$, $\labelingForm(\aEv)$ is
  not independent of $\aLoc$, and $\aEv$ writes, then $\cEv\lt'\aEv$.
\end{itemize}

In defining \emph{data races} (and thus in the proof of \drfsc) it is
important to position internal actions relative to synchronization actions.
For example, the following execution is consider data-race free.
\begin{displaymath}
  x\GETS1\SEMI
  \aReg\GETS x \SEMI
  y\REL\GETS 1 \SEMI
  \PAR
  \bReg\GETS y\ACQ \SEMI
  x\GETS 2
\end{displaymath}
\begin{tikzdisplay}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \internal{a2}{\DR{x}{}}{right=of a1}
  %\graypo{a1}{a2}
  \event{a3}{\DWRel{y}{1}}{right=of a2}
  \graypo{a2}{a3}
  \po[bend left]{a1}{a3}
  \event{b1}{\DRAcq{y}{1}}{right=3em of a3}
  \rf{a3}{b1}
  \event{b2}{\DW{x}{2}}{right=of b1}
  \po{b1}{b2}
\end{tikzdisplay}
However, if we commute the read of $x$ and the release of $y$, the resulting
program has a data race.
% \begin{displaymath}
%   x\GETS0\SEMI
%   x\GETS1\SEMI
%   \aReg\GETS x \SEMI
%   y\REL\GETS 1 \SEMI
%   z\GETS\aReg
%   \PAR
%   \bReg\GETS z\ACQ \SEMI
%   \cReg\GETS x
% \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{a0}{\DW{x}{0}}{left=of a1}
%   \wk{a0}{a1}
%   \internal{a2}{\DR{x}{1}}{right=of a1}
%   \graypo{a1}{a2}
%    \event{a3}{\DWRel{y}{1}}{right=of a2}
%   \graypo{a2}{a3}
%   \po[bend left]{a1}{a3}
%   \event{a4}{\DW{z}{1}}{right=of a3}
%   \graypo[bend left]{a2}{a4}
%   \event{b1}{\DRAcq{z}{1}}{below=of a4}
%   \rf{a4}{b1}
%   \event{b2}{\DR{x}{0}}{left=8em of b1}
%   \po{b1}{b2}
%   \wk{b2}{a1}
%   \wk{a0}{b2}
% \end{tikzdisplay}


\paragraph{Address Calculation}

Definition of data model:
\begin{itemize}
\item memory locations have the form $\REF{\aVal}$,
\item expressions do \emph{not} include memory locations or the operator $\REF{\aExp}$,
\end{itemize}

\begin{align*}
\aCmd,\,\bCmd
\BNFDEF& \cdots
\BNFSEP \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
\BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
\end{align*}

\begin{align*}
  \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; \textstyle\bigcup_\aVal\; ({\cExp}=\cVal \mid \DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] 
  \\ & \mkern2mu\cup \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid\iDRmode{\aLoc}{\aVal}) \prefix \sem{\aCmd}[\aLoc/\aReg]
  \\
  \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
  \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; \textstyle\bigcup_\aVal\; ({\cExp}=\cVal \land \aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
  \\ & \mkern2mu\cup \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid \iDWmode{\aLoc}{\aVal}) \prefix \sem{\aCmd}[\aExp/\aLoc]  
\end{align*}

\paragraph{Read-Modify-Write}

% \section{Variations}

% \citet{2019-sp} define \emph{3-valued pomsets with preconditions} to model
% security flaws that arise from speculative evaluation in computer
% microarchitecture (such as Spectre \cite{DBLP:journals/corr/abs-1801-01203}).
% \begin{definition}
%   %\label{def:3valued}
%   A \emph{3-valued pomset with preconditions} is a tuple
%   $(\Event, {\le}, {\gtN}, \labeling)$, such that
%   \begin{itemize}
%   \item $\Event$ is a set of \emph{states},
%   \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
%   \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
%   \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
%     \begin{itemize}
%     \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$, \hfill
%       (Inclusion)
%     \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then
%       $\bEv = \aEv$, and \hfill (Consistency)
%     \item\label{5c} if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$
%       then $\cEv \gtN \aEv$.  \hfill (Semi-transitivity)
%     \end{itemize}
%   \end{itemize}

%   A \emph{(memory model) pomset} is a 3-valued pomset with preconditions,
%   such that
%   \begin{itemize}
%   \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
%     $\labelingForm(\bEv)$, and \hfill (Causal-strengthening)
%   \end{itemize}
% \end{definition}
% The axioms for $\gtN$ are adapted
% from~\citet[A1--A3]{DBLP:journals/dc/Lamport86}.  

% \begin{definition}
%   A pomset \emph{coherent} if, when restricted to events that read or write
%   any single location $\aLoc$, $\gtN$ forms a partial order.
% \end{definition}
