\section{Extensions}
\label{sec:variants}

We extend the model to include additional
features: fences, address calculation, and read-modify-write (\RMW). The
proofs given later in the paper extend to include these features.  

\paragraph{Silent Actions and Fences.}

For the actions of a data model, we require that there is a set
$\Int\subseteq\Act$ such that
$\Int\cap\fdom(\rreads)=\Int\cap\fdom(\rwrites)=\emptyset$.  We say $\aAct$
is \emph{silent} if $\aAct\in\Int$.

By definition, silent actions neither read nor write.

To model the fencing behavior of local reads and writes, our example language
includes silent actions of the form $\DFR{\amode}$ and $\DFW{\amode}$.  For
$\amode\in\{\modeRA,\,\modeSC\}$, $\DFR{\amode}$ is an acquire, and
$\DFW{\amode}$ is a release.  The fences with access mode $\modeRLX$ do
nothing; we include them only to remove case analysis from the definitions.

We also include syntactic fences of the form
``$\FENCE^{\fmode} \SEMI \aCmd$.''  The semantics of syntactic fences
is subtly different from the fencing behavior of
$\modeRA$/$\modeSC$-accesses in C11.  Thus we include separate actions for syntactic
fences: $\DFS{\fmode}$.  The \emph{syntactic fence mode}
$(\fmode \!\!\BNFDEF\!\! \modeREL \!\BNFSEP\! \modeACQ \!\BNFSEP\! \modeSC)$
is either \emph{release}, \emph{acquire}, or \emph{sequentially-consistent}.
$\DFS{\modeREL}$ is a release. $\DFS{\modeACQ}$ is an acquire.
$\DFS{\modeSC}$ is both a release and an acquire.

To Definition \ref{def:prefix} of prefixing, add:
\begin{enumerate}
\item[5e.] if $\bEv$ reads and $\labelingAct(\aEv)=\DFS{\modeACQ}$, then
  $\aEv \lt' \bEv$, and
\item[5f.] if $\labelingAct(\bEv)=\DFS{\modeREL}$ and $\aEv$ writes, then
  $\bEv \lt' \aEv$.
\end{enumerate}
\begin{align*}
  \sem{\FENCE^{\fmode}\SEMI \aCmd} & =
  (\DFS{\fmode}) \prefix \sem{\aCmd}
  \\
  \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFR{\amode}) \;\prefix}\,\;
  \sem{\aCmd}[\aLoc/\aReg]
  \\
  \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
  \;\;\textstyle\parallel_\aVal (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFW{\amode}) \;\prefix}\,\;
  (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
\end{align*}

Our semantics does not suffer the weaknesses of C11 fences, noted by
\citet[Figs.~5 and 6]{DBLP:conf/pldi/LahavVKHD17}. We omit $0$-initialization
in these examples:
\begin{gather*}
    x\GETS1
    \PAR
    r\GETS x\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \event{b1}{\DR{x}{1}}{right=3em of a1}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \po{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=3em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \po{c2}{c3}
  \wk{b3}{c1}
  \rf{a1}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
  \\
    x\GETS1\SEMI   
    z\REL\GETS1\SEMI   
    \PAR
    r\ACQ\GETS z\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=.7em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{z}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b1}{\DRAcq{z}{1}}{right=2em of a2}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \po{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=2em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \po{c2}{c3}
  \wk{b3}{c1}
  \rf{a2}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
\end{gather*}
The executions are disallowed, due to cycles.  It is a testament to the
complexity of C11 that it allows these executions.

\paragraph{Address Calculation.}
In the definition of a data model, remove the location set $\Loc$ and require
that locations have the form $\aLoc\!\!\BNFDEF\!\!\REF{\cVal}$, where $\cVal$
is a value.  Expressions may include neither memory locations nor the
operator $\REF{\cExp}^{\amode}$.
In our example language, we update the syntax of commands:
\begin{gather*}
  \aCmd
  \BNFDEF \cdots
  \BNFSEP \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
  \BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
  \\
\begin{aligned}
  \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_{\cVal,\aVal}\; (\;\mathhl{\cExp=\cVal} \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
  \\[-.5ex] & \mkern2mu\cup
  \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\;\mathhl{\cExp=\cVal}\mid\DFR{\amode}) \prefix
  \sem{\aCmd}[\REF{\cVal}/\aReg]
  \\
  \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
  \\[-1ex]
  &\mkern-65mu\hbox to 0pt{$\begin{aligned}
    &\textstyle\parallel_{\cVal,\aVal}\;(\;\mathhl{\cExp=\cVal} \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
    \\[-.5ex]  \cup\!&
    \textstyle\parallel_{\cVal\phantom{,\aVal}}\; (\;\mathhl{\cExp=\cVal}\mid\DFW{\amode}) \prefix
    (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
  \end{aligned}$}
  % \\[-9.5ex]
  % \sem{\;\mathhl{\REF{\cExp}^\amode}\GETS\aExp\SEMI \aCmd} & =
  % \\[6ex]
\end{aligned}
% \begin{aligned}
%   \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
%   \textstyle\bigcup_{\cVal,\aVal}\; (\cExp=\cVal \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
%   \\[-.5ex] & \mkern2mu\cup
%   \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFR{\amode}) \prefix
%   \sem{\aCmd}[\REF{\cVal}/\aReg]
%   \\
%   \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
%   \\[-1ex]
%   &\mkern-65mu\hbox to 0pt{$\begin{aligned}
%     &\textstyle\parallel_{\cVal,\aVal}\;(\cExp=\cVal \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
%     \\[-.5ex]  \cup\!&
%     \textstyle\parallel_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFW{\amode}) \prefix
%     (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
%   \end{aligned}$}
% \end{aligned}
\end{gather*}

Let us revisit the discussion of the use of \!$\PAR$\!
in Candidate~\ref{cand2.9}.
Note that 
\begin{math}
  \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
\end{math}
includes both of the following pomsets (``$\BANG \aExp$'' evaluates to $1$ if
$\aExp$ is $0$, and $0$ otherwise):
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  %\\[-1.5ex]\intertext{and:}\\[-5ex]
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
      \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
    \end{tikzinline}}%\;\;\cdots
\end{align*}
By using \!$\PAR$\!, it also includes:
\begin{gather}
  \label{alanAddress}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
      %\event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
    \end{tikzinline}}%\;\;\cdots
\end{gather}
In this example, the events that coalesce correspond to different statements
in the syntax.


Because we do not enforce order between reads, there is some danger that
address calculations could introduce anomalous behaviors that arise \emph{out of thin air}
(\oota) \cite{DBLP:conf/esop/BattyMNPS15}.  Consider the following attempted
execution, where all memory addresses are initialized to $0$, except that
$\REF{2}$ is $1$ and $\REF{1}$ is $2$:
\begin{gather*}
  \aReg\GETS y\SEMI \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \PAR
  \aReg\GETS x\SEMI \bReg\GETS \REF{\aReg}\SEMI y\GETS \bReg
  %x\GETS\REF{y} \PAR y\GETS\REF{x}
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{2}}{}
  \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
  \event{a3}{\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=10,in=170]{a1}{a3}
  \event{b1}{\DR{x}{1}}{right=3em of a3}
  \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
  \event{b3}{\DW{y}{2}}{right=of b2}
  \po{b2}{b3}
  \po[out=10,in=170]{b1}{b3}
  \rf[out=-170,in=-10]{b3}{a1}
  \rf{a3}{b1}
    \end{tikzinline}}
\end{gather*}
Although there is no order enforced between the reads, the read-to-write
order induced by the semantics is sufficient to prohibit this \oota{}
behavior.  Note the intermediate state:
\begin{gather*}
  \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\aReg{=}2\mid\DR{\REF{2}}{1}}{}
  \event{a3}{\aReg{=}2\mid\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}
The precondition on the write is required by causal strengthening in
Definition~\ref{def:mmpomset}: if $\bEv\le\aEv$ then $\labelingForm(\aEv)$
implies $\labelingForm(\bEv)$.

\paragraph{Read-Modify-Write.} We discuss \RMW\ operations that work on a
single location in memory, such as \emph{fetch-and-add} ($\FADD$) and
\emph{compare-and-swap} ($\CAS$).  These operations can be modeled using read/write
actions or using an additional relation between events.  The second approach
is more general and less obvious, therefore we explain it here.

In Definition \ref{def:mmpomset}, require that a \emph{(memory model) pomset}
be a tuple $(\Event, {\le}, \labeling, \xrmw)$, where ${\xrmw}\subseteq{\le}$
relates the two events of a successful \RMW.  Additionally, require that:
\begin{itemize}
\item If $\cEv$ and $\aEv$ both write $x$, $\cEv\gtN \aEv$ and $\bEv \xrmw \aEv$ then  $\cEv\gtN \bEv$.
\item If $\cEv$ and $\aEv$ both write $x$, $\bEv\gtN \cEv$ and $\bEv \xrmw \aEv$ then  $\aEv\gtN \cEv$.
\end{itemize}
We elide the obvious and tedious semantic rules.

% \begin{scope}
% \renewcommand{\aEv}{r}
% In Definition \ref{def:rf}, require that when $\bEv$ \emph{fulfills $\aEv$ on
%   $\aLoc$}:
% \begin{itemize}
% %\item there is no pair $(r,w)\in{\rrmw}$ such that $r\gtN\bEv\gtN w$, and
% \item if
%   $\aEv \gtN \bEv$,
%   $\bEv$ writes to $\aLoc$, and
%   $(\aEv,w)\in{\rrmw}$, 
%   then $w \gtN \bEv$.
% \end{itemize}
% \end{scope}
This definition ensures atomicity, disallowing executions such as
\cite[Ex.~3.2]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  \aLoc\GETS0\SEMI\bReg\GETS \FADD^{\modeRLX,\modeRLX}(\aLoc)
  \PAR
  x\GETS 2\SEMI s\GETS x
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\DR{x}{0}}{}
  \event{a1}{\DW{x}{0}}{left=of a2}
  \rf{a1}{a2}
  \event{a3}{\DW{x}{2}}{right=of a2}
  \wk{a2}{a3}
  \event{b2}{\DW{x}{1}}{right=of a3}
  \event{b3}{\DR{x}{1}}{right=of b2}
  \rmw[out=-15,in=-165]{a2}[below]{b2}
  \wk{a3}{b2}
  \rf{b2}{b3}
    \end{tikzinline}}
\end{gather*}

By using two actions rather than one, the definition allows examples such as the
following, which is allowed by \armeight{} 
\cite[Ex.~3.10]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  r \GETS y\SEMI
  z \GETS r
  \PAR
  r\GETS z\SEMI
  x\GETS 0\SEMI
  s\GETS \FADD^{\modeRLX,\modeRA}(x) \SEMI
  y\GETS s{+}1
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{1}}{}
  \event{a2}{\DW{z}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b1}{\DR{z}{1}}{right=3em of a2}
  \rf{a2}{b1}
  \event{b2}{\DW{x}{0}}{right=of b1}
  \event{b3}{\DR{x}{0}}{right=of b2}
  \rf{b2}{b3}
  \event{b4}{\DWRel{x}{1}}{right=2em of b3}
  \rmw{b3}{b4}
  \event{b5}{\DW{y}{1}}{right=of b4}
  \po[out=-15,in=-165]{b1}{b4}
  \po[out=-20,in=-160]{b3}{b5}
  \rf[out=170,in=10]{b5}{a1}
    \end{tikzinline}}
\end{gather*}

