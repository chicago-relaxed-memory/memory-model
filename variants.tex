\section{Test Cases and Additional Features}
\label{sec:variants}

After discussing a few test cases, we extend the model to include additional
features: fences, address calculation, and read-modify-write
(\RMW)\footnote{The proofs given later in the paper extend to all of these
  features, with one exception: we believe the \armeight/\tso-compilation
  strategy is correct for \RMW---it is borrowed from
  \citet{DBLP:journals/pacmpl/PodkopaevLV19}---but have not proved it.}.  We
then provide an alternative semantics that supports full sequential
composition, building $\sem{\aCmd\SEMI\bCmd}$ from $\sem{\aCmd}$ and
$\sem{\bCmd}$.

\paragraph{Test Cases.}
Our model gives the desired results for the test cases of \citet{PughWebsite},
\citet[\textsection 5.3]{SevcikThesis}, and \citet[\textsection
4]{DBLP:conf/esop/BattyMNPS15}.  It also agrees with the ``surprising and
controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}.

We present two examples that are hallmarks of \mca{} architectures.
The analysis follows from a few simple principles.  
% \begin{gather*}
%   \renewcommand{\arraycolsep}{1pt}
%   \hbox{\small
%     $\begin{array}{ccccc}
%     &x\GETS0\SEMI x\GETS 1
%     &\PAR&
%     r\GETS x \SEMI s\GETS y
%     %\IF{x}\THEN r\GETS y \FI
%     \\
%     \PAR
%     &y\GETS0\SEMI y\GETS 1
%     &\PAR&
%     r\GETS y \SEMI s\GETS x
%     %\IF{y}\THEN s\GETS x \FI
%   \end{array}$}
%   \quad
%   \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \rf{wx1}{rx1}
%   \rf[bend left]{wy0}{ry0}
%   \rf{wy1}{ry1}
%   \rf[bend right]{wx0}{rx0}
%   \wk{rx0}{wx1}
%   \wk{ry0}{wy1}
%     \end{tikzinlinesmall}}
% \end{gather*}
\begin{gather*}
  \\[-2.5ex]
  \renewcommand{\arraycolsep}{1pt}
  \hbox{\small
    $\begin{array}{ccccc}
    &x\GETS0\SEMI x\GETS 1
    &\PAR&
    r\GETS x\ACQ \SEMI s\GETS y
    %\IF{x}\THEN r\GETS y \FI
    \\
    \PAR
    &y\GETS0\SEMI y\GETS 1
    &\PAR&
    r\GETS y\ACQ \SEMI s\GETS x
    %\IF{y}\THEN s\GETS x \FI
  \end{array}$}
  \quad
  \smash{\hbox{\begin{tikzinlinesmall}[baseline=-10pt,node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DRAcq{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
    \end{tikzinlinesmall}}}
  \\[-1ex]
\end{gather*}
In this variant of \iriw\ (Independent Reads of Independent Writes), order 
is imposed by \emph{coherence} (between the writes), \emph{fulfillment}
(between read and write), and \emph{fencing} (from acquiring read to relaxed read).
Given the evident cycle, the candidate execution is invalid.
% Note that if you enforce the dependency between the reads, then the execution
% is disallowed, because the is a cycle on weak edges restricted to $x$:
% \begin{math}
%   (\DW{x}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
% then
% \begin{math}
%   (\DW{y}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}

It is also impossible for all threads to read $1$ in the following, due to
\emph{control dependencies}, \emph{coherence}, and \emph{fulfillment}.
\begin{gather*}
  \hbox{\small$\IF{x}\THEN y\GETS0 \FI \SEMI y\GETS1
  {\PAR}
  \IF{y}\THEN z\GETS0 \FI \SEMI z\GETS1
  {\PAR}
  \IF{z}\THEN x\GETS0 \FI \SEMI x\GETS1
  $}
  \\[-.5ex]
  \hbox{\begin{tikzinlinesmall}[node distance=1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DW{y}{0}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \wk{a2}{a3}
  \event{b1}{\DR{x}{1}}{right=of a3}
  \event{b2}{\DW{y}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{y}{1}}{right=of b2}
  \wk{b2}{b3}
  \event{c1}{\DR{x}{1}}{right=of b3}
  \event{c2}{\DW{y}{0}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DW{y}{1}}{right=of c2}
  \wk{c2}{c3}
  \rf{a3}{b1}
  \rf{b3}{c1}
  \rf[out=173,in=7]{c3}{a1}  
    \end{tikzinlinesmall}}
\end{gather*}

In either example, the execution is allowed if the cycle is broken---for
example, by changing $x\ACQ$ to $x\RLX$ in \iriw.


% \citet{PughWebsite} developed a set of twenty {causality test cases} in the
% process of revising the Java Memory Model (JMM)
% \cite{Manson:2005:JMM:1047659.1040336}.
% %Using hand calculation, we have confirmed that
% Our model gives the desired result for all twenty cases,
% unrolling loops as necessary.
% % confirmed that our model gives the desired result these test cases, with the
% % following caveats: to model TC14 and TC15 we must unroll loops; the behaviors
% % of TC1 and TC8 are only allowed in our model if the inferred range of
% % variables is included as a global assumption in the logic. 
% Our model also gives the desired results for the examples of
% \citet{PughWebsite}, \citet[\textsection 5.3]{SevcikThesis},
% \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15}.  Our model agrees with
% ``surprising and controversial behaviors'' of
% \citet[\textsection 8]{Manson:2005:JMM:1047659.1040336}.  We elide the
% details.
% \textsection\ref{sec:examples} develops some of these examples.

\paragraph{Silent Actions and Fences.}

For the actions of a data model, we require that there is a set
$\Int\subseteq\Act$ such that
$\Int\cap\fdom(\rreads)=\Int\cap\fdom(\rwrites)=\emptyset$.  We say $\aAct$
is \emph{silent} if $\aAct\in\Int$.  By definition, silent actions neither
read nor write.

To model the fencing behavior of local reads and writes, our example language
includes internal actions of the form $\DFR{\amode}$ and $\DFW{\amode}$.
$\DFR{\amode}$ is an acquire if $\amode\neq\modeRLX$.  $\DFW{\amode}$ is a
release if $\amode\neq\modeRLX$.

Because the semantics of syntactic fences is subtly different from the
fencing behavior of $\modeRA$/$\modeSC$-accesses, our example language
includes separate internal actions for syntactic fences: $\DFS{\fmode}$.  The
\emph{syntactic fence mode}
$\fmode \!\!\BNFDEF\!\! \modeREL \!\BNFSEP\! \modeACQ \!\BNFSEP\! \modeSC$ is either
\emph{release}, \emph{acquire}, or \emph{sequentially-consistent}.
$\DFS{\modeREL}$ is a release. $\DFS{\modeACQ}$ is an acquire.
$\DFS{\modeSC}$ is both a release and an acquire.

As concrete syntax for commands, we write ``$\FENCE^{\fmode} \SEMI \aCmd$.''
\begin{align*}
  \sem{\FENCE^{\fmode}\SEMI \aCmd} & =
  (\DFS{\fmode}) \prefix \sem{\aCmd}
  \\
  \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFR{\amode}) \;\prefix}\,\;
  \sem{\aCmd}[\aLoc/\aReg]
  \\
  \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
  \textstyle\PAR_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFW{\amode}) \;\prefix}\,\;
  (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
\end{align*}

In the following, we leave out the initial writes of $0$.
\citep[Fig 5]{DBLP:conf/pldi/LahavVKHD17}:
\begin{gather*}
    y\GETS1
    \PAR
    r\GETS x\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{y}{1}}{}
  \event{a0}{\DW{y}{0}}{left=of a1}
  \wk{a0}{a1}
  \event{a2}{\DWRel{x}{1}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DR{x}{1}}{right=3em of a2}
  \rf{a2}{a3}
  \event{b1}{\DRAcq{x}{1}}{right=of a3}
  \rf[out=10,in=170]{a2}{b1}
  \event{b2}{\DR{y}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{z}{0}}{right=of b2}
  \po{b2}{b3}
    \end{tikzinline}}
\end{gather*}

\citep[Fig 6]{DBLP:conf/pldi/LahavVKHD17}:



In our semantics, we have not included rules for silent synchronizations.
\begin{gather}
  \label{read-before-acquire}
  %y\GETS0\SEMI
    y\GETS1\SEMI
    x\REL\GETS1
    \PAR
    r\GETS x\SEMI
    \IF{x\ACQ}\THEN z\GETS y\FI
    \\[-.1ex]
    \nonumber
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{a1}{\DW{y}{1}}{}
  % \event{a0}{\DW{y}{0}}{left=of a1}
  % \wk{a0}{a1}
  \event{a2}{\DWRel{x}{1}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DR{x}{1}}{right=3em of a2}
  \rf{a2}{a3}
  \event{b1}{\DRAcq{x}{1}}{right=of a3}
  \rf[out=10,in=170]{a2}{b1}
  \event{b2}{\DR{y}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{z}{0}}{right=of b2}
  \po{b2}{b3}
  \wk[out=-170,in=-10]{b2}{a1}
    \end{tikzinline}}
\end{gather}







\paragraph{Address Calculation.}
Update syntax as follows:
\begin{align*}
  \aLoc\BNFDEF\REF{\cVal}
  \qquad
  \aCmd
  \BNFDEF \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
  \BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
  \BNFSEP \cdots 
\end{align*}
Memory locations are numbers.  To avoid syntactic collisions between values
and locations, we use a syntactic trick, defining locations---$\aLoc$,
$\bLoc$, $\cLoc$---to range over $\REF{\cVal}$, where $\cVal$ is a value.
\begin{align*}
  \sem{\aReg\GETS{\REF{\cExp}^\amode}\SEMI \aCmd} & =
  \textstyle\bigcup_{{\cVal,\aVal}}\; {({\cExp}=\cVal} \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
  \\[-.5ex] & \mkern2mu\cup
  %\text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
  (\iDR[\amode]{\aLoc}{}) \prefix
  \sem{\aCmd}[\REF{\cVal}/\aReg]
  \\[-1ex]
  \sem{{\REF{\cExp}^\amode}\GETS\aExp\SEMI \aCmd} & =
  \\[-1ex]
  &\mkern-55mu\hbox to 0pt{$\begin{aligned}
    &\textstyle\PAR_{{\cVal,\aVal}}\;{({\cExp}=\cVal} \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
    \\[-.5ex] & \mkern2mu\cup
    %\text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
    (\iDW[\amode]{\aLoc}{}) \prefix
    (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
  \end{aligned}$}
\end{align*}

% THE FULL RULES, with internal actions:
% \begin{align*}
%   \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
%   \textstyle\bigcup_{\aLoc=\REF{\cVal}}\;\bigcup_\aVal\; ({\cExp}=\cVal \mid \DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
%   \\[-.5ex] & \mkern2mu\cup
%   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%   \textstyle\bigcup_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid\iDR{\aLoc}{})\prefix
%   \sem{\aCmd}[\aLoc/\aReg]
%   \\
%   \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =  
%   \textstyle\PAR_{\aLoc=\REF{\cVal}}\; \PAR_{\!\!\aVal}\;({\cExp}=\cVal \land \aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
%   \\[-.5ex] & \mkern2mu\cup
%   \text{if $\amode\mathbin\neq\modeRLX$ then }\text{$\emptyset$ else }
%   \textstyle\PAR_{\aLoc=\REF{\cVal}}\; ({\cExp}=\cVal \mid\iDW{\aLoc}{}) \prefix 
%   (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
% \end{align*}


% Our language allows address calculations.  To model this, we allow locations
% to have the form $\REF{n}$, where $n$ is a natural number.  
Because we do not
enforce order between reads, there is some danger that address calculations
could allow thin air behavior.   To see how our model addresses this, assume
that we have the following locations and initial values:
\begin{align*}
  \REF{0}&=0  &
  \REF{1}&=2  &
  \REF{2}&=1  &
  x &=0 &
  y &=0 
\end{align*}
Consider the program
\begin{math}
  (x\GETS\REF{y} \PAR y\GETS\REF{x})
\end{math}
with attempted execution:
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DR{y}{2}}{}
%   \event{a2}{\DR{\REF{2}}{1}}{below=of a1}
%   \event{a3}{\DW{x}{1}}{below=of a2}
%   \po{a2}{a3}
%   \po[out=210,in=150]{a1}{a3}
%   \event{b1}{\DR{x}{1}}{right=3em of a1}
%   \event{b2}{\DR{\REF{1}}{2}}{below=of b1}
%   \event{b3}{\DW{y}{2}}{below=of b2}
%   \po{b2}{b3}
%   \po[out=-30,in=30]{b1}{b3}
%   \rf{b3}{a1}
%   \rf{a3}{b1}
% \end{tikzdisplay}
\begin{tikzdisplay}[node distance=1em]
  \event{a1}{\DR{y}{2}}{}
  \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
  \event{a3}{\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=10,in=170]{a1}{a3}
  \event{b1}{\DR{x}{1}}{right=3em of a3}
  \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
  \event{b3}{\DW{y}{2}}{right=of b2}
  \po{b2}{b3}
  \po[out=10,in=170]{b1}{b3}
  \rf[out=-170,in=-10]{b3}{a1}
  \rf{a3}{b1}
\end{tikzdisplay}
Although there is no order enforced between the reads, the read-to-write
order induced by the semantics is sufficient to prohibit this thin-air
behavior.

The dependency calculation in this example is interesting.  Desugaring, the
first thread is $\aReg\GETS y\SEMI \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg$.
In isolation, the write action is $(\bReg=1\mid\DW{x}{1})$.  Prepending
$(\bReg\GETS \REF{\aReg})$ causes substitution $(\REF{\aReg}=1)$ then with
$(\aReg=2\mid\DR{\REF{2}}{1})$, this can be weakened to $1=1$ by the
substitution of $1$ for $\REF{2}$, as long as there is order between the
events.  But the precondition is also constrained by the last clause of the
Definition~\ref{def:mmpomset}: if $\bEv\le\aEv$ then $\labelingForm(\aEv)$
implies $\labelingForm(\bEv)$.
%
Thus the we arrive at the label $(\aReg=2\mid\DW{x}{1})$.  Subsequently,
$\aReg\GETS y$ transforms the precondition to $y=2$ and prefixing $\DR{y}{2}$
allows this to be weakened to $2=2$.

% if $\bEv\lt\bEv'\geN\aEv'\lt\aEv$ then $\bEv\lt\aEv$.
%   \begin{displaymath}
%     y\GETS 1
%     \PAR
%     x\GETS 1\SEMI
%     x\GETS 2\SEMI
%     \FENCE\SEMI
%     \aReg\GETS y
%     \PAR
%     y\GETS 2\SEMI
%     \FENCE\SEMI
%     \bReg\GETS x
%   \end{displaymath}
% \begin{tikzdisplay}[node distance=1em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{a2}{\DW{x}{2}}{right=of a1}
%   \po{a1}{a2}
%   %\event{a3}{\DF{}}{right=of a2}
%   %\po{a2}{a3}
%   \event{a4}{\DR{y}{1}}{right=of a2}
%   \po{a2}{a4}
%   %
%   \event{b1}{\DW{y}{2}}{below=of a4}
%   %\event{b2}{\DF{}}{left=of b1}
%   %\po{b1}{b2}
%   \event{b3}{\DR{x}{1}}{left=of b1}
%   \po{b1}{b3}
%   \wk{a4}{b1}
%   %
%   \event{c1}{\DW{y}{1}}{above=of a4}
%   \po{c1}{a4}
%   \rf{a1}{b3}
%   \wk{b3}{a2}
% \end{tikzdisplay}
% Ie, it does publication by antidependency...

\paragraph{Read-Modify-Write}

% \section{Variations}

% \citet{2019-sp} define \emph{3-valued pomsets with preconditions} to model
% security flaws that arise from speculative evaluation in computer
% microarchitecture (such as Spectre \cite{DBLP:journals/corr/abs-1801-01203}).
% \begin{definition}
%   %\label{def:3valued}
%   A \emph{3-valued pomset with preconditions} is a tuple
%   $(\Event, {\le}, {\gtN}, \labeling)$, such that
%   \begin{itemize}
%   \item $\Event$ is a set of \emph{states},
%   \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
%   \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
%   \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
%     \begin{itemize}
%     \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$, \hfill
%       (Inclusion)
%     \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then
%       $\bEv = \aEv$, and \hfill (Consistency)
%     \item\label{5c} if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$
%       then $\cEv \gtN \aEv$.  \hfill (Semi-transitivity)
%     \end{itemize}
%   \end{itemize}

%   A \emph{(memory model) pomset} is a 3-valued pomset with preconditions,
%   such that
%   \begin{itemize}
%   \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
%     $\labelingForm(\bEv)$, and \hfill (Causal-strengthening)
%   \end{itemize}
% \end{definition}
% The axioms for $\gtN$ are adapted
% from~\citet[A1--A3]{DBLP:journals/dc/Lamport86}.  

% \begin{definition}
%   A pomset \emph{coherent} if, when restricted to events that read or write
%   any single location $\aLoc$, $\gtN$ forms a partial order.
% \end{definition}
