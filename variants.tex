\section{Extensions}
\label{sec:variants}

We extend the model to include additional
features: fences, address calculation, and read-modify-write (\RMW). The
proofs given later in the paper extend to include these features.  

\paragraph{Fences}

Syntactic fences
``$\FENCE^{\fmode} \SEMI \aCmd$'' have corresponding  actions: $(\DFS{\fmode})$.  The \emph{syntactic fence mode}
$(\fmode \!\!\BNFDEF\!\! \modeREL \!\BNFSEP\! \modeACQ \!\BNFSEP\! \modeSC)$
is either \emph{release}, \emph{acquire}, or \emph{sequentially-consistent}.
$(\DFS{\modeREL})$ is a release. $(\DFS{\modeACQ})$ is an acquire.
$(\DFS{\modeSC})$ is both a release and an acquire.
\begin{align*}
  \sem{\FENCE^{\fmode}\SEMI \aCmd} & =
  (\DFS{\fmode}) \prefix \sem{\aCmd}
\end{align*}
Syntactic fences require additional order to simulate $\modeRA$/$\modeSC$-accesses.
% Consider a variant of \ref{Pub1}:
% \begin{gather*}
%   \label{Pub2}\tag{Pub2}
%   x\GETS0\SEMI %y\GETS0\SEMI
%   x\GETS 1\SEMI \FENCE^\modeREL\SEMI y \GETS1
%   \PAR
%   r\GETS y \SEMI \FENCE^\modeACQ\SEMI s\GETS x
%   \\[-1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{wx0}{\DW{x}{0}}{}
%       \event{wx1}{\DW{x}{1}}{right=of wx0}
%       \event{fr}{\DFS{\modeREL}}{right=of wx1}
%       \event{wy1}{\DW{y}{1}}{right=of fr}
%       \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
%       \event{fa}{\DFS{\modeACQ}}{right=of ry1}
%       \event{rx0}{\DR{x}{0}}{right=of fa}
%       \sync{wx1}{fr}
%       %\sync{fr}{wy1}
%       %\sync{ry1}{fa}
%       \sync{fa}{rx0}
%       \rf{wy1}{ry1}
%       \rf[out=10,in=170]{wx0}{rx0}
%       \wk{wx0}{wx1}
%     \end{tikzinline}}
% \end{gather*}
% The semantics of syntactic fences
% is subtly different from the fencing behavior of
% $\modeRA$/$\modeSC$-accesses in C11. 
%To ensure the order that invalidates this execution candidate,
We add the following rules 
to Definition \ref{def:prefix} of \emph{prefixing}:
\begin{enumerate}
\item[{\labeltext[5e]{(5e)}{5e}}] if $\bEv$ reads, and $\aEv$ is an acquiring fence, then
  $\bEv \lt' \aEv$, and
\item[{\labeltext[5f]{(5f)}{5f}}] if $\bEv$ is a releasing fence, and $\aEv$ writes, then
  $\bEv \lt' \aEv$.
\end{enumerate}
Consider the following variant of \ref{Pub1}:
\begin{gather*}
  \taglabel{Pub2}
  x\GETS0\SEMI %y\GETS0\SEMI
  x\GETS 1\SEMI \FENCE^\modeREL\SEMI y \GETS1
  \PAR
  r\GETS y \SEMI \FENCE^\modeACQ\SEMI s\GETS x
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
      \event{wx0}{\DW{x}{0}}{}
      \event{wx1}{\DW{x}{1}}{right=of wx0}
      \event{fr}{\DFS{\modeREL}}{right=of wx1}
      \event{wy1}{\DW{y}{1}}{right=of fr}
      \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
      \event{fa}{\DFS{\modeACQ}}{right=of ry1}
      \event{rx0}{\DR{x}{0}}{right=of fa}
      \sync{wx1}{fr}
      \sync{fr}{wy1}
      \sync{ry1}{fa}
      \sync{fa}{rx0}
      \rf{wy1}{ry1}
      \rf[out=10,in=170]{wx0}{rx0}
      \wk{wx0}{wx1}
    \end{tikzinline}}
\end{gather*}
\ref{5f} requires that $(\DFS{\modeREL})\le(\DW{y}{1})$.  \ref{5e} requires
that $(\DR{y}{1})\le(\DFS{\modeACQ})$.  The attempted execution is
\emph{invalid}: the stale read $(\DR{x}{0})$ violates the last requirement of
fulfillment (Definition \ref{def:rf}).

% Fences can simulate release/acquire access:
% \begin{gather*}  
%   x\GETS1\SEMI
%   \FENCE^{\modeREL}\SEMI
%   y\GETS1
%   \PAR
%   r\GETS y\SEMI
%   \FENCE^{\modeACQ}\SEMI
%   s\GETS x
%   \\[-1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%       \event{a1}{\DW{x}{1}}{}
%       \event{a2}{\DFS{\modeREL}}{right=of a1}
%       \po{a1}{a2}
%       \event{a3}{\DW{y}{1}}{right=of a2}
%       \po{a2}{a3}
%       \event{b1}{\DR{y}{1}}{right=3em of a3}
%       \event{b2}{\DFS{\modeACQ}}{right=of b1}
%       \po{b1}{b2}
%       \event{b3}{\DR{x}{0}}{right=of b2}
%       \po{b2}{b3}
%       \rf{a3}{b1}
%       \wkx[out=-170,in=-10]{b3}{a1}
%     \end{tikzinline}}
% \end{gather*}

Our semantics does not suffer the weaknesses of C11 fences, noted by
\citet[Figs.~5 and 6]{DBLP:conf/pldi/LahavVKHD17}. We omit $0$\hyp{}initialization
in these examples:
\begin{gather*}
  \taglabel{SC2}
    x\GETS1
    \PAR
    r\GETS x\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \event{b1}{\DR{x}{1}}{right=3em of a1}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \sync{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \sync{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=3em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \sync{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \sync{c2}{c3}
  \wk{b3}{c1}
  \rf{a1}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
  \\
  \taglabel{SC3}
    x\GETS1\SEMI   
    z\REL\GETS1\SEMI   
    \PAR
    r\ACQ\GETS z\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=.7em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{z}{1}}{right=of a1}
  \sync{a1}{a2}
  \event{b1}{\DRAcq{z}{1}}{right=2em of a2}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \sync{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \sync{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=2em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \sync{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \sync{c2}{c3}
  \wk{b3}{c1}
  \rf{a2}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
\end{gather*}
The executions are disallowed, due to cycles.  While these results are
immediate in our model, it is worth noting that they are anything but
immediate in the various models of C++.  \citet{DBLP:conf/pldi/LahavVKHD17}
devote an entire paper to debugging the model of SC access in C++.
% It is a testament to the
% complexity of C11 that it allows these executions.

% \paragraph{Silent Actions and Fences.}

% For the actions of a data model, we require that there is a set
% $\Int\subseteq\Act$ such that
% $\Int\cap\fdom(\rreads)=\Int\cap\fdom(\rwrites)=\emptyset$.  We say $\aAct$
% is \emph{silent} if $\aAct\in\Int$.

% By definition, silent actions neither read nor write.

% To model the fencing behavior of local reads and writes, our example language
% includes silent actions for \emph{read fences} $(\DFR{\amode})$ and
% \emph{write fences} $(\DFW[\aLoc]{\amode})$.  For modes $\modeRA$ and
% $\modeSC$, read fences are acquires and write fences are releases.  As with
% all actions, fences are ordered with respect to preceding acquired and
% following releases.  For mode $\modeRLX$, the fences do nothing.  We
% emphasize that \emph{write fences} are silent, and thus do not interfere with
% \emph{write actions} when fulfilling a read.

% For use in \textsection\ref{sec:opt}, we annotate write fences with the
% location of the local write.  We extend the notion of \emph{conflict}
% (Definition \ref{def:prefix}) to include write fence actions, thus ordering
% $(\DFW[\aLoc]{\amode})$ with respect to reads and writes on
% $\aLoc$\nofootnote{Using this version of write fences, one could rephrase the
%   write rules to move cover filtering from silent local writes to explicit
%   ``visible'' writes in Definition \ref{def:cover}---and the matching items
%   in \textsection\ref{sec:variants} and Definition \ref{def:semi:seq}
%   (6b). In this case, we would choose $(\relfilt{\aLoc} \aPSS)$ be the set
%   $\aPSS'\subseteq\aPSS$ such that $\aPS'\in\aPSS'$ when for every
%   $\cEv',\,\aEv'\in\Event'$, if $\labelingAct(\cEv')=(\DFW[\aLoc]{\amode})$,
%   $\aEv'$ is a release, and $\cEv'\le\aEv'$, then there is some
%   $\bEv'\in\Event'$ such that $\bEv$ (visibly) writes $\aLoc$ and
%   $\cEv'\lt\bEv'\le\aEv'$.  This has the same effect, but results in a
%   slightly different semantics. The choice between the two is arbitrary.}.
% The additional order is harmless, since write fences do not interfere with
% fulfillment.
% % Finally, we also modify write fence actions so that they
% % name the variable that was written: $\DFW[\aLoc]{\amode}$.  These new actions
% % remain silent.  

% We also include syntactic fences of the form
% ``$\FENCE^{\fmode} \SEMI \aCmd$.''  The semantics of syntactic fences
% is subtly different from the fencing behavior of
% $\modeRA$/$\modeSC$-accesses in C11.  Thus we include separate actions for syntactic
% fences: $(\DFS{\fmode})$.  The \emph{syntactic fence mode}
% $(\fmode \!\!\BNFDEF\!\! \modeREL \!\BNFSEP\! \modeACQ \!\BNFSEP\! \modeSC)$
% is either \emph{release}, \emph{acquire}, or \emph{sequentially-consistent}.
% $(\DFS{\modeREL})$ is a release. $(\DFS{\modeACQ})$ is an acquire.
% $(\DFS{\modeSC})$ is both a release and an acquire.

% The additional order of syntactic fences is captured by adding the following
% to Definition \ref{def:prefix} of \emph{prefixing}:
% \begin{enumerate}
% \item[5e.] if $\bEv$ reads and $\labelingAct(\aEv)=(\DFS{\modeACQ})$, then
%   $\aEv \lt' \bEv$, and
% \item[5f.] if $\labelingAct(\bEv)=(\DFS{\modeREL})$ and $\aEv$ writes, then
%   $\bEv \lt' \aEv$.
% \end{enumerate}
% The semantic rules are:
% \begin{align*}
%   \sem{\FENCE^{\fmode}\SEMI \aCmd} & =
%   (\DFS{\fmode}) \prefix \sem{\aCmd}
%   \\
%   \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
%   \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
%   \\[-.5ex] &
%   \mkern2mu\cup
%   \,\mathhl{(\DFR{\amode}) \;\prefix}\,\;
%   \sem{\aCmd}[\aLoc/\aReg]
%   \\
%   \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
%   \;\;\textstyle\parallel_\aVal (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
%   \\[-.5ex] &
%   \mkern2mu\cup
%   \,\mathhl{(\DFW[\aLoc]{\amode}) \;\prefix}\,\;
%   (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
% \end{align*}
% Our semantics does not suffer the weaknesses of C11 fences, noted by
% \citet[Figs.~5 and 6]{DBLP:conf/pldi/LahavVKHD17}. We omit $0$\hyp{}initialization
% in these examples:
% \begin{gather*}
%     x\GETS1
%     \PAR
%     r\GETS x\SEMI   
%     \FENCE^{\modeSC}\SEMI
%     r\GETS y  
%     \PAR
%     y\GETS 1 \SEMI
%     \FENCE^{\modeSC}\SEMI
%     r\GETS x  
%     \\[-.1ex]
%   \hbox{\begin{tikzinline}[node distance=1em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{b1}{\DR{x}{1}}{right=3em of a1}
%   \event{b2}{\DFS{\modeSC}}{right=of b1}
%   \po{b1}{b2}
%   \event{b3}{\DR{y}{0}}{right=of b2}
%   \po{b2}{b3}
%   \event{c1}{\DW{y}{1}}{right=3em of b3}
%   \event{c2}{\DFS{\modeSC}}{right=of c1}
%   \po{c1}{c2}
%   \event{c3}{\DR{x}{0}}{right=of c2}
%   \po{c2}{c3}
%   \wk{b3}{c1}
%   \rf{a1}{b1}
%   \wk[out=-170,in=-10]{c3}{a1}
%     \end{tikzinline}}
%   \\
%     x\GETS1\SEMI   
%     z\REL\GETS1\SEMI   
%     \PAR
%     r\ACQ\GETS z\SEMI   
%     \FENCE^{\modeSC}\SEMI
%     r\GETS y  
%     \PAR
%     y\GETS 1 \SEMI
%     \FENCE^{\modeSC}\SEMI
%     r\GETS x  
%     \\[-.1ex]
%   \hbox{\begin{tikzinline}[node distance=.7em]
%   \event{a1}{\DW{x}{1}}{}
%   \event{a2}{\DWRel{z}{1}}{right=of a1}
%   \po{a1}{a2}
%   \event{b1}{\DRAcq{z}{1}}{right=2em of a2}
%   \event{b2}{\DFS{\modeSC}}{right=of b1}
%   \po{b1}{b2}
%   \event{b3}{\DR{y}{0}}{right=of b2}
%   \po{b2}{b3}
%   \event{c1}{\DW{y}{1}}{right=2em of b3}
%   \event{c2}{\DFS{\modeSC}}{right=of c1}
%   \po{c1}{c2}
%   \event{c3}{\DR{x}{0}}{right=of c2}
%   \po{c2}{c3}
%   \wk{b3}{c1}
%   \rf{a2}{b1}
%   \wk[out=-170,in=-10]{c3}{a1}
%     \end{tikzinline}}
% \end{gather*}
% The executions are disallowed, due to cycles.  It is a testament to the
% complexity of C11 that it allows these executions.

\paragraph{Address Calculation}
In the definition of a data model, we require
that locations have the form $\aLoc\!\!\BNFDEF\!\!\REF{\cVal}$, where $\cVal$
is a value.  Expressions may include neither memory locations nor the
operator $\REF{\cExp}^{\amode}$.
In our example language, we update the syntax of commands:
\begin{gather*}
  \aCmd
  \BNFDEF \cdots
  \BNFSEP \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
  \BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
\end{gather*}
For degenerate programs that include only constant references (every
expression $\REF{\cExp}^\amode$ satisfies $\cExp=\cVal$, for some $\cVal$), the
following semantics produces exactly the same executions as before.
\begin{align*}
  \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_\cVal\bigcup_\aVal\; (\;\mathhl{\cExp=\cVal} \mid \DRmode{\REF{\cVal}}\aVal) \prefix (\;\mathhl{\cExp=\cVal} \guard\sem{\aCmd}[\REF{\cVal}/\aReg])
  % \\[-.5ex] & \mkern2mu\cup
  % \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\;\mathhl{\cExp=\cVal}\mid\DFR{\amode}) \prefix
  % \sem{\aCmd}[\REF{\cVal}/\aReg]
  \\
  \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
  \\[-1ex]
  &\mkern-68mu\hbox to 0pt{$\begin{aligned}
    &\textstyle\parallel_\cVal\bigcup_\aVal\;(\;\mathhl{\cExp=\cVal} \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix (\;\mathhl{\cExp=\cVal} \guard \sem{\aCmd}[\aExp/\REF{\cVal}])
    \\[-.5ex]  \cup\!&
    \textstyle\parallel_{\cVal}\phantom{\bigcup_\aVal}\; %(\;\mathhl{\cExp=\cVal}\mid\DFW[\REF{\cVal}]{\amode}) \prefix
    (\relfilt{\REF{\cVal}} (\;\mathhl{\cExp=\cVal} \guard \sem{\aCmd}[\aExp/\REF{\cVal}]))
  \end{aligned}$}
  % \\[-9.5ex]
  % \sem{\;\mathhl{\REF{\cExp}^\amode}\GETS\aExp\SEMI \aCmd} & =
  % \\[6ex]
\end{align*}
% \begin{aligned}
%   \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
%   \textstyle\bigcup_{\cVal,\aVal}\; (\cExp=\cVal \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
%   \\[-.5ex] & \mkern2mu\cup
%   \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFR{\amode}) \prefix
%   \sem{\aCmd}[\REF{\cVal}/\aReg]
%   \\
%   \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
%   \\[-1ex]
%   &\mkern-65mu\hbox to 0pt{$\begin{aligned}
%     &\textstyle\parallel_{\cVal,\aVal}\;(\cExp=\cVal \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
%     \\[-.5ex]  \cup\!&
%     \textstyle\parallel_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFW{\amode}) \prefix
%     (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
%   \end{aligned}$}
% \end{aligned}

\labeltext{Let}{page:disjunction2} us revisit the discussion of the use of \!$\PAR$\!
in Candidate~\ref{cand:sc}.
Note that 
\begin{math}
  \sem{[r] \GETS 0\SEMI [0]\GETS \BANG r}
\end{math}
includes both of the following pomsets (``$\BANG \aExp$'' evaluates to $1$ if
$\aExp$ is $0$, and $0$ otherwise):
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{[0]}{1}}{right=of a}
      \co{a}{b}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  %\\[-1.5ex]\intertext{and:}\\[-5ex]
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ1\mathbin{\mid}\DW{[1]}{0}}{}
      \event{b}{r\EQ1\mathbin{\mid}\DW{[0]}{0}}{right=of a}
    \end{tikzinline}}%\;\;\cdots
\end{align*}
By using \!$\PAR$\!, it also includes:
\begin{gather}
  \label{alanAddress}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{[0]}{1}}{right=of a}
      \co{a}{b}
      %\event{c}{r\EQ1\mathbin{\mid}\DW{[1]}{0}}{right=of b}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{[0]}{0}}{}
      \event{b}{r\EQ1\mathbin{\mid}\DW{[1]}{0}}{right=of a}
      \co{a}{b}
      %\event{c}{r\EQ1\mathbin{\mid}\DW{[1]}{0}}{right=of b}
    \end{tikzinline}}%\;\;\cdots
\end{gather}
In this example, the events that coalesce correspond to different statements
in the syntax.


\labeltext{Because}{page:strengthening} we do not enforce order between reads, there is some danger that
address calculations could introduce anomalous behaviors that arise \emph{out of thin air}
(\oota) \cite{DBLP:conf/esop/BattyMNPS15}.  Consider the following attempted
execution, where all memory addresses are initialized to $0$, except that
$\REF{2}$ is $1$ and $\REF{1}$ is $2$:
\begin{gather*}
  \taglabel{OOTA2}
  \aReg\GETS y\SEMI \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \PAR
  \aReg\GETS x\SEMI \bReg\GETS \REF{\aReg}\SEMI y\GETS \bReg
  %x\GETS\REF{y} \PAR y\GETS\REF{x}
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{2}}{}
  \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
  \event{a3}{\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=10,in=170]{a1}{a3}
  \event{b1}{\DR{x}{1}}{right=3em of a3}
  \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
  \event{b3}{\DW{y}{2}}{right=of b2}
  \po{b2}{b3}
  \po[out=10,in=170]{b1}{b3}
  \rf[out=-170,in=-10]{b3}{a1}
  \rf{a3}{b1}
    \end{tikzinline}}
\end{gather*}
Although there is no order enforced between the reads, the read-to-write
order induced by the semantics is sufficient to prohibit this \oota{}
behavior.  Note the intermediate state:
\begin{gather*}
  \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\aReg{=}2\mid\DR{\REF{2}}{1}}{}
  \event{a3}{\aReg{=}2\mid\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}
The precondition on the write is required by causal strengthening in
Definition~\ref{def:mmpomset}: if $\bEv\le\aEv$ then $\labelingForm(\aEv)$
implies $\labelingForm(\bEv)$.

\paragraph{Read-Modify-Write} We discuss \RMW\ operations that work on a
single location in memory, such as \emph{fetch-and-add} ($\FADD$) and
\emph{compare-and-swap} ($\CAS$).  These operations can be modeled using read/write
actions or using an additional relation between events.  The second approach
is more general and less obvious, therefore we explain it here.

In Definition \ref{def:mmpomset}, we require that a \emph{(memory model) pomset}
be a tuple $(\Event, {\le}, \labeling, \rrmw)$, where ${\rrmw}\subseteq{\le}$
relates the two events of a successful \RMW.  Additionally, we require that:
\begin{itemize}
\item If $\cEv$, $\aEv$ write the same $x$, $\cEv\gtN \aEv$ and $\bEv \xrmw \aEv$ then  $\cEv\gtN \bEv$.
\item If $\cEv$, $\aEv$ write the same $x$, $\bEv\gtN \cEv$ and $\bEv \xrmw \aEv$ then  $\aEv\gtN \cEv$.
\end{itemize}
In Definition~\ref{def:downset}, we require that downsets are \RMW\
closed:
$\Event'\subseteq\{ \bEv \in \Event \mid \exists\aEv\in\Event'.\; \aEv\xrmw\bEv\}$.
% ${\le'}={\le}\restrict{\Event'}$, 
% ${\xrmw'}={\xrmw}\restrict{\Event'}$, and
% ${\labeling'}={\labeling}\restrict{\Event'}$.  

Other than these two changes, nothing else changes.  In particular, \RMW{}s
require no special treatment in Definition~\ref{def:par}: the constituent
events of an \RMW{} may coalesce with other events as a result of parallel
composition.  We elide the obvious and tedious semantic rules that generate $\rrmw$.

% \begin{scope}
% \renewcommand{\aEv}{r}
% In Definition \ref{def:rf}, require that when $\bEv$ \emph{fulfills $\aEv$ on
%   $\aLoc$}:
% \begin{itemize}
% %\item there is no pair $(r,w)\in{\rrmw}$ such that $r\gtN\bEv\gtN w$, and
% \item if
%   $\aEv \gtN \bEv$,
%   $\bEv$ writes to $\aLoc$, and
%   $(\aEv,w)\in{\rrmw}$, 
%   then $w \gtN \bEv$.
% \end{itemize}
% \end{scope}
This definition ensures atomicity, disallowing executions such as
\cite[Ex.~3.2]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  \taglabel{RMW1}
  \aLoc\GETS0\SEMI\bReg\GETS \FADD^{\modeRLX,\modeRLX}(\aLoc)
  \PAR
  x\GETS 2\SEMI s\GETS x
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\DR{x}{0}}{}
  \event{a1}{\DW{x}{0}}{left=of a2}
  \rf{a1}{a2}
  \event{a3}{\DW{x}{2}}{right=of a2}
  \wk{a2}{a3}
  \event{b2}{\DW{x}{1}}{right=of a3}
  \event{b3}{\DR{x}{1}}{right=of b2}
  \rmw[out=-15,in=-165]{a2}[below]{b2}
  \wk{a3}{b2}
  \rf{b2}{b3}
    \end{tikzinline}}
\end{gather*}

By using two actions rather than one, the definition allows examples such as the
following, which is allowed by \armeight{} 
\cite[Ex.~3.10]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  \taglabel{RMW2}
  r \GETS y\SEMI
  z \GETS r
  \PAR
  r\GETS z\SEMI
  x\GETS 0\SEMI
  s\GETS \FADD^{\modeRLX,\modeRA}(x) \SEMI
  y\GETS s{+}1
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{1}}{}
  \event{a2}{\DW{z}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b1}{\DR{z}{1}}{right=3em of a2}
  \rf{a2}{b1}
  \event{b2}{\DW{x}{0}}{right=of b1}
  \event{b3}{\DR{x}{0}}{right=of b2}
  \rf{b2}{b3}
  \event{b4}{\DWRel{x}{1}}{right=2em of b3}
  \rmw{b3}{b4}
  \event{b5}{\DW{y}{1}}{right=of b4}
  \sync[out=-15,in=-165]{b1}{b4}
  \po[out=-20,in=-160]{b3}{b5}
  \rf[out=170,in=10]{b5}{a1}
    \end{tikzinline}}
\end{gather*}

