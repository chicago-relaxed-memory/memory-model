\section{Test Cases and Additional Features}
\label{sec:variants}

After discussing a few test cases, we extend the model to include additional
features: fences, address calculation, and read-modify-write
(\RMW)\footnote{The proofs given later in the paper extend to all of these
  features, with one exception: we believe the \armeight/\tso-compilation
  strategy is correct for \RMW---it is borrowed from
  \citet{DBLP:journals/pacmpl/PodkopaevLV19}---but have not proved it.}.  We
then provide an alternative semantics that supports full sequential
composition, building $\sem{\aCmd\SEMI\bCmd}$ from $\sem{\aCmd}$ and
$\sem{\bCmd}$.

\paragraph{Test Cases.}
Our model gives the desired results for the test cases of \citet{PughWebsite},
\citet[\textsection 5.3]{SevcikThesis}, and \citet[\textsection
4]{DBLP:conf/esop/BattyMNPS15}.  It also agrees with the ``surprising and
controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}.

We present two examples that are hallmarks of \mca{} architectures.
The analysis follows from a few simple principles.  
% \begin{gather*}
%   \renewcommand{\arraycolsep}{1pt}
%   \hbox{\small
%     $\begin{array}{ccccc}
%     &x\GETS0\SEMI x\GETS 1
%     &\PAR&
%     r\GETS x \SEMI s\GETS y
%     %\IF{x}\THEN r\GETS y \FI
%     \\
%     \PAR
%     &y\GETS0\SEMI y\GETS 1
%     &\PAR&
%     r\GETS y \SEMI s\GETS x
%     %\IF{y}\THEN s\GETS x \FI
%   \end{array}$}
%   \quad
%   \hbox{\begin{tikzinlinesmall}[node distance=.5em and 1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \rf{wx1}{rx1}
%   \rf[bend left]{wy0}{ry0}
%   \rf{wy1}{ry1}
%   \rf[bend right]{wx0}{rx0}
%   \wk{rx0}{wx1}
%   \wk{ry0}{wy1}
%     \end{tikzinlinesmall}}
% \end{gather*}
\begin{gather*}
  \\[-2.5ex]
  \renewcommand{\arraycolsep}{1pt}
  \hbox{\small
    $\begin{array}{ccccc}
    &x\GETS0\SEMI x\GETS 1
    &\PAR&
    r\GETS x\ACQ \SEMI s\GETS y
    %\IF{x}\THEN r\GETS y \FI
    \\
    \PAR
    &y\GETS0\SEMI y\GETS 1
    &\PAR&
    r\GETS y\ACQ \SEMI s\GETS x
    %\IF{y}\THEN s\GETS x \FI
  \end{array}$}
  \quad
  \smash{\hbox{\begin{tikzinlinesmall}[baseline=-10pt,node distance=.5em and 1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{below=2ex of wx0}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DRAcq{y}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DRAcq{x}{1}}{right=2.5 em of wx1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \rf{wx1}{rx1}
  \rf[bend left]{wy0}{ry0}
  \rf{wy1}{ry1}
  \rf[bend right]{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
    \end{tikzinlinesmall}}}
  \\[-1ex]
\end{gather*}
In this variant of \iriw\ (Independent Reads of Independent Writes), order 
is imposed by \emph{coherence} (between the writes), \emph{fulfillment}
(between read and write), and \emph{fencing} (from acquiring read to relaxed read).
Given the evident cycle, the candidate execution is invalid.
% Note that if you enforce the dependency between the reads, then the execution
% is disallowed, because the is a cycle on weak edges restricted to $x$:
% \begin{math}
%   (\DW{x}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}
% then
% \begin{math}
%   (\DW{y}{1})\le (\DR{y}{0}) \gtN (\DW{y}{1})
% \end{math}
% therefore
% \begin{math}
%   (\DW{x}{1}) \gtN  (\DW{y}{1});
% \end{math}

It is also impossible for all threads to read $1$ in the following, due to
\emph{control dependencies}, \emph{coherence}, and \emph{fulfillment}.
\begin{gather*}
  \hbox{\small$\IF{x}\THEN y\GETS0 \FI \SEMI y\GETS1
  {\PAR}
  \IF{y}\THEN z\GETS0 \FI \SEMI z\GETS1
  {\PAR}
  \IF{z}\THEN x\GETS0 \FI \SEMI x\GETS1
  $}
  \\[-.5ex]
  \hbox{\begin{tikzinlinesmall}[node distance=1em]
  \event{a1}{\DR{x}{1}}{}
  \event{a2}{\DW{y}{0}}{right=of a1}
  \po{a1}{a2}
  \event{a3}{\DW{y}{1}}{right=of a2}
  \wk{a2}{a3}
  \event{b1}{\DR{x}{1}}{right=of a3}
  \event{b2}{\DW{y}{0}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DW{y}{1}}{right=of b2}
  \wk{b2}{b3}
  \event{c1}{\DR{x}{1}}{right=of b3}
  \event{c2}{\DW{y}{0}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DW{y}{1}}{right=of c2}
  \wk{c2}{c3}
  \rf{a3}{b1}
  \rf{b3}{c1}
  \rf[out=173,in=7]{c3}{a1}  
    \end{tikzinlinesmall}}
\end{gather*}

In either example, the execution is allowed if the cycle is broken---for
example, by changing $x\ACQ$ to $x\RLX$ in \iriw.


% \citet{PughWebsite} developed a set of twenty {causality test cases} in the
% process of revising the Java Memory Model (JMM)
% \cite{Manson:2005:JMM:1047659.1040336}.
% %Using hand calculation, we have confirmed that
% Our model gives the desired result for all twenty cases,
% unrolling loops as necessary.
% % confirmed that our model gives the desired result these test cases, with the
% % following caveats: to model TC14 and TC15 we must unroll loops; the behaviors
% % of TC1 and TC8 are only allowed in our model if the inferred range of
% % variables is included as a global assumption in the logic. 
% Our model also gives the desired results for the examples of
% \citet{PughWebsite}, \citet[\textsection 5.3]{SevcikThesis},
% \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15}.  Our model agrees with
% ``surprising and controversial behaviors'' of
% \citet[\textsection 8]{Manson:2005:JMM:1047659.1040336}.  We elide the
% details.
% \textsection\ref{sec:examples} develops some of these examples.

\paragraph{Silent Actions and Fences.}

For the actions of a data model, we require that there is a set
$\Int\subseteq\Act$ such that
$\Int\cap\fdom(\rreads)=\Int\cap\fdom(\rwrites)=\emptyset$.  We say $\aAct$
is \emph{silent} if $\aAct\in\Int$.  By definition, silent actions neither
read nor write.

To model the fencing behavior of local reads and writes, our example language
includes internal actions of the form $\DFR{\amode}$ and $\DFW{\amode}$.  For
$\amode\in\{\modeRA,\,\modeSC\}$, $\DFR{\amode}$ is an acquire, and
$\DFW{\amode}$ is a release.  The fences with access mode $\modeRLX$ do
nothing; we include them only to remove case analysis from the definitions.

Because the semantics of syntactic fences is subtly different from the
fencing behavior of $\modeRA$/$\modeSC$-accesses, our example language
includes separate internal actions for syntactic fences: $\DFS{\fmode}$.  The
\emph{syntactic fence mode}
$(\fmode \!\!\BNFDEF\!\! \modeREL \!\BNFSEP\! \modeACQ \!\BNFSEP\! \modeSC)$ is either
\emph{release}, \emph{acquire}, or \emph{sequentially-consistent}.
$\DFS{\modeREL}$ is a release. $\DFS{\modeACQ}$ is an acquire.
$\DFS{\modeSC}$ is both a release and an acquire.

To Definition \ref{def:prefix} of prefixing, add:
\begin{enumerate}
\item[5e.] if $\bEv$ reads and $\labelingAct(\aEv)=\DFS{\modeACQ}$, then
  $\aEv \lt' \bEv$, and
\item[5f.] if $\labelingAct(\bEv)=\DFS{\modeREL}$ and $\aEv$ writes, then
  $\bEv \lt' \aEv$.
\end{enumerate}

As concrete syntax for commands, we write ``$\FENCE^{\fmode} \SEMI \aCmd$.''
\begin{align*}
  \sem{\FENCE^{\fmode}\SEMI \aCmd} & =
  (\DFS{\fmode}) \prefix \sem{\aCmd}
  \\
  \sem{\aReg\GETS\aLoc^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_\aVal\; (\DRmode\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]  
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFR{\amode}) \;\prefix}\,\;
  \sem{\aCmd}[\aLoc/\aReg]
  \\
  \sem{\aLoc^\amode\GETS\aExp\SEMI \aCmd} & =
  \textstyle\PAR_\aVal\; (\aExp=\aVal \mid \DWmode\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]
  \\[-.5ex] &
  \mkern2mu\cup
  \,\mathhl{(\DFW{\amode}) \;\prefix}\,\;
  (\relfilt{\aLoc} \sem{\aCmd}[\aExp/\aLoc])
\end{align*}

Our semantics does not suffer the weaknesses of C11 fences, noted by
\citet[Figs.~5 and 6]{DBLP:conf/pldi/LahavVKHD17}. We omit $0$-initialization
in these examples:
\begin{gather*}
    x\GETS1
    \PAR
    r\GETS x\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DW{x}{1}}{}
  \event{b1}{\DR{x}{1}}{right=3em of a1}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \po{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=3em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \po{c2}{c3}
  \wk{b3}{c1}
  \rf{a1}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
  \\
    x\GETS1\SEMI   
    z\REL\GETS1\SEMI   
    \PAR
    r\ACQ\GETS z\SEMI   
    \FENCE^{\modeSC}\SEMI
    r\GETS y  
    \PAR
    y\GETS 1 \SEMI
    \FENCE^{\modeSC}\SEMI
    r\GETS x  
    \\[-.1ex]
  \hbox{\begin{tikzinline}[node distance=.7em]
  \event{a1}{\DW{x}{1}}{}
  \event{a2}{\DWRel{z}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b1}{\DRAcq{z}{1}}{right=2em of a2}
  \event{b2}{\DFS{\modeSC}}{right=of b1}
  \po{b1}{b2}
  \event{b3}{\DR{y}{0}}{right=of b2}
  \po{b2}{b3}
  \event{c1}{\DW{y}{1}}{right=2em of b3}
  \event{c2}{\DFS{\modeSC}}{right=of c1}
  \po{c1}{c2}
  \event{c3}{\DR{x}{0}}{right=of c2}
  \po{c2}{c3}
  \wk{b3}{c1}
  \rf{a2}{b1}
  \wk[out=-170,in=-10]{c3}{a1}
    \end{tikzinline}}
\end{gather*}
The executions are disallowed, due to cycles.  It is a testament to the
complexity of C11 that it allows these executions.

\paragraph{Address Calculation.}
In the definition of a data model, remove the location set $\Loc$ and require
that locations have the form $\aLoc\!\!\BNFDEF\!\!\REF{\cVal}$, where $\cVal$
is a value.  Expressions may include neither memory locations nor the
operator $\REF{\cExp}^{\amode}$.
In our example language, we update the syntax of commands:
\begin{gather*}
  \aCmd
  \BNFDEF \cdots
  \BNFSEP \aReg\GETS\REF{\cExp}^{\amode}\SEMI \aCmd 
  \BNFSEP \REF{\cExp}^{\amode}\GETS\aExp\SEMI \aCmd
  \\
\begin{aligned}
  \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
  \textstyle\bigcup_{\cVal,\aVal}\; (\;\mathhl{\cExp=\cVal} \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
  \\[-.5ex] & \mkern2mu\cup
  \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\;\mathhl{\cExp=\cVal}\mid\DFR{\amode}) \prefix
  \sem{\aCmd}[\REF{\cVal}/\aReg]
  \\
  \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
  \\[-1ex]
  &\mkern-65mu\hbox to 0pt{$\begin{aligned}
    &\textstyle\PAR_{\cVal,\aVal}\;(\;\mathhl{\cExp=\cVal} \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
    \\[-.5ex]  \cup\!&
    \textstyle\PAR_{\cVal\phantom{,\aVal}}\; (\;\mathhl{\cExp=\cVal}\mid\DFW{\amode}) \prefix
    (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
  \end{aligned}$}
  % \\[-9.5ex]
  % \sem{\;\mathhl{\REF{\cExp}^\amode}\GETS\aExp\SEMI \aCmd} & =
  % \\[6ex]
\end{aligned}
% \begin{aligned}
%   \sem{\aReg\GETS\REF{\cExp}^\amode\SEMI \aCmd} & =
%   \textstyle\bigcup_{\cVal,\aVal}\; (\cExp=\cVal \mid \DRmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\REF{\cVal}/\aReg]  
%   \\[-.5ex] & \mkern2mu\cup
%   \textstyle\bigcup_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFR{\amode}) \prefix
%   \sem{\aCmd}[\REF{\cVal}/\aReg]
%   \\
%   \sem{\REF{\cExp}^\amode\GETS\aExp\SEMI \aCmd} & =
%   \\[-1ex]
%   &\mkern-65mu\hbox to 0pt{$\begin{aligned}
%     &\textstyle\PAR_{\cVal,\aVal}\;(\cExp=\cVal \land \aExp=\aVal \mid \DWmode{\REF{\cVal}}\aVal) \prefix \sem{\aCmd}[\aExp/\REF{\cVal}]
%     \\[-.5ex]  \cup\!&
%     \textstyle\PAR_{\cVal\phantom{,\aVal}}\; (\cExp=\cVal\mid\DFW{\amode}) \prefix
%     (\relfilt{\REF{\cVal}} \sem{\aCmd}[\aExp/\REF{\cVal}])    
%   \end{aligned}$}
% \end{aligned}
\end{gather*}

Let us revisit the discussion of the use of \!$\PAR$\!
in Candidate~\ref{cand2.9}.
Note that 
\begin{math}
  \sem{a[r] \GETS 0\SEMI a[0]\GETS \BANG r}
\end{math}
includes both of the following pomsets (``$\BANG \aExp$'' evaluates to $1$ if
$\aExp$ is $0$, and $0$ otherwise):
\begin{align*}
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ0\mathbin{\mid}\DW{a[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
    \end{tikzinline}}%\;\;\cdots
  \qquad
  %\\[-1.5ex]\intertext{and:}\\[-5ex]
  \hbox{\begin{tikzinline}[node distance=.2em]
      \event{a}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{}
      \event{b}{r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{right=of a}
    \end{tikzinline}}%\;\;\cdots
\end{align*}
By using \!$\PAR$\!, it also includes:
\begin{gather*}
  \hbox{\begin{tikzinline}[node distance=.5em]
      \event{a}{r\EQ0\lor r\EQ1\mathbin{\mid}\DW{a[0]}{0}}{}
      \event{b}{r\EQ0\mathbin{\mid}\DW{a[0]}{1}}{right=of a}
      %\event{c}{r\EQ1\mathbin{\mid}\DW{a[1]}{0}}{right=of b}
    \end{tikzinline}}%\;\;\cdots
\end{gather*}
In this example, the events that coalesce correspond to different statements
in the syntax.


Because we do not enforce order between reads, there is some danger that
address calculations could allow thin air behavior.  Consider the following
attempted execution, where all memory addresses are initialized to $0$,
except that $\REF{2}$ is $1$ and $\REF{1}$ is $2$:
\begin{gather*}
  \aReg\GETS y\SEMI \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \PAR
  \aReg\GETS x\SEMI \bReg\GETS \REF{\aReg}\SEMI y\GETS \bReg
  %x\GETS\REF{y} \PAR y\GETS\REF{x}
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{2}}{}
  \event{a2}{\DR{\REF{2}}{1}}{right=of a1}
  \event{a3}{\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
  \po[out=10,in=170]{a1}{a3}
  \event{b1}{\DR{x}{1}}{right=3em of a3}
  \event{b2}{\DR{\REF{1}}{2}}{right=of b1}
  \event{b3}{\DW{y}{2}}{right=of b2}
  \po{b2}{b3}
  \po[out=10,in=170]{b1}{b3}
  \rf[out=-170,in=-10]{b3}{a1}
  \rf{a3}{b1}
    \end{tikzinline}}
\end{gather*}
Although there is no order enforced between the reads, the read-to-write
order induced by the semantics is sufficient to prohibit this thin-air
behavior.  Note the intermediate state:
\begin{gather*}
  \bReg\GETS \REF{\aReg}\SEMI x\GETS \bReg
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\aReg{=}2\mid\DR{\REF{2}}{1}}{}
  \event{a3}{\aReg{=}2\mid\DW{x}{1}}{right=of a2}
  \po{a2}{a3}
    \end{tikzinline}}
\end{gather*}
The precondition on the write is required by the last clause of
Definition~\ref{def:mmpomset}: if $\bEv\le\aEv$ then $\labelingForm(\aEv)$
implies $\labelingForm(\bEv)$.

\paragraph{Read-Modify-Write.} We discuss \RMW\ operations that work on a
single location in memory, such as Fetch-And-Add ($\FADD$) and
compare-and-swap ($\CAS$).  These operations can be modeled using read/write
actions or using an additional relation between events.  The second approach
is more general and less obvious, therefore we explain it here.

In Definition \ref{def:mmpomset}, require that a \emph{(memory model) pomset}
be a tuple $(\Event, {\le}, \labeling, \xrmw)$, where ${\xrmw}\subseteq{\le}$
relates the two events of a successful \RMW.  Additionally, require that:
\begin{itemize}
\item If $\cEv$ and $\aEv$ both write $x$, $\cEv\gtN \aEv$ and $\bEv \xrmw \aEv$ then  $\cEv\gtN \bEv$.
\item If $\cEv$ and $\aEv$ both write $x$, $\bEv\gtN \cEv$ and $\bEv \xrmw \aEv$ then  $\aEv\gtN \cEv$.
\end{itemize}
We elide the obvious and tedious semantic rules.

% \begin{scope}
% \renewcommand{\aEv}{r}
% In Definition \ref{def:rf}, require that when $\bEv$ \emph{fulfills $\aEv$ on
%   $\aLoc$}:
% \begin{itemize}
% %\item there is no pair $(r,w)\in{\rrmw}$ such that $r\gtN\bEv\gtN w$, and
% \item if
%   $\aEv \gtN \bEv$,
%   $\bEv$ writes to $\aLoc$, and
%   $(\aEv,w)\in{\rrmw}$, 
%   then $w \gtN \bEv$.
% \end{itemize}
% \end{scope}
This definition ensures atomicity, disallowing executions such as
\cite[Ex.~3.2]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  \aLoc\GETS0\SEMI\bReg\GETS \FADD(\aLoc)
  \PAR
  x\GETS 2\SEMI s\GETS x
  \\
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a2}{\DR{x}{0}}{}
  \event{a1}{\DW{x}{0}}{left=of a2}
  \rf{a1}{a2}
  \event{a3}{\DW{x}{2}}{right=of a2}
  \wk{a2}{a3}
  \event{b2}{\DW{x}{1}}{right=of a3}
  \event{b3}{\DR{x}{1}}{right=of b2}
  \rmw[out=-15,in=-165]{a2}[below]{b2}
  \wk{a3}{b2}
  \rf{b2}{b3}
    \end{tikzinline}}
\end{gather*}

By using two actions rather than one, we allow examples such as the
following, which is allowed by \armeight{} 
\cite[Ex.~3.10]{DBLP:journals/pacmpl/PodkopaevLV19}:
\begin{gather*}
  r \GETS y\SEMI
  z \GETS r
  \PAR
  r\GETS z\SEMI
  x\GETS 0\SEMI
  s\GETS \FADD^{\modeRLX,\modeRA}(x) \SEMI
  y\GETS s{+}1
  \\[-1ex]
  \hbox{\begin{tikzinline}[node distance=1em]
  \event{a1}{\DR{y}{1}}{}
  \event{a2}{\DW{z}{1}}{right=of a1}
  \po{a1}{a2}
  \event{b1}{\DR{z}{1}}{right=3em of a2}
  \rf{a2}{b1}
  \event{b2}{\DW{x}{0}}{right=of b1}
  \event{b3}{\DR{x}{0}}{right=of b2}
  \rf{b2}{b3}
  \event{b4}{\DWRel{x}{1}}{right=2em of b3}
  \rmw{b3}{b4}
  \event{b5}{\DW{y}{1}}{right=of b4}
  \po[out=-15,in=-165]{b1}{b4}
  \po[out=-20,in=-160]{b3}{b5}
  \rf[out=170,in=10]{b5}{a1}
    \end{tikzinline}}
\end{gather*}

\paragraph{Sequential Composition.}
We refactor the syntax:
\begin{align*}
  \aCmd,\,\bCmd
  \BNFDEF& \SKIP
  \BNFSEP \FENCE^{\fmode}
  \BNFSEP \aReg\GETS\aExp
  \BNFSEP \aReg\GETS\aLoc^{\amode} 
  \BNFSEP \aLoc^{\amode}\GETS\aExp
  \\[-.5ex]
  \BNFSEP&\aCmd \PAR \bCmd
  \BNFSEP\aCmd \SEMI \bCmd
  \BNFSEP \VAR\aLoc
  \BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \bCmd \FI
\end{align*}
For clarity, we do not include address calculation or \RMW{}s in this
subsection.


We introduce explicit substitutions,
following the conventions of \citet{DBLP:conf/icalp/RitterP97}: 
\begin{align*}
  \aLocReg\!\!\BNFDEF\!\! \aLoc \!\BNFSEP\! \aReg
  &&
  \aSub,\,\bSub\!\!\BNFDEF\!\! \SUBEMP \!\BNFSEP\! \SUBPAR{\aSub}{\aExp/\aLocReg}
  \!\BNFSEP\! \aSub\SUBSEQ\bSub
\end{align*}
We write application as $\aForm\SUBAPP\aSub$ and write
$\SUBPAR{\SUBEMP}{\aExp/\aLocReg}$ as $\SUB{\aExp/\aLocReg}$.  The definition
of application is not complicated our lack of support for renaming locations:
We only apply substitutions to formulae, which have no binders.

% Goal:
% \begin{math}
%   (\aForm\aSub)\bSub =
%   \aForm(\aSub;\bSub)
% \end{math}
% Pure substitution: $\fdom(\aSub)$ disjoint $\fcodom(\aSub)$.
% Pure substitutions are idempotent.
% $\aSub$ and $\bSub$ are composable if $\fdom(\aSub)$ disjoint $\fcodom(\bSub)$
% \begin{displaymath}
%   (\aSub;\bSub)(x) =
%   \begin{cases}
%     \aSub(\bSub(x)) & \text{if } x \in \fdom(\bSub)\\
%     \aSub(x) & \text{otherwise}
%   \end{cases}
% \end{displaymath}

Let $\Sub$ be the set of all (explicit) substitutions.  In a data model,
substitutions are silent actions: $\Sub\subseteq\Int$.  Pomsets may contain
at most one event $\cEv$ with a label in $\Sub$, and that may be no
$\aEv$ such that $\cEv\le\aEv$.

Substitutions track dependencies for the follower.

Write fence actions need to indicate which variable was written:
$\DFW[\aLoc]{\amode}$.  We extend the notion of \emph{conflict} to include
write fence actions (thus ordering them w.r.t.~reads and writes on the same
location).

To simplify the definition of the base cases, we use a literal notation for
pomsets, drawing substitutions as accepting states.  Let
$\aPS''\in\CLOSE{\aPS}$ if there is $\aPS'\in\PRE(\aPS)$ such that $\aPS''$
implies $\aPS'$ and $\aPS''$ is an augmentation of $\aPS'$.
The definitions for conditional and location binding are unchanged.
\begin{gather*}
  \begin{aligned}
  \sem{\SKIP} & \eqdef
  \CLOSE{\TIKZ{\final{f}{\SUBEMP}{}}}
  \\  
  \sem{\aReg\GETS\aExp} & \eqdef
  \CLOSE{\TIKZ{\final{f}{\SUB{\aExp/\aReg}}{}}}
  \\
  \sem{\FENCE^{\fmode}} & =
  \CLOSE{\TIKZ{
      \event{a}{\DFS{\fmode}}{}
      \final{f}{\SUBEMP}{right=of a}
    }} 
  \\
  \sem{\aReg\GETS\aLoc^\amode} & =
  \textstyle\bigcup_\aVal\;
  \CLOSE{\TIKZ{
      \event{a}{\DRmode\aLoc\aVal}{}
      \final{f}{\SUB{\aVal/\aReg}}{right=of a}
      \po{a}{f}
    }}
  \\[-.5ex] &
  \mkern2mu\cup
  \CLOSE{\TIKZ{
      \event{a}{\DFR{\amode}}{}
      \final{f}{\SUB{\aLoc/\aReg}}{right=of a}
      \po{a}{f}
    }}
  \\
  \sem{\aLoc^\amode\GETS\aExp} & =
  \textstyle\PAR_\aVal\;
  \CLOSE{\TIKZ{
      \event{a}{\aExp=\aVal \mid \DWmode\aLoc\aVal}{}
      \final{f}{\aExp=\aVal \mid \SUB{\aExp/\aLoc}}{right=of a}
    }}
  \\[-.5ex] &
  \mkern2mu\cup
  \CLOSE{\TIKZ{
      \event{a}{\DFW[\aLoc]{\amode}}{}
      \final{f}{\SUB{\aExp/\aLoc}}{right=of a}
    }}
  \end{aligned}
  \\
  \begin{aligned}
    \sem{\aCmd \PAR \bCmd} &= \sem{\aCmd} \parallel \killS\sem{\bCmd}
    &
    \killS(\aPS)&=\{ \aEv\in\Event \mid \labelingAct(\aEv)\notin\Sub \}
    \\
    \sem{\aCmd \SEMI \bCmd} &= \sem{\aCmd} \sequence \sem{\bCmd}
    &
    \killS(\aPSS)&=\{\aPS\restrict{\killS(\aPS)} \mid \aPS\in\aPSS \}
  \end{aligned}
\end{gather*}
To ensure a unique accepting state, we break the symmetry of \!$\PAR$\!,
choosing to keep the substitution on the left.
% \begin{gather*}
%   \begin{aligned}
%     \killS(\aPS)&=\{ \aEv\in\Event \mid \labelingAct(\aEv)\notin\Sub \}
%     &
%     \killS(\aPSS)&=\{\aPS\restrict{\killS(\aPS)} \mid \aPS\in\aPSS \}
%   \end{aligned}
% \end{gather*}

% Relative to the previous definitions, the base cases are handled as follows:
% \begin{itemize}
% \item $\sem{\SKIP}$ introduces the identity substitution,
% \item $\sem{\aLoc\GETS\aExp}$ introduces $\SUB{\aExp/\aLoc}$,
% \item $\sem{\aReg\GETS\aExp}$ introduces $\SUB{\aExp/\aReg}$,
% \item $\sem{\aReg\GETS\aLoc}$, local rule, introduces $\SUB{\aLoc/\aReg}$,
% \item $\sem{\aReg\GETS\aLoc}$, nonlocal rule, introduces
%   $(\DR{\aLoc}{\aVal}) \lt \SUB{\aVal/\aReg}$.
% \end{itemize}
% Base cases:
% \begin{align*}
%   \sem{\SKIP}
%   =&
%   \TIKZ{\final{f}{}{}} 
%   \\
%   \sem{\aLoc\GETS\aExp}
%   =&
%   \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\aExp=\aVal\mid\DW\aLoc\aVal)}{}\final{f}{\aExp/\aLoc}{right=of a}}
%   \\
%   \sem{\aReg\GETS\aLoc}
%   =&
%   \TIKZ{\final{f}{\aLoc/\aReg}{}}
%   \cup
%   \textstyle\bigcup_\aVal\; \TIKZ{\event{a}{(\DR\aLoc\aVal)}{}\final{f}{\aLoc/\aReg}{right=of a}\po{a}{f}}
% \end{align*}


% Here's the def for prefixing:
% \begin{enumerate}
% \item[1.] $\Event' = \Event \uplus \{\bEv\}$,
% \item[2.] ${\le'}\supseteq{\le}$,
% \item[3a.] $\labelingAct'(\bEv) = \aAct$,
% \item[3b.] $\labelingForm'(\bEv)$ implies $\aForm$,
% \item[4a.] $\labelingAct'(\aEv) = \labelingAct(\aEv)$,
% \item[4b.] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
%   $\labelingForm'(\aEv)$ implies $\labelingForm(\aEv)[\aVal/\aLoc]$,
% \item[4c.] if $\bEv$ does not \externally read then $\labelingForm'(\aEv)$
%   implies $\labelingForm(\aEv)$, 
% \item[5a.] if $\labelingForm'(\aEv)$ does not imply $\labelingForm(\aEv)$ and
%   $\aEv$ writes, then $\bEv\lt'\aEv$,
% \item[5b.] if $\bEv$ and $\aEv$ are \external actions in conflict, then
%   $\bEv\lt'\aEv$,
% \item[5c.] if $\bEv$ is an acquire or $\aEv$ is a release, then
%   $\bEv \lt' \aEv$,
% \item[5d.] if $\bEv$ is an SC write and $\aEv$ is an SC read, then
%   $\bEv \lt' \aEv$, 
% \item[5e.] if $\bEv$ reads and $\labelingAct(\aEv)=\DFS{\modeACQ}$, then
%   $\aEv \lt' \bEv$,
% \item[5f.] if $\labelingAct(\bEv)=\DFS{\modeREL}$ and $\aEv$ writes, then
%   $\bEv \lt' \aEv$, and
% \item[6.] if $\bEv$ is a release, $\aEv_1$ is an acquire, $\aEv_1\le\aEv_2$, then $\labelingForm(\aEv_2)$
%   is location independent.
% \end{enumerate}



\begin{definition}
  \label{def:semi:seq}
  Let $\DISJUNCT(\aPSS)$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ if there
  are $\aPS^i\in\aPSS$ such $\Event' = \Event^i$, ${\le'}={\le^i}$,
  $\labelingAct'=\labelingAct^i$, and $\labelingForm'(\aEv)$ implies
  $\bigvee_i \labelingForm^i(\aEv)$.
  
  Let $(\aPSS^1 \sequence \aPSS^2)$ be the set
  $\{\aPS^1\in\aPSS^1\mid \disjoint{\Event^1}{\Sub}\}\cup \DISJUNCT(\aPSS')$
  where $\aPS'\in\aPSS'$ when there are $\aPS^1 \in \aPSS^1$,
  $\cEv\in\Event^1\cap\Sub$ and $\aPS^2\in\aPSS^2$ such that the following
  hold.  Let $\bEv$ range over $\Event^1\setminus\Sub$, and $\aEv$ range over
  $\Event^2$.
\begin{enumerate}
\item[1.] $\Event' = \Event^1\setminus\Sub \uplus \Event^2$,
\item[2.] ${\le'}\supseteq{\le^1}\cup{\le^2}$, 
\item[3a.] $\labelingAct'(\bEv) = \labelingAct^1(\bEv)$,
\item[3b.] $\labelingForm'(\bEv)$ implies $\labelingForm^1(\bEv)$,
\item[4a1.] $\labelingAct'(\aEv) = \labelingAct^2(\aEv)$,  for $\aEv\in\Event^2\setminus\Sub$,
\item[4a2.] $\labelingAct'(\aEv) =  \labelingAct^2(\aEv)\SUBSEQ\labelingAct^1(\cEv)$,  for $\aEv\in\Event^2\cap\Sub$, 
\item[4bc.] $\labelingForm'(\aEv)$ implies $\labelingForm^2(\aEv)\SUBAPP\labelingAct^1(\cEv)$,
% \item[4b.] if $\bEv$ \externally reads $\aVal$ from $\aLoc$ then
%   $\labelingForm'(\aEv)$ implies $\labelingForm^2(\aEv)[\aVal/\aLoc]$,
% \item[4c.] if $\bEv$ does not \externally read then $\labelingForm'(\aEv)$
%   implies $\labelingForm^2(\aEv)$,
\item[5a.] if $\labelingForm'(\aEv)$ does not imply $\labelingForm^2(\aEv)$ and
  $\aEv$ writes, then $\cEv\ORDER\aEv$,
\item[5b-f.] as before,
% \item[5b.] if $\bEv$ and $\aEv$ are \external actions in conflict, then
%   $\bEv\ORDER\aEv$,
% \item[5c.] if $\bEv$ is an acquire or $\aEv$ is a release, then
%   $\bEv \ORDER \aEv$,
% \item[5d.] if $\bEv$ is an SC write and $\aEv$ is an SC read, then
%   $\bEv \ORDER \aEv$, 
% \item[5e.] if $\bEv$ reads and $\labelingAct(\aEv)=\DFS{\modeACQ}$, then
%   $\aEv \ORDER \bEv$,
% \item[5f.] if $\labelingAct(\bEv)=\DFS{\modeREL}$ and $\aEv$ writes, then
%   $\bEv \ORDER \aEv$, 
\item[6a.] if $\bEv$ is a release, $\dEv\in\Event'$ is an acquire,
  $\bEv\le'\dEv\le'\aEv$, then $\labelingForm(\aEv)$ is location independent, and
\item[6b.] if $\labelingAct(\bEv)=\DFW[\aLoc]{\amode}$, $\bEv\le\aEv$, and
  $\aEv$ is a release that does not write $\aLoc$, then  some
  $\dEv$ writes $\aLoc$ and $\bEv\le'\dEv\le'\aEv$. %such that $\dEv$ %(explicitly)
\end{enumerate}
6b ensures the effect of $\relfilt{}$ in the local write rule.
\end{definition}


\begin{comment}
Plan: 
  a.  Define pom1; pom2  for pomsets
  b.  [| C1 ; C2 |] = cup { pom1; pom2 | pom1 in C1, pom2 in C2}

Def:
   pom1; pom2
             cup_L  L prefix pom2 
             where L is a  linearization of pom1
\end{comment}

% \section{Variations}

% \citet{2019-sp} define \emph{3-valued pomsets with preconditions} to model
% security flaws that arise from speculative evaluation in computer
% microarchitecture (such as Spectre \cite{DBLP:journals/corr/abs-1801-01203}).
% \begin{definition}
%   %\label{def:3valued}
%   A \emph{3-valued pomset with preconditions} is a tuple
%   $(\Event, {\le}, {\gtN}, \labeling)$, such that
%   \begin{itemize}
%   \item $\Event$ is a set of \emph{states},
%   \item $\labeling: \Event \fun (\Formulae\times\Act)$ is a \emph{labeling},
%   \item ${\le} \subseteq (\Event\times\Event)$ is a partial order, and
%   \item ${\gtN} \subseteq (\Event\times\Event)$ such that:
%     \begin{itemize}
%     \item\label{5a} if $\bEv \le \aEv$ then $\bEv \gtN \aEv$, \hfill
%       (Inclusion)
%     \item\label{5b} if $\bEv \le \aEv$ and $\aEv \gtN \bEv$ then
%       $\bEv = \aEv$, and \hfill (Consistency)
%     \item\label{5c} if $\cEv \le \bEv \gtN \aEv$ or $\cEv \gtN \bEv \le \aEv$
%       then $\cEv \gtN \aEv$.  \hfill (Semi-transitivity)
%     \end{itemize}
%   \end{itemize}

%   A \emph{(memory model) pomset} is a 3-valued pomset with preconditions,
%   such that
%   \begin{itemize}
%   \item if $\bEv\le\aEv$ then $\labelingForm(\aEv)$ implies
%     $\labelingForm(\bEv)$, and \hfill (Causal-strengthening)
%   \end{itemize}
% \end{definition}
% The axioms for $\gtN$ are adapted
% from~\citet[A1--A3]{DBLP:journals/dc/Lamport86}.  

% \begin{definition}
%   A pomset \emph{coherent} if, when restricted to events that read or write
%   any single location $\aLoc$, $\gtN$ forms a partial order.
% \end{definition}
