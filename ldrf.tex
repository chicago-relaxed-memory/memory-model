\section{Comparison to related work}\label{sec:ldrf}
A memory consistency model for a shared-memory multiprocessor defines the a read may return.  There has been extensive research on hardware and software memory models.~\citet{DBLP:journals/pacmpl/PodkopaevLV19} is a recent attempt to provide formal foundations to bridge the gap between the two.  \citet{AlglaveThesis} provides a historical and conceptual perspective on hardware memory models.  This paper focusses on software memory models.   For a survey and history of the Java Memory Model, we refer the reader to\citet{DBLP:journals/toplas/Lochbihler13}; for a survey and history of C11, we refer the reader to~\citet{DBLP:phd/ethos/Batty15}.  

~\citet{Batty17} motivates compositional methods in the context of relaxed memory.  This paper follows a line of work on relaxed memory models in the framework of true concurrency~\cite{DBLP:conf/lics/JeffreyR16,Pichon-Pharabod:2016:CSR:2837614.2837616,DBLP:conf/esop/CenciarelliKS07}.  

We discuss in more detail the relationship with the most closely related work.  

\subsection{3-Valued pomsets and Lamports axioms}
~\citet{DBLP:journals/dc/Lamport86} considers a transitive, acyclic relation $\lt$, and a relation $\gtN$ with the following axioms to connect $\lt,\gtN$, namely:
\begin{align*}
\aEv \gtN \bEv & \Rightarrow & \aEv \lt \bEv
\aEv \gtN \bEv &\Leftarrow& (\aEv \gtN \cEv \wedge\ \cEv \lt \bEv) \vee\ (\aEv \lt \cEv \wedge\ \cEv \gtN \bEv) \\
\aEv \lt \bEv &\Leftarrow& \aEv \lt \bEv_1 \gtN \bEv_2 \lt \bEv 
\end{align*}
In our setting, the basic ingredient of $\gtN$ is $\reco$, from which we can define the full $\gtN$ by closing by the above axioms. The $\gtN$ so defined is transitive.   Furthermore, if $\lt$ is acyclic and follows the idioms arising from programs, then the induced $\gtN$ is also acyclic.   This leads us to the three-valued  memory pomsets that we have considered in this paper. 

In a concurrency context, three valued transition relations are studied in modal transition systems~\citep{DBLP:conf/lics/LarsenT88, DBLP:conf/avmfss/Larsen89,DBLP:conf/avmfss/Larsen89} and the semantics of  three-valued temporal logics for such transition systems is studied in~\citep{DBLP:conf/concur/BrunsG00,DBLP:conf/esop/HuthJS01}. 

\subsection{Modeling the invalidation of load buffering}

In this subsection, we argue that our paper is relevant even to the reader who desires a semantics that invalidates load buffering.  

There are two related lines of research that suggest to prohibit the reordering of loads with following stores.  
\begin{itemize}
\item 
~\citet{Dolan:2018:BDR:3192366.3192421} imposes this restriction in order to ``bound data races in space and time''.  Thus, in their model, one can reason sequentially about the the assignment to $w$ and deduce that $x=1 \Rightarrow\ z= 1$ despite the concurrent races on $u$, and  the past and future races on $y$\footnote{Concurrent, past and future stated wrt assignment to $w$.}.   In this program $r,s$ are registers, and $x,y,z,u,v,w$ are shared variables.
\begin{align*}
\mbox{Thread 1: } & u \GETS 0 \SEMI y \GETS 1 \SEMI v^{rel}  \GETS 1 \SEMI z \GETS 2 \SEMI r \GETS u \SEMI y \GETS 3 \SEMI \\[-.5ex]
\mbox{Thread 2: } & y \GETS 2 \SEMI  \IF{v^{acq}==1} \THEN\ w \GETS 1 + y -y \SEMI u \GETS 1 \SEMI x \GETS 1  \FI \SEMI s \GETS u \SEMI  y \GETS 2 \SEMI
\end{align*}
\item ~\citet{BoehmOOTA} describes a series of ``\oota'' like examples, and uses this restriction to rule out example~\ref{rfub}.  
\end{itemize}

This restriction can be captured naturally in our model.  We make two changes.
\begin{itemize}
\item Modify the semantic rule for read to remove the possibility of an internal read:
  \begin{align*}
    \sem{\aReg\GETS\REF{\cExp}\SEMI \aCmd} & =
    \textstyle\bigcup_{\aLoc=\REF{\bVal}}\; ({\cExp}=\bVal) \guard \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] 
  \end{align*}
\item Modify item \ref{pre-read}b in the definition of prefixing to require
  order from a read to subsequent write:
  \begin{enumerate}
  \item[(\ref{pre-read}b$'$)] if $\aEv$ is a write then  $\cEv\lt'\aEv$ 
  \end{enumerate}
\end{itemize}
In \ref{pre-read}b$'$ we removed the ``or or $\labelingForm'(\aEv)$ implies
$\labelingForm(\aEv)$.''

While~\citet{Dolan:2018:BDR:3192366.3192421} already describes DRF and  the compilation to \armeight, our approach yields the following new insights.
\begin{itemize}
\item Compositional treatment of temporal invariants from\textsection\ref{sec:logic} holds mutatis mutandis, since all executions of the restricted model are already accounted for in the general model.

\item With regards to single-threaded optimizations in \textsection\ref{sec:opt}, our approach provides different methods to prove optimizations, that complement the extant methods of~\citet{Dolan:2018:BDR:3192366.3192421} with data sensitivity; for example, our methods provides a simple proof of  the transformation of $
\IF{\aExp}\THEN\ x \GETS 1 \SEMI \aCmd \ELSE x\GETS 1 \SEMI \bCmd\FI$ to 
$x \GETS 1 \SEMI \IF{\aExp}\THEN\  \aCmd \ELSE  \bCmd\FI$.

\end{itemize}

\subsection{Revisiting \oota}
~\citet{DBLP:conf/esop/BattyMNPS15} describe the problem of thin-air executions.~\citet{BoehmOOTA} revisits community discussions on ``\oota'' like examples.  We classify the models on the basis of their behavior on three examples, namely examples~\eqref{oota1}, \eqref{types}, \eqref{alan} and \eqref{rfub}.  
\begin{itemize}
\item RC11\cite{DBLP:conf/pldi/LahavVKHD17}, JMM~\cite{Manson:2005:JMM:1047659.1040336} and the related models of~\citet{DBLP:conf/esop/JagadeesanPR10} and \citet{DBLP:conf/popl/KangHLVD17} forbid only \eqref{oota1}.
\item The model of this paper forbids \eqref{oota1}, \eqref{types} and \eqref{alan}.
\item Forbidding load buffering as per \citep{Dolan:2018:BDR:3192366.3192421,BoehmOOTA} forbids all four examples.  RC11\cite{DBLP:conf/pldi/LahavVKHD17} also forbids all four examples. 
\end{itemize}

One of our novel contributions to this line of research is the desideratum of compositional reasoning of safety properties. The The presence of such compositional reasoning suffices to remove the undesirable effects of \oota, eg. type safety.  And while \oota\ in a model is an elusive creature, and hence hard to prove or disprove,  the support of a model for a compositional proof principle is provable or falsifiable.  

\subsection{Relationship to models of speculation}
The closest formal cousin to our model is that of~\citet{2019-sp}.   In the spectrum from micro architectures to architectures to software,whereas~\citet{2019-sp} lies between the micro and architectural levels, we aim to be as abstract as possible to bridge the gap to programming languages.  This is reflected in the several differences in the formal model.  

We do not track false branches of conditionals, as seen in our monotonicity axiom, whereby any event with a precondition $\FALSE$ can only have $\FALSE$ successors in $\lt$, whereas in that paper, specualtion on false branches can lead to observable effects.   We are also less accurate  about tracking reads, as reflected in the removal of program order between reads and reads.   

~\citet{2019-sp} does not study the properties as a memory model.  While we conjecture that our proofs of DRF and compositional reasoning can be carried over to that setting, we support more compiler optimizations of single threaded code than~\citet{2019-sp}. 



